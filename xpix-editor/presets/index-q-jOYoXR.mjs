var dy = Object.defineProperty;
var uy = (n, t, e) => t in n ? dy(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var Qt = (n, t, e) => (uy(n, typeof t != "symbol" ? t + "" : t, e), e), Jl = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
};
var L = (n, t, e) => (Jl(n, t, "read from private field"), e ? e.call(n) : t.get(n)), _e = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, zt = (n, t, e, s) => (Jl(n, t, "write to private field"), s ? s.call(n, e) : t.set(n, e), e);
var nn = (n, t, e) => (Jl(n, t, "access private method"), e);
import { shallowRef as Bi, inject as jo, triggerRef as Ql, defineComponent as $e, provide as Ga, renderSlot as Yi, openBlock as J, createElementBlock as gt, createElementVNode as O, createStaticVNode as fy, Fragment as Go, createCommentVNode as xe, unref as bt, createVNode as fe, computed as Jn, createBlock as Fe, resolveDynamicComponent as Hh, defineAsyncComponent as $i, ref as so, onMounted as E1, onUnmounted as py, renderList as ru, normalizeClass as gy, normalizeStyle as T1, toDisplayString as gr, onBeforeUnmount as my, watch as _y, normalizeProps as Ho, guardReactiveProps as zo, withCtx as pn, mergeProps as yy, withModifiers as vy } from "vue";
var by = typeof global == "object" && global && global.Object === Object && global, wy = typeof self == "object" && self && self.Object === Object && self, A1 = by || wy || Function("return this")(), Ha = A1.Symbol, I1 = Object.prototype, Sy = I1.hasOwnProperty, Cy = I1.toString, Dr = Ha ? Ha.toStringTag : void 0;
function ky(n) {
  var t = Sy.call(n, Dr), e = n[Dr];
  try {
    n[Dr] = void 0;
    var s = !0;
  } catch {
  }
  var i = Cy.call(n);
  return s && (t ? n[Dr] = e : delete n[Dr]), i;
}
var xy = Object.prototype, Ey = xy.toString;
function Ty(n) {
  return Ey.call(n);
}
var Ay = "[object Null]", Iy = "[object Undefined]", Hf = Ha ? Ha.toStringTag : void 0;
function Oy(n) {
  return n == null ? n === void 0 ? Iy : Ay : Hf && Hf in Object(n) ? ky(n) : Ty(n);
}
function Dy(n) {
  return n != null && typeof n == "object";
}
var Py = "[object Symbol]";
function My(n) {
  return typeof n == "symbol" || Dy(n) && Oy(n) == Py;
}
var Ry = /\s/;
function $y(n) {
  for (var t = n.length; t-- && Ry.test(n.charAt(t)); )
    ;
  return t;
}
var Ny = /^\s+/;
function Ly(n) {
  return n && n.slice(0, $y(n) + 1).replace(Ny, "");
}
function za(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
var zf = NaN, Uy = /^[-+]0x[0-9a-f]+$/i, Fy = /^0b[01]+$/i, By = /^0o[0-7]+$/i, Vy = parseInt;
function Wf(n) {
  if (typeof n == "number")
    return n;
  if (My(n))
    return zf;
  if (za(n)) {
    var t = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = za(t) ? t + "" : t;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = Ly(n);
  var e = Fy.test(n);
  return e || By.test(n) ? Vy(n.slice(2), e ? 2 : 8) : Uy.test(n) ? zf : +n;
}
var Kf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ou(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function jy(n) {
  if (n.__esModule)
    return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function s() {
      return this instanceof s ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else
    e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(s) {
    var i = Object.getOwnPropertyDescriptor(n, s);
    Object.defineProperty(e, s, i.get ? i : {
      enumerable: !0,
      get: function() {
        return n[s];
      }
    });
  }), e;
}
var th = function() {
  return A1.Date.now();
}, Gy = "Expected a function", Hy = Math.max, zy = Math.min;
function Pc(n, t, e) {
  var s, i, r, o, a, c, l = 0, h = !1, d = !1, u = !0;
  if (typeof n != "function")
    throw new TypeError(Gy);
  t = Wf(t) || 0, za(e) && (h = !!e.leading, d = "maxWait" in e, r = d ? Hy(Wf(e.maxWait) || 0, t) : r, u = "trailing" in e ? !!e.trailing : u);
  function f(w) {
    var k = s, C = i;
    return s = i = void 0, l = w, o = n.apply(C, k), o;
  }
  function p(w) {
    return l = w, a = setTimeout(v, t), h ? f(w) : o;
  }
  function m(w) {
    var k = w - c, C = w - l, A = t - k;
    return d ? zy(A, r - C) : A;
  }
  function _(w) {
    var k = w - c, C = w - l;
    return c === void 0 || k >= t || k < 0 || d && C >= r;
  }
  function v() {
    var w = th();
    if (_(w))
      return b(w);
    a = setTimeout(v, m(w));
  }
  function b(w) {
    return a = void 0, u && s ? f(w) : (s = i = void 0, o);
  }
  function g() {
    a !== void 0 && clearTimeout(a), l = 0, s = c = i = a = void 0;
  }
  function y() {
    return a === void 0 ? o : b(th());
  }
  function S() {
    var w = th(), k = _(w);
    if (s = arguments, i = this, c = w, k) {
      if (a === void 0)
        return p(c);
      if (d)
        return clearTimeout(a), a = setTimeout(v, t), f(c);
    }
    return a === void 0 && (a = setTimeout(v, t)), o;
  }
  return S.cancel = g, S.flush = y, S;
}
var Wy = "Expected a function";
function Ky(n, t, e) {
  var s = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(Wy);
  return za(e) && (s = "leading" in e ? !!e.leading : s, i = "trailing" in e ? !!e.trailing : i), Pc(n, t, {
    leading: s,
    maxWait: t,
    trailing: i
  });
}
var no;
(function(n) {
  n[n.DefaultRuntimeError = 1] = "DefaultRuntimeError", n[n.ValueNotExists = 2] = "ValueNotExists", n[n.ValueNotInstanceOf = 3] = "ValueNotInstanceOf", n[n.ValueNotEqual = 4] = "ValueNotEqual", n[n.MIGRATION_ERROR = 5] = "MIGRATION_ERROR", n[n.SCHEMA_VALIDATE_ERROR = 6] = "SCHEMA_VALIDATE_ERROR", n[n.DefaultFatalError = 1e4] = "DefaultFatalError";
})(no || (no = {}));
class Mc extends Error {
  constructor(t, e) {
    super(e), this.name = "BlockSuiteError", this.code = t, this.isFatal = t >= 1e4;
  }
}
function Yy(n) {
  if (!(n instanceof Mc))
    throw n;
  if (n.isFatal)
    throw new Error("A fatal error for BlockSuite occurs, please contact the team if you find this.", { cause: n });
  console.error("A runtime error for BlockSuite occurs, you can ignore this error if it won't break the user experience."), console.error(n.stack);
}
function Yf(n) {
  return n !== Object(n);
}
function B(n, t = "val does not exist") {
  if (n == null)
    throw t instanceof Error ? t : new Mc(no.ValueNotExists, t);
}
function zh(n, t) {
  const e = Yf(n), s = Yf(t);
  if (e && s) {
    if (!Object.is(n, t))
      return !1;
  } else {
    if (e !== s)
      return !1;
    if (Array.isArray(n) && Array.isArray(t))
      return n.length !== t.length ? !1 : n.every((i, r) => zh(i, t[r]));
    if (typeof n == "object" && typeof t == "object") {
      const i = Object.entries(n), r = Object.entries(t);
      return i.length !== r.length ? !1 : i.every((o, a) => zh(o, r[a]));
    }
  }
  return !0;
}
class as {
  constructor() {
    this._disposed = !1, this._disposables = [];
  }
  get disposed() {
    return this._disposed;
  }
  /**
   * Add to group to be disposed with others.
   * This will be immediately disposed if this group has already been disposed.
   */
  add(t) {
    typeof t == "function" ? this._disposed ? t() : this._disposables.push({ dispose: t }) : this._disposed ? t.dispose() : this._disposables.push(t);
  }
  addFromEvent(t, e, s, i) {
    this.add({
      dispose: () => {
        t.removeEventListener(e, s, i);
      }
    }), t.addEventListener(e, s, i);
  }
  dispose() {
    O1(this._disposables), this._disposables = [], this._disposed = !0;
  }
}
function Zy(n) {
  return {
    dispose: () => O1(n)
  };
}
function O1(n) {
  for (const t of n)
    try {
      t.dispose();
    } catch (e) {
      console.error(e);
    }
}
function qy(n, t, { leading: e = !0, trailing: s = !0 } = {}) {
  let i = null, r = null;
  const o = () => {
    r && s ? (n(...r), r = null, i = setTimeout(o, t)) : i = null;
  };
  return function(...a) {
    if (i) {
      r = a;
      return;
    }
    e && n.apply(this, a), i = setTimeout(o, t);
  };
}
class Xy {
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
class lt {
  constructor() {
    this._emitting = !1, this._callbacks = [], this._disposables = [], this.subscribe = (t, e, s) => {
      let i;
      const { filter: r, equalityFn: o = Object.is } = s ?? {};
      return this.on((a) => {
        if (r && !r(a))
          return;
        const c = t(a);
        (i === void 0 || !o(i, c)) && (e(c), i = c);
      });
    };
  }
  filter(t) {
    const e = new lt();
    return this._disposables.push({
      dispose: () => e.dispose()
    }), this.on((s) => {
      t(s) && e.emit(s);
    }), e;
  }
  on(t) {
    if (this._emitting) {
      const e = [...this._callbacks, t];
      this._callbacks = e;
    } else
      this._callbacks.push(t);
    return {
      dispose: () => {
        if (this._emitting)
          this._callbacks = this._callbacks.filter((e) => e !== t);
        else {
          const e = this._callbacks.indexOf(t);
          e > -1 && this._callbacks.splice(e, 1);
        }
      }
    };
  }
  once(t) {
    let e;
    const s = (r) => {
      t(r), e && e();
    }, i = this.on(s);
    return e = i.dispose, i;
  }
  unshift(t) {
    if (this._emitting) {
      const e = [t, ...this._callbacks];
      this._callbacks = e;
    } else
      this._callbacks.unshift(t);
    return {
      dispose: () => {
        if (this._emitting)
          this._callbacks = this._callbacks.filter((e) => e !== t);
        else {
          const e = this._callbacks.indexOf(t);
          e > -1 && this._callbacks.splice(e, 1);
        }
      }
    };
  }
  emit(t) {
    const e = this._emitting;
    this._emitting = !0, this._callbacks.forEach((s) => {
      try {
        s(t);
      } catch (i) {
        console.error(i);
      }
    }), this._emitting = e;
  }
  pipe(t) {
    return this._callbacks.push((e) => t.emit(e)), this;
  }
  dispose() {
    Zy(this._disposables).dispose(), this._callbacks = [], this._disposables = [];
  }
  toDispose(t) {
    return t.push(this), this;
  }
}
const Qn = () => /* @__PURE__ */ new Set(), eh = (n) => n[n.length - 1], Jy = (n, t) => {
  for (let e = 0; e < t.length; e++)
    n.push(t[e]);
}, Gs = Array.from, Qy = (n, t) => {
  for (let e = 0; e < n.length; e++)
    if (t(n[e], e, n))
      return !0;
  return !1;
}, tv = (n, t) => {
  const e = new Array(n);
  for (let s = 0; s < n; s++)
    e[s] = t(s, e);
  return e;
}, Wh = Array.isArray, ev = String.fromCharCode, sv = (n) => n.toLowerCase(), nv = /^\s*/g, iv = (n) => n.replace(nv, ""), rv = /([A-Z])/g, Zf = (n, t) => iv(n.replace(rv, (e) => `${t}${sv(e)}`)), ov = (n) => {
  const t = unescape(encodeURIComponent(n)), e = t.length, s = new Uint8Array(e);
  for (let i = 0; i < e; i++)
    s[i] = /** @type {number} */
    t.codePointAt(i);
  return s;
}, io = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), av = (n) => io.encode(n), cv = io ? av : ov;
let Zr = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Zr && Zr.decode(new Uint8Array()).length === 1 && (Zr = null);
const lv = (n, t) => tv(t, () => n).join(""), he = () => /* @__PURE__ */ new Map(), Kh = (n) => {
  const t = he();
  return n.forEach((e, s) => {
    t.set(s, e);
  }), t;
}, De = (n, t, e) => {
  let s = n.get(t);
  return s === void 0 && n.set(t, s = e()), s;
}, hv = (n, t) => {
  const e = [];
  for (const [s, i] of n)
    e.push(t(i, s));
  return e;
}, dv = (n, t) => {
  for (const [e, s] of n)
    if (t(s, e))
      return !0;
  return !1;
}, qf = (n) => n === void 0 ? null : n;
class uv {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(t, e) {
    this.map.set(t, e);
  }
  /**
   * @param {string} key
   */
  getItem(t) {
    return this.map.get(t);
  }
}
let D1 = new uv(), fv = !0;
try {
  typeof localStorage < "u" && localStorage && (D1 = localStorage, fv = !1);
} catch {
}
const pv = D1, gv = Object.assign, mv = Object.keys, _v = (n, t) => {
  for (const e in n)
    t(n[e], e);
}, Wa = (n) => mv(n).length, yv = (n) => {
  for (const t in n)
    return !1;
  return !0;
}, vv = (n, t) => {
  for (const e in n)
    if (!t(n[e], e))
      return !1;
  return !0;
}, P1 = (n, t) => Object.prototype.hasOwnProperty.call(n, t), bv = (n, t) => n === t || Wa(n) === Wa(t) && vv(n, (e, s) => (e !== void 0 || P1(t, s)) && t[s] === e), au = (n, t, e = 0) => {
  try {
    for (; e < n.length; e++)
      n[e](...t);
  } finally {
    e < n.length && au(n, t, e + 1);
  }
}, M1 = (n) => n, wv = (n, t) => n === t, Aa = (n, t) => {
  if (n == null || t == null)
    return wv(n, t);
  if (n.constructor !== t.constructor)
    return !1;
  if (n === t)
    return !0;
  switch (n.constructor) {
    case ArrayBuffer:
      n = new Uint8Array(n), t = new Uint8Array(t);
    case Uint8Array: {
      if (n.byteLength !== t.byteLength)
        return !1;
      for (let e = 0; e < n.length; e++)
        if (n[e] !== t[e])
          return !1;
      break;
    }
    case Set: {
      if (n.size !== t.size)
        return !1;
      for (const e of n)
        if (!t.has(e))
          return !1;
      break;
    }
    case Map: {
      if (n.size !== t.size)
        return !1;
      for (const e of n.keys())
        if (!t.has(e) || !Aa(n.get(e), t.get(e)))
          return !1;
      break;
    }
    case Object:
      if (Wa(n) !== Wa(t))
        return !1;
      for (const e in n)
        if (!P1(n, e) || !Aa(n[e], t[e]))
          return !1;
      break;
    case Array:
      if (n.length !== t.length)
        return !1;
      for (let e = 0; e < n.length; e++)
        if (!Aa(n[e], t[e]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, Sv = (n, t) => t.includes(n), tr = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", Cv = typeof window < "u" && typeof document < "u" && !tr;
let ps;
const kv = () => {
  if (ps === void 0)
    if (tr) {
      ps = he();
      const n = process.argv;
      let t = null;
      for (let e = 0; e < n.length; e++) {
        const s = n[e];
        s[0] === "-" ? (t !== null && ps.set(t, ""), t = s) : t !== null && (ps.set(t, s), t = null);
      }
      t !== null && ps.set(t, "");
    } else
      typeof location == "object" ? (ps = he(), (location.search || "?").slice(1).split("&").forEach((n) => {
        if (n.length !== 0) {
          const [t, e] = n.split("=");
          ps.set(`--${Zf(t, "-")}`, e), ps.set(`-${Zf(t, "-")}`, e);
        }
      })) : ps = he();
  return ps;
}, Yh = (n) => kv().has(n), Zh = (n) => qf(tr ? process.env[n.toUpperCase().replaceAll("-", "_")] : pv.getItem(n)), xv = (n) => Yh("--" + n) || Zh(n) !== null;
xv("production");
const Xf = tr && Sv(process.env.FORCE_COLOR, ["true", "1", "2"]), Ev = !Yh("no-colors") && (!tr || process.stdout.isTTY || Xf) && (!tr || Yh("color") || Xf || Zh("COLORTERM") !== null || (Zh("TERM") || "").includes("color")), Hs = Math.floor, Ia = Math.abs, R1 = (n, t) => n < t ? n : t, ui = (n, t) => n > t ? n : t, $1 = (n) => n !== 0 ? n < 0 : 1 / n < 0, Jf = 1, Qf = 2, sh = 4, nh = 8, ro = 32, Us = 64, Ae = 128, Tv = 1 << 29, Rc = 31, qh = 63, zn = 127, Av = 2147483647, N1 = Number.MAX_SAFE_INTEGER, Iv = Number.isInteger || ((n) => typeof n == "number" && isFinite(n) && Hs(n) === n);
class Wo {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const mr = () => new Wo(), Ov = (n) => {
  let t = n.cpos;
  for (let e = 0; e < n.bufs.length; e++)
    t += n.bufs[e].length;
  return t;
}, We = (n) => {
  const t = new Uint8Array(Ov(n));
  let e = 0;
  for (let s = 0; s < n.bufs.length; s++) {
    const i = n.bufs[s];
    t.set(i, e), e += i.length;
  }
  return t.set(new Uint8Array(n.cbuf.buffer, 0, n.cpos), e), t;
}, Dv = (n, t) => {
  const e = n.cbuf.length;
  e - n.cpos < t && (n.bufs.push(new Uint8Array(n.cbuf.buffer, 0, n.cpos)), n.cbuf = new Uint8Array(ui(e, t) * 2), n.cpos = 0);
}, le = (n, t) => {
  const e = n.cbuf.length;
  n.cpos === e && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(e * 2), n.cpos = 0), n.cbuf[n.cpos++] = t;
}, oo = le, et = (n, t) => {
  for (; t > zn; )
    le(n, Ae | zn & t), t = Hs(t / 128);
  le(n, zn & t);
}, $c = (n, t) => {
  const e = $1(t);
  for (e && (t = -t), le(n, (t > qh ? Ae : 0) | (e ? Us : 0) | qh & t), t = Hs(t / 64); t > 0; )
    le(n, (t > zn ? Ae : 0) | zn & t), t = Hs(t / 128);
}, Xh = new Uint8Array(3e4), Pv = Xh.length / 3, Mv = (n, t) => {
  if (t.length < Pv) {
    const e = io.encodeInto(t, Xh).written || 0;
    et(n, e);
    for (let s = 0; s < e; s++)
      le(n, Xh[s]);
  } else
    Ne(n, cv(t));
}, Rv = (n, t) => {
  const e = unescape(encodeURIComponent(t)), s = e.length;
  et(n, s);
  for (let i = 0; i < s; i++)
    le(
      n,
      /** @type {number} */
      e.codePointAt(i)
    );
}, Wn = io && /** @type {any} */
io.encodeInto ? Mv : Rv, $v = (n, t) => Ko(n, We(t)), Ko = (n, t) => {
  const e = n.cbuf.length, s = n.cpos, i = R1(e - s, t.length), r = t.length - i;
  n.cbuf.set(t.subarray(0, i), s), n.cpos += i, r > 0 && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(ui(e * 2, r)), n.cbuf.set(t.subarray(i)), n.cpos = r);
}, Ne = (n, t) => {
  et(n, t.byteLength), Ko(n, t);
}, cu = (n, t) => {
  Dv(n, t);
  const e = new DataView(n.cbuf.buffer, n.cpos, t);
  return n.cpos += t, e;
}, Nv = (n, t) => cu(n, 4).setFloat32(0, t, !1), Lv = (n, t) => cu(n, 8).setFloat64(0, t, !1), Uv = (n, t) => (
  /** @type {any} */
  cu(n, 8).setBigInt64(0, t, !1)
), tp = new DataView(new ArrayBuffer(4)), Fv = (n) => (tp.setFloat32(0, n), tp.getFloat32(0) === n), ao = (n, t) => {
  switch (typeof t) {
    case "string":
      le(n, 119), Wn(n, t);
      break;
    case "number":
      Iv(t) && Ia(t) <= Av ? (le(n, 125), $c(n, t)) : Fv(t) ? (le(n, 124), Nv(n, t)) : (le(n, 123), Lv(n, t));
      break;
    case "bigint":
      le(n, 122), Uv(n, t);
      break;
    case "object":
      if (t === null)
        le(n, 126);
      else if (Wh(t)) {
        le(n, 117), et(n, t.length);
        for (let e = 0; e < t.length; e++)
          ao(n, t[e]);
      } else if (t instanceof Uint8Array)
        le(n, 116), Ne(n, t);
      else {
        le(n, 118);
        const e = Object.keys(t);
        et(n, e.length);
        for (let s = 0; s < e.length; s++) {
          const i = e[s];
          Wn(n, i), ao(n, t[i]);
        }
      }
      break;
    case "boolean":
      le(n, t ? 120 : 121);
      break;
    default:
      le(n, 127);
  }
};
class ep extends Wo {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(t) {
    super(), this.w = t, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(t) {
    this.s === t ? this.count++ : (this.count > 0 && et(this, this.count - 1), this.count = 1, this.w(this, t), this.s = t);
  }
}
const sp = (n) => {
  n.count > 0 && ($c(n.encoder, n.count === 1 ? n.s : -n.s), n.count > 1 && et(n.encoder, n.count - 2));
};
class Oa {
  constructor() {
    this.encoder = new Wo(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(t) {
    this.s === t ? this.count++ : (sp(this), this.count = 1, this.s = t);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return sp(this), We(this.encoder);
  }
}
const np = (n) => {
  if (n.count > 0) {
    const t = n.diff * 2 + (n.count === 1 ? 0 : 1);
    $c(n.encoder, t), n.count > 1 && et(n.encoder, n.count - 2);
  }
};
class ih {
  constructor() {
    this.encoder = new Wo(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(t) {
    this.diff === t - this.s ? (this.s = t, this.count++) : (np(this), this.count = 1, this.diff = t - this.s, this.s = t);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return np(this), We(this.encoder);
  }
}
class Bv {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Oa();
  }
  /**
   * @param {string} string
   */
  write(t) {
    this.s += t, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(t.length);
  }
  toUint8Array() {
    const t = new Wo();
    return this.sarr.push(this.s), this.s = "", Wn(t, this.sarr.join("")), Ko(t, this.lensE.toUint8Array()), We(t);
  }
}
const zs = (n) => new Error(n), bs = () => {
  throw zs("Method unimplemented");
}, Re = () => {
  throw zs("Unexpected case");
}, L1 = zs("Unexpected end of array"), U1 = zs("Integer out of Range");
class Nc {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(t) {
    this.arr = t, this.pos = 0;
  }
}
const be = (n) => new Nc(n), F1 = (n) => n.pos !== n.arr.length, Vv = (n, t) => {
  const e = new Uint8Array(n.arr.buffer, n.pos + n.arr.byteOffset, t);
  return n.pos += t, e;
}, Le = (n) => Vv(n, ct(n)), er = (n) => n.arr[n.pos++], ct = (n) => {
  let t = 0, e = 1;
  const s = n.arr.length;
  for (; n.pos < s; ) {
    const i = n.arr[n.pos++];
    if (t = t + (i & zn) * e, e *= 128, i < Ae)
      return t;
    if (t > N1)
      throw U1;
  }
  throw L1;
}, Lc = (n) => {
  let t = n.arr[n.pos++], e = t & qh, s = 64;
  const i = (t & Us) > 0 ? -1 : 1;
  if (!(t & Ae))
    return i * e;
  const r = n.arr.length;
  for (; n.pos < r; ) {
    if (t = n.arr[n.pos++], e = e + (t & zn) * s, s *= 128, t < Ae)
      return i * e;
    if (e > N1)
      throw U1;
  }
  throw L1;
}, jv = (n) => {
  let t = ct(n);
  if (t === 0)
    return "";
  {
    let e = String.fromCodePoint(er(n));
    if (--t < 100)
      for (; t--; )
        e += String.fromCodePoint(er(n));
    else
      for (; t > 0; ) {
        const s = t < 1e4 ? t : 1e4, i = n.arr.subarray(n.pos, n.pos + s);
        n.pos += s, e += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), t -= s;
      }
    return decodeURIComponent(escape(e));
  }
}, Gv = (n) => (
  /** @type any */
  Zr.decode(Le(n))
), Kn = Zr ? Gv : jv, lu = (n, t) => {
  const e = new DataView(n.arr.buffer, n.arr.byteOffset + n.pos, t);
  return n.pos += t, e;
}, Hv = (n) => lu(n, 4).getFloat32(0, !1), zv = (n) => lu(n, 8).getFloat64(0, !1), Wv = (n) => (
  /** @type {any} */
  lu(n, 8).getBigInt64(0, !1)
), Kv = [
  (n) => {
  },
  // CASE 127: undefined
  (n) => null,
  // CASE 126: null
  Lc,
  // CASE 125: integer
  Hv,
  // CASE 124: float32
  zv,
  // CASE 123: float64
  Wv,
  // CASE 122: bigint
  (n) => !1,
  // CASE 121: boolean (false)
  (n) => !0,
  // CASE 120: boolean (true)
  Kn,
  // CASE 119: string
  (n) => {
    const t = ct(n), e = {};
    for (let s = 0; s < t; s++) {
      const i = Kn(n);
      e[i] = co(n);
    }
    return e;
  },
  (n) => {
    const t = ct(n), e = [];
    for (let s = 0; s < t; s++)
      e.push(co(n));
    return e;
  },
  Le
  // CASE 116: Uint8Array
], co = (n) => Kv[127 - er(n)](n);
class ip extends Nc {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(t, e) {
    super(t), this.reader = e, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), F1(this) ? this.count = ct(this) + 1 : this.count = -1), this.count--, /** @type {T} */
    this.s;
  }
}
class Da extends Nc {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(t) {
    super(t), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Lc(this);
      const t = $1(this.s);
      this.count = 1, t && (this.s = -this.s, this.count = ct(this) + 2);
    }
    return this.count--, /** @type {number} */
    this.s;
  }
}
class rh extends Nc {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(t) {
    super(t), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const t = Lc(this), e = t & 1;
      this.diff = Hs(t / 2), this.count = 1, e && (this.count = ct(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class Yv {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(t) {
    this.decoder = new Da(t), this.str = Kn(this.decoder), this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const t = this.spos + this.decoder.read(), e = this.str.slice(this.spos, t);
    return this.spos = t, e;
  }
}
const Zv = (n) => new Uint8Array(n), qv = (n) => {
  let t = "";
  for (let e = 0; e < n.byteLength; e++)
    t += ev(n[e]);
  return btoa(t);
}, Xv = (n) => Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("base64"), Jv = Cv ? qv : Xv, Qv = (n) => {
  const t = Zv(n.byteLength);
  return t.set(n), t;
}, ws = (n, t) => n >>> t | n << 32 - t, t4 = (n) => ws(n, 2) ^ ws(n, 13) ^ ws(n, 22), e4 = (n) => ws(n, 6) ^ ws(n, 11) ^ ws(n, 25), s4 = (n) => ws(n, 7) ^ ws(n, 18) ^ n >>> 3, n4 = (n) => ws(n, 17) ^ ws(n, 19) ^ n >>> 10, i4 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), r4 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
class o4 {
  constructor() {
    const t = new ArrayBuffer(320);
    this._H = new Uint32Array(t, 0, 8), this._H.set(r4), this._W = new Uint32Array(t, 64, 64);
  }
  _updateHash() {
    const t = this._H, e = this._W;
    for (let d = 16; d < 64; d++)
      e[d] = n4(e[d - 2]) + e[d - 7] + s4(e[d - 15]) + e[d - 16];
    let s = t[0], i = t[1], r = t[2], o = t[3], a = t[4], c = t[5], l = t[6], h = t[7];
    for (let d = 0, u, f; d < 64; d++)
      u = h + e4(a) + (a & c ^ ~a & l) + i4[d] + e[d] >>> 0, f = t4(s) + (s & i ^ s & r ^ i & r) >>> 0, h = l, l = c, c = a, a = o + u >>> 0, o = r, r = i, i = s, s = u + f >>> 0;
    t[0] += s, t[1] += i, t[2] += r, t[3] += o, t[4] += a, t[5] += c, t[6] += l, t[7] += h;
  }
  /**
   * @param {Uint8Array} data
   */
  digest(t) {
    let e = 0;
    for (; e + 56 <= t.length; ) {
      let o = 0;
      for (; o < 16 && e + 3 < t.length; o++)
        this._W[o] = t[e++] << 24 | t[e++] << 16 | t[e++] << 8 | t[e++];
      if (e % 64 !== 0) {
        for (this._W.fill(0, o, 16); e < t.length; )
          this._W[o] |= t[e] << (3 - e % 4) * 8, e++;
        this._W[o] |= Ae << (3 - e % 4) * 8;
      }
      this._updateHash();
    }
    const s = e % 64 !== 0;
    this._W.fill(0, 0, 16);
    let i = 0;
    for (; e < t.length; i++)
      for (let o = 3; o >= 0 && e < t.length; o--)
        this._W[i] |= t[e++] << o * 8;
    s || (this._W[i - (e % 4 === 0 ? 0 : 1)] |= Ae << (3 - e % 4) * 8), this._W[14] = t.byteLength / Tv, this._W[15] = t.byteLength * 8, this._updateHash();
    const r = new Uint8Array(32);
    for (let o = 0; o < this._H.length; o++)
      for (let a = 0; a < 4; a++)
        r[o * 4 + a] = this._H[o] >>> (3 - a) * 8;
    return r;
  }
}
const a4 = (n) => new o4().digest(n);
async function c4(n) {
  const t = crypto.subtle === void 0 ? a4(new Uint8Array(n)) : await crypto.subtle.digest("SHA-256", n);
  return Jv(new Uint8Array(t)).replace(/\+/g, "-").replace(/\//g, "_");
}
const l4 = /* @__PURE__ */ new Map([
  ["audio/aac", "aac"],
  ["application/x-abiword", "abw"],
  ["image/apng", "apng"],
  ["application/x-freearc", "arc"],
  ["image/avif", "avif"],
  ["video/x-msvideo", "avi"],
  ["application/vnd.amazon.ebook", "azw"],
  ["application/octet-stream", "bin"],
  ["image/bmp", "bmp"],
  ["application/x-bzip", "bz"],
  ["application/x-bzip2", "bz2"],
  ["application/x-cdf", "cda"],
  ["application/x-csh", "csh"],
  ["text/css", "css"],
  ["text/csv", "csv"],
  ["application/msword", "doc"],
  [
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "docx"
  ],
  ["application/vnd.ms-fontobject", "eot"],
  ["application/epub+zip", "epub"],
  ["application/gzip", "gz"],
  ["image/gif", "gif"],
  ["text/html", "html"],
  ["image/vnd.microsoft.icon", "ico"],
  ["text/calendar", "ics"],
  ["application/java-archive", "jar"],
  ["image/jpeg", "jpeg"],
  ["text/javascript", "js"],
  ["application/json", "json"],
  ["application/ld+json", "jsonld"],
  ["audio/midi", "mid"],
  ["audio/x-midi", "midi"],
  ["audio/mpeg", "mp3"],
  ["video/mp4", "mp4"],
  ["video/mpeg", "mpeg"],
  ["application/vnd.apple.installer+xml", "mpkg"],
  ["application/vnd.oasis.opendocument.presentation", "odp"],
  ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
  ["application/vnd.oasis.opendocument.text", "odt"],
  ["audio/ogg", "oga"],
  ["video/ogg", "ogv"],
  ["application/ogg", "ogx"],
  ["audio/opus", "opus"],
  ["font/otf", "otf"],
  ["image/png", "png"],
  ["application/pdf", "pdf"],
  ["application/x-httpd-php", "php"],
  ["application/vnd.ms-powerpoint", "ppt"],
  [
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "pptx"
  ],
  ["application/vnd.rar", "rar"],
  ["application/rtf", "rtf"],
  ["application/x-sh", "sh"],
  ["image/svg+xml", "svg"],
  ["application/x-tar", "tar"],
  ["image/tiff", "tiff"],
  ["video/mp2t", "ts"],
  ["font/ttf", "ttf"],
  ["text/plain", "txt"],
  ["application/vnd.visio", "vsd"],
  ["audio/wav", "wav"],
  ["audio/webm", "weba"],
  ["video/webm", "webm"],
  ["image/webp", "webp"],
  ["font/woff", "woff"],
  ["font/woff2", "woff2"],
  ["application/xhtml+xml", "xhtml"],
  ["application/vnd.ms-excel", "xls"],
  ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
  ["application/xml", "xml"],
  ["text/xml", "xml"],
  ["application/vnd.mozilla.xul+xml", "xul"],
  ["application/zip", "zip"],
  ["application/zstd", "zst"],
  ["video/3gpp", "3gp"],
  ["audio/3gpp", "3gp"],
  ["video/3gpp2", "3g2"],
  ["audio/3gpp2", "3g2"],
  ["application/x-7z-compressed", "7z"]
]);
new Map(Array.from(l4.entries()).map(([n, t]) => [t, n]));
const h4 = [
  {
    desc: "add pageVersion in meta",
    condition: (n) => n.getMap("meta").get("workspaceVersion") < 2,
    migrate: (n) => {
      const t = n.getMap("meta");
      t.set("pageVersion", 1), t.set("workspaceVersion", 2);
    }
  }
];
class hu {
  constructor() {
    this._observers = he();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(t, e) {
    return De(
      this._observers,
      /** @type {string} */
      t,
      Qn
    ).add(e), e;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(t, e) {
    const s = (...i) => {
      this.off(
        t,
        /** @type {any} */
        s
      ), e(...i);
    };
    this.on(
      t,
      /** @type {any} */
      s
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(t, e) {
    const s = this._observers.get(t);
    s !== void 0 && (s.delete(e), s.size === 0 && this._observers.delete(t));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(t, e) {
    return Gs((this._observers.get(t) || he()).values()).forEach((s) => s(...e));
  }
  destroy() {
    this._observers = he();
  }
}
let B1 = class {
  constructor() {
    this._observers = he();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(t, e) {
    De(this._observers, t, Qn).add(e);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(t, e) {
    const s = (...i) => {
      this.off(t, s), e(...i);
    };
    this.on(t, s);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(t, e) {
    const s = this._observers.get(t);
    s !== void 0 && (s.delete(e), s.size === 0 && this._observers.delete(t));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(t, e) {
    return Gs((this._observers.get(t) || he()).values()).forEach((s) => s(...e));
  }
  destroy() {
    this._observers = he();
  }
};
const d4 = crypto.getRandomValues.bind(crypto), V1 = () => d4(new Uint32Array(1))[0], u4 = "10000000-1000-4000-8000" + -1e11, du = () => u4.replace(
  /[018]/g,
  /** @param {number} c */
  (n) => (n ^ V1() & 15 >> n / 4).toString(16)
), Ka = Date.now, sr = (n) => (
  /** @type {Promise<T>} */
  new Promise(n)
);
Promise.all.bind(Promise);
class f4 {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(t, e) {
    this.left = t, this.right = e;
  }
}
const Is = (n, t) => new f4(n, t);
typeof DOMParser < "u" && new DOMParser();
const p4 = (n) => hv(n, (t, e) => `${e}:${t};`).join(""), Zs = Symbol, j1 = Zs(), G1 = Zs(), g4 = Zs(), m4 = Zs(), _4 = Zs(), H1 = Zs(), y4 = Zs(), uu = Zs(), v4 = Zs(), b4 = (n) => {
  var s;
  n.length === 1 && ((s = n[0]) == null ? void 0 : s.constructor) === Function && (n = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  n[0]());
  const t = [];
  let e = 0;
  for (; e < n.length; e++) {
    const i = n[e];
    i === void 0 || i.constructor === String || i.constructor === Number || i.constructor === Object && t.push(JSON.stringify(i));
  }
  return t;
}, w4 = {
  [j1]: Is("font-weight", "bold"),
  [G1]: Is("font-weight", "normal"),
  [g4]: Is("color", "blue"),
  [_4]: Is("color", "green"),
  [m4]: Is("color", "grey"),
  [H1]: Is("color", "red"),
  [y4]: Is("color", "purple"),
  [uu]: Is("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [v4]: Is("color", "black")
}, S4 = (n) => {
  var o;
  n.length === 1 && ((o = n[0]) == null ? void 0 : o.constructor) === Function && (n = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  n[0]());
  const t = [], e = [], s = he();
  let i = [], r = 0;
  for (; r < n.length; r++) {
    const a = n[r], c = w4[a];
    if (c !== void 0)
      s.set(c.left, c.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const l = p4(s);
        r > 0 || l.length > 0 ? (t.push("%c" + a), e.push(l)) : t.push(a);
      } else
        break;
    }
  }
  for (r > 0 && (i = e, i.unshift(t.join(""))); r < n.length; r++) {
    const a = n[r];
    a instanceof Symbol || i.push(a);
  }
  return i;
}, z1 = Ev ? S4 : b4, Jh = (...n) => {
  console.log(...z1(n)), W1.forEach((t) => t.print(n));
}, C4 = (...n) => {
  console.warn(...z1(n)), n.unshift(uu), W1.forEach((t) => t.print(n));
}, W1 = Qn(), K1 = (n) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: n
}), k4 = (n, t) => K1(() => {
  let e;
  do
    e = n.next();
  while (!e.done && !t(e.value));
  return e;
}), oh = (n, t) => K1(() => {
  const { done: e, value: s } = n.next();
  return { done: e, value: e ? void 0 : t(s) };
});
class x4 extends hu {
  /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */
  constructor(t, e) {
    super(), this.doc = t, this.awareness = e;
  }
}
class fu {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(t, e) {
    this.clock = t, this.len = e;
  }
}
class _r {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const ti = (n, t, e) => t.clients.forEach((s, i) => {
  const r = (
    /** @type {Array<GC|Item>} */
    n.doc.store.clients.get(i)
  );
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    og(n, r, a.clock, a.len, e);
  }
}), E4 = (n, t) => {
  let e = 0, s = n.length - 1;
  for (; e <= s; ) {
    const i = Hs((e + s) / 2), r = n[i], o = r.clock;
    if (o <= t) {
      if (t < o + r.len)
        return i;
      e = i + 1;
    } else
      s = i - 1;
  }
  return null;
}, fi = (n, t) => {
  const e = n.clients.get(t.client);
  return e !== void 0 && E4(e, t.clock) !== null;
}, pu = (n) => {
  n.clients.forEach((t) => {
    t.sort((i, r) => i.clock - r.clock);
    let e, s;
    for (e = 1, s = 1; e < t.length; e++) {
      const i = t[s - 1], r = t[e];
      i.clock + i.len >= r.clock ? i.len = ui(i.len, r.clock + r.len - i.clock) : (s < e && (t[s] = r), s++);
    }
    t.length = s;
  });
}, nr = (n) => {
  const t = new _r();
  for (let e = 0; e < n.length; e++)
    n[e].clients.forEach((s, i) => {
      if (!t.clients.has(i)) {
        const r = s.slice();
        for (let o = e + 1; o < n.length; o++)
          Jy(r, n[o].clients.get(i) || []);
        t.clients.set(i, r);
      }
    });
  return pu(t), t;
}, lo = (n, t, e, s) => {
  De(n.clients, t, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new fu(e, s));
}, Uc = () => new _r(), gu = (n) => {
  const t = Uc();
  return n.clients.forEach((e, s) => {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      if (o.deleted) {
        const a = o.id.clock;
        let c = o.length;
        if (r + 1 < e.length)
          for (let l = e[r + 1]; r + 1 < e.length && l.deleted; l = e[++r + 1])
            c += l.length;
        i.push(new fu(a, c));
      }
    }
    i.length > 0 && t.clients.set(s, i);
  }), t;
}, Cs = (n, t) => {
  et(n.restEncoder, t.clients.size), Gs(t.clients.entries()).sort((e, s) => s[0] - e[0]).forEach(([e, s]) => {
    n.resetDsCurVal(), et(n.restEncoder, e);
    const i = s.length;
    et(n.restEncoder, i);
    for (let r = 0; r < i; r++) {
      const o = s[r];
      n.writeDsClock(o.clock), n.writeDsLen(o.len);
    }
  });
}, Ws = (n) => {
  const t = new _r(), e = ct(n.restDecoder);
  for (let s = 0; s < e; s++) {
    n.resetDsCurVal();
    const i = ct(n.restDecoder), r = ct(n.restDecoder);
    if (r > 0) {
      const o = De(t.clients, i, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let a = 0; a < r; a++)
        o.push(new fu(n.readDsClock(), n.readDsLen()));
    }
  }
  return t;
}, rp = (n, t, e) => {
  const s = new _r(), i = ct(n.restDecoder);
  for (let r = 0; r < i; r++) {
    n.resetDsCurVal();
    const o = ct(n.restDecoder), a = ct(n.restDecoder), c = e.clients.get(o) || [], l = Bt(e, o);
    for (let h = 0; h < a; h++) {
      const d = n.readDsClock(), u = d + n.readDsLen();
      if (d < l) {
        l < u && lo(s, o, l, u - l);
        let f = Ke(c, d), p = c[f];
        for (!p.deleted && p.id.clock < d && (c.splice(f + 1, 0, qa(t, p, d - p.id.clock)), f++); f < c.length && (p = c[f++], p.id.clock < u); )
          p.deleted || (u < p.id.clock + p.length && c.splice(f, 0, qa(t, p, u - p.id.clock)), p.delete(t));
      } else
        lo(s, o, d, u - d);
    }
  }
  if (s.clients.size > 0) {
    const r = new cs();
    return et(r.restEncoder, 0), Cs(r, s), r.toUint8Array();
  }
  return null;
}, Y1 = (n, t) => {
  if (n.clients.size !== t.clients.size)
    return !1;
  for (const [e, s] of n.clients.entries()) {
    const i = (
      /** @type {Array<import('../internals.js').DeleteItem>} */
      t.clients.get(e)
    );
    if (i === void 0 || s.length !== i.length)
      return !1;
    for (let r = 0; r < s.length; r++) {
      const o = s[r], a = i[r];
      if (o.clock !== a.clock || o.len !== a.len)
        return !1;
    }
  }
  return !0;
}, Z1 = V1;
let Tn = class q1 extends hu {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: t = du(), collectionid: e = null, gc: s = !0, gcFilter: i = () => !0, meta: r = null, autoLoad: o = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = s, this.gcFilter = i, this.clientID = Z1(), this.guid = t, this.collectionid = e, this.share = /* @__PURE__ */ new Map(), this.store = new ig(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = o, this.meta = r, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = sr((l) => {
      this.on("load", () => {
        this.isLoaded = !0, l(this);
      });
    });
    const c = () => sr((l) => {
      const h = (d) => {
        (d === void 0 || d === !0) && (this.off("sync", h), l());
      };
      this.on("sync", h);
    });
    this.on("sync", (l) => {
      l === !1 && this.isSynced && (this.whenSynced = c()), this.isSynced = l === void 0 || l === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = c();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const t = this._item;
    t !== null && !this.shouldLoad && kt(
      /** @type {any} */
      t.parent.doc,
      (e) => {
        e.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Gs(this.subdocs).map((t) => t.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(t, e = null) {
    return kt(this, t, e);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(t, e = (
    /** @type {any} */
    se
  )) {
    const s = De(this.share, t, () => {
      const r = new e();
      return r._integrate(this, null), r;
    }), i = s.constructor;
    if (e !== se && i !== e)
      if (i === se) {
        const r = new e();
        r._map = s._map, s._map.forEach(
          /** @param {Item?} n */
          (o) => {
            for (; o !== null; o = o.left)
              o.parent = r;
          }
        ), r._start = s._start;
        for (let o = r._start; o !== null; o = o.right)
          o.parent = r;
        return r._length = s._length, this.share.set(t, r), r._integrate(this, null), /** @type {InstanceType<Type>} */
        r;
      } else
        throw new Error(`Type with the name ${t} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      s
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(t = "") {
    return (
      /** @type {YArray<T>} */
      this.get(t, de)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(t = "") {
    return this.get(t, pe);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(t = "") {
    return (
      /** @type {YMap<T>} */
      this.get(t, ne)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(t = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(t, mn)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(t = "") {
    return this.get(t, gn);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const t = {};
    return this.share.forEach((e, s) => {
      t[s] = e.toJSON();
    }), t;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    Gs(this.subdocs).forEach((e) => e.destroy());
    const t = this._item;
    if (t !== null) {
      this._item = null;
      const e = (
        /** @type {ContentDoc} */
        t.content
      );
      e.doc = new q1({ guid: this.guid, ...e.opts, shouldLoad: !1 }), e.doc._item = t, kt(
        /** @type {any} */
        t.parent.doc,
        (s) => {
          const i = e.doc;
          t.deleted || s.subdocsAdded.add(i), s.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
};
class ho {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(t) {
    this.restDecoder = t;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return ct(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return ct(this.restDecoder);
  }
}
class Ze extends ho {
  /**
   * @return {ID}
   */
  readLeftID() {
    return st(ct(this.restDecoder), ct(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return st(ct(this.restDecoder), ct(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return ct(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return er(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return Kn(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return ct(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return ct(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return ct(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return co(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return Qv(Le(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(Kn(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return Kn(this.restDecoder);
  }
}
class X1 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(t) {
    this.dsCurrVal = 0, this.restDecoder = t;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return this.dsCurrVal += ct(this.restDecoder), this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const t = ct(this.restDecoder) + 1;
    return this.dsCurrVal += t, t;
  }
}
class Be extends X1 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(t) {
    super(t), this.keys = [], ct(t), this.keyClockDecoder = new rh(Le(t)), this.clientDecoder = new Da(Le(t)), this.leftClockDecoder = new rh(Le(t)), this.rightClockDecoder = new rh(Le(t)), this.infoDecoder = new ip(Le(t), er), this.stringDecoder = new Yv(Le(t)), this.parentInfoDecoder = new ip(Le(t), er), this.typeRefDecoder = new Da(Le(t)), this.lenDecoder = new Da(Le(t));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new Yn(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new Yn(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return co(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return Le(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return co(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const t = this.keyClockDecoder.read();
    if (t < this.keys.length)
      return this.keys[t];
    {
      const e = this.stringDecoder.read();
      return this.keys.push(e), e;
    }
  }
}
class ir {
  constructor() {
    this.restEncoder = mr();
  }
  toUint8Array() {
    return We(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(t) {
    et(this.restEncoder, t);
  }
  /**
   * @param {number} len
   */
  writeDsLen(t) {
    et(this.restEncoder, t);
  }
}
class An extends ir {
  /**
   * @param {ID} id
   */
  writeLeftID(t) {
    et(this.restEncoder, t.client), et(this.restEncoder, t.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(t) {
    et(this.restEncoder, t.client), et(this.restEncoder, t.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(t) {
    et(this.restEncoder, t);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(t) {
    oo(this.restEncoder, t);
  }
  /**
   * @param {string} s
   */
  writeString(t) {
    Wn(this.restEncoder, t);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(t) {
    et(this.restEncoder, t ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(t) {
    et(this.restEncoder, t);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(t) {
    et(this.restEncoder, t);
  }
  /**
   * @param {any} any
   */
  writeAny(t) {
    ao(this.restEncoder, t);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(t) {
    Ne(this.restEncoder, t);
  }
  /**
   * @param {any} embed
   */
  writeJSON(t) {
    Wn(this.restEncoder, JSON.stringify(t));
  }
  /**
   * @param {string} key
   */
  writeKey(t) {
    Wn(this.restEncoder, t);
  }
}
class Fc {
  constructor() {
    this.restEncoder = mr(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return We(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(t) {
    const e = t - this.dsCurrVal;
    this.dsCurrVal = t, et(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(t) {
    t === 0 && Re(), et(this.restEncoder, t - 1), this.dsCurrVal += t;
  }
}
class cs extends Fc {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new ih(), this.clientEncoder = new Oa(), this.leftClockEncoder = new ih(), this.rightClockEncoder = new ih(), this.infoEncoder = new ep(oo), this.stringEncoder = new Bv(), this.parentInfoEncoder = new ep(oo), this.typeRefEncoder = new Oa(), this.lenEncoder = new Oa();
  }
  toUint8Array() {
    const t = mr();
    return et(t, 0), Ne(t, this.keyClockEncoder.toUint8Array()), Ne(t, this.clientEncoder.toUint8Array()), Ne(t, this.leftClockEncoder.toUint8Array()), Ne(t, this.rightClockEncoder.toUint8Array()), Ne(t, We(this.infoEncoder)), Ne(t, this.stringEncoder.toUint8Array()), Ne(t, We(this.parentInfoEncoder)), Ne(t, this.typeRefEncoder.toUint8Array()), Ne(t, this.lenEncoder.toUint8Array()), Ko(t, We(this.restEncoder)), We(t);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(t) {
    this.clientEncoder.write(t.client), this.leftClockEncoder.write(t.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(t) {
    this.clientEncoder.write(t.client), this.rightClockEncoder.write(t.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(t) {
    this.clientEncoder.write(t);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(t) {
    this.infoEncoder.write(t);
  }
  /**
   * @param {string} s
   */
  writeString(t) {
    this.stringEncoder.write(t);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(t) {
    this.parentInfoEncoder.write(t ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(t) {
    this.typeRefEncoder.write(t);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(t) {
    this.lenEncoder.write(t);
  }
  /**
   * @param {any} any
   */
  writeAny(t) {
    ao(this.restEncoder, t);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(t) {
    Ne(this.restEncoder, t);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(t) {
    ao(this.restEncoder, t);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(t) {
    const e = this.keyMap.get(t);
    e === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(t)) : this.keyClockEncoder.write(e);
  }
}
const T4 = (n, t, e, s) => {
  s = ui(s, t[0].id.clock);
  const i = Ke(t, s);
  et(n.restEncoder, t.length - i), n.writeClient(e), et(n.restEncoder, s);
  const r = t[i];
  r.write(n, s - r.id.clock);
  for (let o = i + 1; o < t.length; o++)
    t[o].write(n, 0);
}, mu = (n, t, e) => {
  const s = /* @__PURE__ */ new Map();
  e.forEach((i, r) => {
    Bt(t, r) > i && s.set(r, i);
  }), Zo(t).forEach((i, r) => {
    e.has(r) || s.set(r, 0);
  }), et(n.restEncoder, s.size), Gs(s.entries()).sort((i, r) => r[0] - i[0]).forEach(([i, r]) => {
    T4(
      n,
      /** @type {Array<GC|Item>} */
      t.clients.get(i),
      i,
      r
    );
  });
}, A4 = (n, t) => {
  const e = he(), s = ct(n.restDecoder);
  for (let i = 0; i < s; i++) {
    const r = ct(n.restDecoder), o = new Array(r), a = n.readClient();
    let c = ct(n.restDecoder);
    e.set(a, { i: 0, refs: o });
    for (let l = 0; l < r; l++) {
      const h = n.readInfo();
      switch (Rc & h) {
        case 0: {
          const d = n.readLen();
          o[l] = new Pe(st(a, c), d), c += d;
          break;
        }
        case 10: {
          const d = ct(n.restDecoder);
          o[l] = new Te(st(a, c), d), c += d;
          break;
        }
        default: {
          const d = (h & (Us | Ae)) === 0, u = new xt(
            st(a, c),
            null,
            // leftd
            (h & Ae) === Ae ? n.readLeftID() : null,
            // origin
            null,
            // right
            (h & Us) === Us ? n.readRightID() : null,
            // right origin
            d ? n.readParentInfo() ? t.get(n.readString()) : n.readLeftID() : null,
            // parent
            d && (h & ro) === ro ? n.readString() : null,
            // parentSub
            Ug(n, h)
            // item content
          );
          o[l] = u, c += u.length;
        }
      }
    }
  }
  return e;
}, I4 = (n, t, e) => {
  const s = [];
  let i = Gs(e.keys()).sort((f, p) => f - p);
  if (i.length === 0)
    return null;
  const r = () => {
    if (i.length === 0)
      return null;
    let f = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      e.get(i[i.length - 1])
    );
    for (; f.refs.length === f.i; )
      if (i.pop(), i.length > 0)
        f = /** @type {{i:number,refs:Array<GC|Item>}} */
        e.get(i[i.length - 1]);
      else
        return null;
    return f;
  };
  let o = r();
  if (o === null)
    return null;
  const a = new ig(), c = /* @__PURE__ */ new Map(), l = (f, p) => {
    const m = c.get(f);
    (m == null || m > p) && c.set(f, p);
  };
  let h = (
    /** @type {any} */
    o.refs[
      /** @type {any} */
      o.i++
    ]
  );
  const d = /* @__PURE__ */ new Map(), u = () => {
    for (const f of s) {
      const p = f.id.client, m = e.get(p);
      m ? (m.i--, a.clients.set(p, m.refs.slice(m.i)), e.delete(p), m.i = 0, m.refs = []) : a.clients.set(p, [f]), i = i.filter((_) => _ !== p);
    }
    s.length = 0;
  };
  for (; ; ) {
    if (h.constructor !== Te) {
      const p = De(d, h.id.client, () => Bt(t, h.id.client)) - h.id.clock;
      if (p < 0)
        s.push(h), l(h.id.client, h.id.clock - 1), u();
      else {
        const m = h.getMissing(n, t);
        if (m !== null) {
          s.push(h);
          const _ = e.get(
            /** @type {number} */
            m
          ) || { refs: [], i: 0 };
          if (_.refs.length === _.i)
            l(
              /** @type {number} */
              m,
              Bt(t, m)
            ), u();
          else {
            h = _.refs[_.i++];
            continue;
          }
        } else
          (p === 0 || p < h.length) && (h.integrate(n, p), d.set(h.id.client, h.id.clock + h.length));
      }
    }
    if (s.length > 0)
      h = /** @type {GC|Item} */
      s.pop();
    else if (o !== null && o.i < o.refs.length)
      h = /** @type {GC|Item} */
      o.refs[o.i++];
    else {
      if (o = r(), o === null)
        break;
      h = /** @type {GC|Item} */
      o.refs[o.i++];
    }
  }
  if (a.clients.size > 0) {
    const f = new cs();
    return mu(f, a, /* @__PURE__ */ new Map()), et(f.restEncoder, 0), { missing: c, update: f.toUint8Array() };
  }
  return null;
}, O4 = (n, t) => mu(n, t.doc.store, t.beforeState), _u = (n, t, e, s = new Be(n)) => kt(t, (i) => {
  i.local = !1;
  let r = !1;
  const o = i.doc, a = o.store, c = A4(s, o), l = I4(i, a, c), h = a.pendingStructs;
  if (h) {
    for (const [u, f] of h.missing)
      if (f < Bt(a, u)) {
        r = !0;
        break;
      }
    if (l) {
      for (const [u, f] of l.missing) {
        const p = h.missing.get(u);
        (p == null || p > f) && h.missing.set(u, f);
      }
      h.update = po([h.update, l.update]);
    }
  } else
    a.pendingStructs = l;
  const d = rp(s, i, a);
  if (a.pendingDs) {
    const u = new Be(be(a.pendingDs));
    ct(u.restDecoder);
    const f = rp(u, i, a);
    d && f ? a.pendingDs = po([d, f]) : a.pendingDs = d || f;
  } else
    a.pendingDs = d;
  if (r) {
    const u = (
      /** @type {{update: Uint8Array}} */
      a.pendingStructs.update
    );
    a.pendingStructs = null, Bc(i.doc, u);
  }
}, e, !1), D4 = (n, t, e) => _u(n, t, e, new Ze(n)), Bc = (n, t, e, s = Be) => {
  const i = be(t);
  _u(i, n, e, new s(i));
}, uo = (n, t, e) => Bc(n, t, e, Ze), P4 = (n, t, e = /* @__PURE__ */ new Map()) => {
  mu(n, t.store, e), Cs(n, gu(t.store));
}, J1 = (n, t = new Uint8Array([0]), e = new cs()) => {
  const s = yu(t);
  P4(e, n, s);
  const i = [e.toUint8Array()];
  if (n.store.pendingDs && i.push(n.store.pendingDs), n.store.pendingStructs && i.push(Tu(n.store.pendingStructs.update, t)), i.length > 1) {
    if (e.constructor === An)
      return Eu(i.map((r, o) => o === 0 ? r : _g(r)));
    if (e.constructor === cs)
      return po(i);
  }
  return i[0];
}, Yo = (n, t) => J1(n, t, new An()), Q1 = (n) => {
  const t = /* @__PURE__ */ new Map(), e = ct(n.restDecoder);
  for (let s = 0; s < e; s++) {
    const i = ct(n.restDecoder), r = ct(n.restDecoder);
    t.set(i, r);
  }
  return t;
}, yu = (n) => Q1(new ho(be(n))), vu = (n, t) => (et(n.restEncoder, t.size), Gs(t.entries()).sort((e, s) => s[0] - e[0]).forEach(([e, s]) => {
  et(n.restEncoder, e), et(n.restEncoder, s);
}), n), M4 = (n, t) => vu(n, Zo(t.store)), R4 = (n, t = new Fc()) => (n instanceof Map ? vu(t, n) : M4(t, n), t.toUint8Array()), bu = (n) => R4(n, new ir());
class $4 {
  constructor() {
    this.l = [];
  }
}
const op = () => new $4(), ap = (n, t) => n.l.push(t), cp = (n, t) => {
  const e = n.l, s = e.length;
  n.l = e.filter((i) => t !== i), s === n.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, tg = (n, t, e) => au(n.l, [t, e]);
class Yn {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(t, e) {
    this.client = t, this.clock = e;
  }
}
const Vn = (n, t) => n === t || n !== null && t !== null && n.client === t.client && n.clock === t.clock, st = (n, t) => new Yn(n, t), lp = (n, t) => {
  et(n, t.client), et(n, t.clock);
}, hp = (n) => st(ct(n), ct(n)), wu = (n) => {
  for (const [t, e] of n.doc.share.entries())
    if (e === n)
      return t;
  throw Re();
}, fo = (n, t) => {
  for (; t !== null; ) {
    if (t.parent === n)
      return !0;
    t = /** @type {AbstractType<any>} */
    t.parent._item;
  }
  return !1;
}, N4 = (n) => {
  const t = [];
  let e = n._start;
  for (; e; )
    t.push(e), e = e.right;
  console.log("Children: ", t), console.log("Children content: ", t.filter((s) => !s.deleted).map((s) => s.content));
};
class L4 {
  /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */
  constructor(t, e = t.getMap("users")) {
    const s = /* @__PURE__ */ new Map();
    this.yusers = e, this.doc = t, this.clients = /* @__PURE__ */ new Map(), this.dss = s;
    const i = (r, o) => {
      const a = r.get("ds"), c = r.get("ids"), l = (
        /** @param {number} clientid */
        (h) => this.clients.set(h, o)
      );
      a.observe(
        /** @param {YArrayEvent<any>} event */
        (h) => {
          h.changes.added.forEach((d) => {
            d.content.getContent().forEach((u) => {
              u instanceof Uint8Array && this.dss.set(o, nr([this.dss.get(o) || Uc(), Ws(new ho(be(u)))]));
            });
          });
        }
      ), this.dss.set(o, nr(a.map((h) => Ws(new ho(be(h)))))), c.observe(
        /** @param {YArrayEvent<any>} event */
        (h) => h.changes.added.forEach((d) => d.content.getContent().forEach(l))
      ), c.forEach(l);
    };
    e.observe((r) => {
      r.keysChanged.forEach(
        (o) => i(e.get(o), o)
      );
    }), e.forEach(i);
  }
  /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */
  setUserMapping(t, e, s, { filter: i = () => !0 } = {}) {
    const r = this.yusers;
    let o = r.get(s);
    o || (o = new ne(), o.set("ids", new de()), o.set("ds", new de()), r.set(s, o)), o.get("ids").push([e]), r.observe((a) => {
      setTimeout(() => {
        const c = r.get(s);
        if (c !== o) {
          o = c, this.clients.forEach((d, u) => {
            s === d && o.get("ids").push([u]);
          });
          const l = new ir(), h = this.dss.get(s);
          h && (Cs(l, h), o.get("ds").push([l.toUint8Array()]));
        }
      }, 0);
    }), t.on(
      "afterTransaction",
      /** @param {Transaction} transaction */
      (a) => {
        setTimeout(() => {
          const c = o.get("ds"), l = a.deleteSet;
          if (a.local && l.clients.size > 0 && i(a, l)) {
            const h = new ir();
            Cs(h, l), c.push([h.toUint8Array()]);
          }
        });
      }
    );
  }
  /**
   * @param {number} clientid
   * @return {any}
   */
  getUserByClientId(t) {
    return this.clients.get(t) || null;
  }
  /**
   * @param {ID} id
   * @return {string | null}
   */
  getUserByDeletedId(t) {
    for (const [e, s] of this.dss.entries())
      if (fi(s, t))
        return e;
    return null;
  }
}
class Vc {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(t, e, s, i = 0) {
    this.type = t, this.tname = e, this.item = s, this.assoc = i;
  }
}
const U4 = (n) => {
  const t = {};
  return n.type && (t.type = n.type), n.tname && (t.tname = n.tname), n.item && (t.item = n.item), n.assoc != null && (t.assoc = n.assoc), t;
}, F4 = (n) => new Vc(n.type == null ? null : st(n.type.client, n.type.clock), n.tname || null, n.item == null ? null : st(n.item.client, n.item.clock), n.assoc == null ? 0 : n.assoc);
class eg {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(t, e, s = 0) {
    this.type = t, this.index = e, this.assoc = s;
  }
}
const B4 = (n, t, e = 0) => new eg(n, t, e), la = (n, t, e) => {
  let s = null, i = null;
  return n._item === null ? i = wu(n) : s = st(n._item.id.client, n._item.id.clock), new Vc(s, i, t, e);
}, V4 = (n, t, e = 0) => {
  let s = n._start;
  if (e < 0) {
    if (t === 0)
      return la(n, null, e);
    t--;
  }
  for (; s !== null; ) {
    if (!s.deleted && s.countable) {
      if (s.length > t)
        return la(n, st(s.id.client, s.id.clock + t), e);
      t -= s.length;
    }
    if (s.right === null && e < 0)
      return la(n, s.lastId, e);
    s = s.right;
  }
  return la(n, null, e);
}, j4 = (n, t) => {
  const { type: e, tname: s, item: i, assoc: r } = t;
  if (i !== null)
    et(n, 0), lp(n, i);
  else if (s !== null)
    oo(n, 1), Wn(n, s);
  else if (e !== null)
    oo(n, 2), lp(n, e);
  else
    throw Re();
  return $c(n, r), n;
}, G4 = (n) => {
  const t = mr();
  return j4(t, n), We(t);
}, H4 = (n) => {
  let t = null, e = null, s = null;
  switch (ct(n)) {
    case 0:
      s = hp(n);
      break;
    case 1:
      e = Kn(n);
      break;
    case 2:
      t = hp(n);
  }
  const i = F1(n) ? Lc(n) : 0;
  return new Vc(t, e, s, i);
}, z4 = (n) => H4(be(n)), W4 = (n, t) => {
  const e = t.store, s = n.item, i = n.type, r = n.tname, o = n.assoc;
  let a = null, c = 0;
  if (s !== null) {
    if (Bt(e, s.client) <= s.clock)
      return null;
    const l = sd(e, s), h = l.item;
    if (!(h instanceof xt))
      return null;
    if (a = /** @type {AbstractType<any>} */
    h.parent, a._item === null || !a._item.deleted) {
      c = h.deleted || !h.countable ? 0 : l.diff + (o >= 0 ? 0 : 1);
      let d = h.left;
      for (; d !== null; )
        !d.deleted && d.countable && (c += d.length), d = d.left;
    }
  } else {
    if (r !== null)
      a = t.get(r);
    else if (i !== null) {
      if (Bt(e, i.client) <= i.clock)
        return null;
      const { item: l } = sd(e, i);
      if (l instanceof xt && l.content instanceof qe)
        a = l.content.type;
      else
        return null;
    } else
      throw Re();
    o >= 0 ? c = a._length : c = 0;
  }
  return B4(a, c, n.assoc);
}, K4 = (n, t) => n === t || n !== null && t !== null && n.tname === t.tname && Vn(n.item, t.item) && Vn(n.type, t.type) && n.assoc === t.assoc;
class Su {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(t, e) {
    this.ds = t, this.sv = e;
  }
}
const Y4 = (n, t) => {
  const e = n.ds.clients, s = t.ds.clients, i = n.sv, r = t.sv;
  if (i.size !== r.size || e.size !== s.size)
    return !1;
  for (const [o, a] of i.entries())
    if (r.get(o) !== a)
      return !1;
  for (const [o, a] of e.entries()) {
    const c = s.get(o) || [];
    if (a.length !== c.length)
      return !1;
    for (let l = 0; l < a.length; l++) {
      const h = a[l], d = c[l];
      if (h.clock !== d.clock || h.len !== d.len)
        return !1;
    }
  }
  return !0;
}, sg = (n, t = new Fc()) => (Cs(t, n.ds), vu(t, n.sv), t.toUint8Array()), Z4 = (n) => sg(n, new ir()), ng = (n, t = new X1(be(n))) => new Su(Ws(t), Q1(t)), q4 = (n) => ng(n, new ho(be(n))), Cu = (n, t) => new Su(n, t), X4 = Cu(Uc(), /* @__PURE__ */ new Map()), J4 = (n) => Cu(gu(n.store), Zo(n.store)), an = (n, t) => t === void 0 ? !n.deleted : t.sv.has(n.id.client) && (t.sv.get(n.id.client) || 0) > n.id.clock && !fi(t.ds, n.id), Qh = (n, t) => {
  const e = De(n.meta, Qh, Qn), s = n.doc.store;
  e.has(t) || (t.sv.forEach((i, r) => {
    i < Bt(s, r) && Ee(n, st(r, i));
  }), ti(n, t.ds, (i) => {
  }), e.add(t));
}, Q4 = (n, t, e = new Tn()) => {
  if (n.gc)
    throw new Error("Garbage-collection must be disabled in `originDoc`!");
  const { sv: s, ds: i } = t, r = new cs();
  return n.transact((o) => {
    let a = 0;
    s.forEach((c) => {
      c > 0 && a++;
    }), et(r.restEncoder, a);
    for (const [c, l] of s) {
      if (l === 0)
        continue;
      l < Bt(n.store, c) && Ee(o, st(c, l));
      const h = n.store.clients.get(c) || [], d = Ke(h, l - 1);
      et(r.restEncoder, d + 1), r.writeClient(c), et(r.restEncoder, 0);
      for (let u = 0; u <= d; u++)
        h[u].write(r, 0);
    }
    Cs(r, i);
  }), Bc(e, r.toUint8Array(), "snapshot"), e;
}, t5 = (n, t, e = Be) => {
  const s = new e(be(t)), i = new In(s, !1);
  for (let o = i.curr; o !== null; o = i.next())
    if ((n.sv.get(o.id.client) || 0) < o.id.clock + o.length)
      return !1;
  const r = nr([n.ds, Ws(s)]);
  return Y1(n.ds, r);
}, e5 = (n, t) => t5(n, t, Ze);
class ig {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const Zo = (n) => {
  const t = /* @__PURE__ */ new Map();
  return n.clients.forEach((e, s) => {
    const i = e[e.length - 1];
    t.set(s, i.id.clock + i.length);
  }), t;
}, Bt = (n, t) => {
  const e = n.clients.get(t);
  if (e === void 0)
    return 0;
  const s = e[e.length - 1];
  return s.id.clock + s.length;
}, rg = (n, t) => {
  let e = n.clients.get(t.id.client);
  if (e === void 0)
    e = [], n.clients.set(t.id.client, e);
  else {
    const s = e[e.length - 1];
    if (s.id.clock + s.length !== t.id.clock)
      throw Re();
  }
  e.push(t);
}, Ke = (n, t) => {
  let e = 0, s = n.length - 1, i = n[s], r = i.id.clock;
  if (r === t)
    return s;
  let o = Hs(t / (r + i.length - 1) * s);
  for (; e <= s; ) {
    if (i = n[o], r = i.id.clock, r <= t) {
      if (t < r + i.length)
        return o;
      e = o + 1;
    } else
      s = o - 1;
    o = Hs((e + s) / 2);
  }
  throw Re();
}, s5 = (n, t) => {
  const e = n.clients.get(t.client);
  return e[Ke(e, t.clock)];
}, qr = (
  /** @type {function(StructStore,ID):Item} */
  s5
), td = (n, t, e) => {
  const s = Ke(t, e), i = t[s];
  return i.id.clock < e && i instanceof xt ? (t.splice(s + 1, 0, qa(n, i, e - i.id.clock)), s + 1) : s;
}, Ee = (n, t) => {
  const e = (
    /** @type {Array<Item>} */
    n.doc.store.clients.get(t.client)
  );
  return e[td(n, e, t.clock)];
}, dp = (n, t, e) => {
  const s = t.clients.get(e.client), i = Ke(s, e.clock), r = s[i];
  return e.clock !== r.id.clock + r.length - 1 && r.constructor !== Pe && s.splice(i + 1, 0, qa(n, r, e.clock - r.id.clock + 1)), r;
}, n5 = (n, t, e) => {
  const s = (
    /** @type {Array<GC|Item>} */
    n.clients.get(t.id.client)
  );
  s[Ke(s, t.id.clock)] = e;
}, og = (n, t, e, s, i) => {
  if (s === 0)
    return;
  const r = e + s;
  let o = td(n, t, e), a;
  do
    a = t[o++], r < a.id.clock + a.length && td(n, t, r), i(a);
  while (o < t.length && t[o].id.clock < r);
};
class ag {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(t, e, s) {
    this.doc = t, this.deleteSet = new _r(), this.beforeState = Zo(t.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = e, this.meta = /* @__PURE__ */ new Map(), this.local = s, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const up = (n, t) => t.deleteSet.clients.size === 0 && !dv(t.afterState, (e, s) => t.beforeState.get(s) !== e) ? !1 : (pu(t.deleteSet), O4(n, t), Cs(n, t.deleteSet), !0), fp = (n, t, e) => {
  const s = t._item;
  (s === null || s.id.clock < (n.beforeState.get(s.id.client) || 0) && !s.deleted) && De(n.changed, t, Qn).add(e);
}, Pa = (n, t) => {
  let e = n[t], s = n[t - 1], i = t;
  for (; i > 0; e = s, s = n[--i - 1]) {
    if (s.deleted === e.deleted && s.constructor === e.constructor && s.mergeWith(e)) {
      e instanceof xt && e.parentSub !== null && /** @type {AbstractType<any>} */
      e.parent._map.get(e.parentSub) === e && e.parent._map.set(
        e.parentSub,
        /** @type {Item} */
        s
      );
      continue;
    }
    break;
  }
  const r = t - i;
  return r && n.splice(t + 1 - r, r), r;
}, cg = (n, t, e) => {
  for (const [s, i] of n.clients.entries()) {
    const r = (
      /** @type {Array<GC|Item>} */
      t.clients.get(s)
    );
    for (let o = i.length - 1; o >= 0; o--) {
      const a = i[o], c = a.clock + a.len;
      for (let l = Ke(r, a.clock), h = r[l]; l < r.length && h.id.clock < c; h = r[++l]) {
        const d = r[l];
        if (a.clock + a.len <= d.id.clock)
          break;
        d instanceof xt && d.deleted && !d.keep && e(d) && d.gc(t, !1);
      }
    }
  }
}, lg = (n, t) => {
  n.clients.forEach((e, s) => {
    const i = (
      /** @type {Array<GC|Item>} */
      t.clients.get(s)
    );
    for (let r = e.length - 1; r >= 0; r--) {
      const o = e[r], a = R1(i.length - 1, 1 + Ke(i, o.clock + o.len - 1));
      for (let c = a, l = i[c]; c > 0 && l.id.clock >= o.clock; l = i[c])
        c -= 1 + Pa(i, c);
    }
  });
}, i5 = (n, t, e) => {
  cg(n, t, e), lg(n, t);
}, hg = (n, t) => {
  if (t < n.length) {
    const e = n[t], s = e.doc, i = s.store, r = e.deleteSet, o = e._mergeStructs;
    try {
      pu(r), e.afterState = Zo(e.doc.store), s.emit("beforeObserverCalls", [e, s]);
      const a = [];
      e.changed.forEach(
        (c, l) => a.push(() => {
          (l._item === null || !l._item.deleted) && l._callObserver(e, c);
        })
      ), a.push(() => {
        e.changedParentTypes.forEach((c, l) => {
          l._dEH.l.length > 0 && (l._item === null || !l._item.deleted) && (c = c.filter(
            (h) => h.target._item === null || !h.target._item.deleted
          ), c.forEach((h) => {
            h.currentTarget = l, h._path = null;
          }), c.sort((h, d) => h.path.length - d.path.length), tg(l._dEH, c, e));
        });
      }), a.push(() => s.emit("afterTransaction", [e, s])), au(a, []), e._needFormattingCleanup && A5(e);
    } finally {
      s.gc && cg(r, i, s.gcFilter), lg(r, i), e.afterState.forEach((h, d) => {
        const u = e.beforeState.get(d) || 0;
        if (u !== h) {
          const f = (
            /** @type {Array<GC|Item>} */
            i.clients.get(d)
          ), p = ui(Ke(f, u), 1);
          for (let m = f.length - 1; m >= p; )
            m -= 1 + Pa(f, m);
        }
      });
      for (let h = o.length - 1; h >= 0; h--) {
        const { client: d, clock: u } = o[h].id, f = (
          /** @type {Array<GC|Item>} */
          i.clients.get(d)
        ), p = Ke(f, u);
        p + 1 < f.length && Pa(f, p + 1) > 1 || p > 0 && Pa(f, p);
      }
      if (!e.local && e.afterState.get(s.clientID) !== e.beforeState.get(s.clientID) && (Jh(uu, j1, "[yjs] ", G1, H1, "Changed the client-id because another client seems to be using it."), s.clientID = Z1()), s.emit("afterTransactionCleanup", [e, s]), s._observers.has("update")) {
        const h = new An();
        up(h, e) && s.emit("update", [h.toUint8Array(), e.origin, s, e]);
      }
      if (s._observers.has("updateV2")) {
        const h = new cs();
        up(h, e) && s.emit("updateV2", [h.toUint8Array(), e.origin, s, e]);
      }
      const { subdocsAdded: a, subdocsLoaded: c, subdocsRemoved: l } = e;
      (a.size > 0 || l.size > 0 || c.size > 0) && (a.forEach((h) => {
        h.clientID = s.clientID, h.collectionid == null && (h.collectionid = s.collectionid), s.subdocs.add(h);
      }), l.forEach((h) => s.subdocs.delete(h)), s.emit("subdocs", [{ loaded: c, added: a, removed: l }, s, e]), l.forEach((h) => h.destroy())), n.length <= t + 1 ? (s._transactionCleanups = [], s.emit("afterAllTransactions", [s, n])) : hg(n, t + 1);
    }
  }
}, kt = (n, t, e = null, s = !0) => {
  const i = n._transactionCleanups;
  let r = !1, o = null;
  n._transaction === null && (r = !0, n._transaction = new ag(n, e, s), i.push(n._transaction), i.length === 1 && n.emit("beforeAllTransactions", [n]), n.emit("beforeTransaction", [n._transaction, n]));
  try {
    o = t(n._transaction);
  } finally {
    if (r) {
      const a = n._transaction === i[0];
      n._transaction = null, a && hg(i, 0);
    }
  }
  return o;
};
class r5 {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(t, e) {
    this.insertions = e, this.deletions = t, this.meta = /* @__PURE__ */ new Map();
  }
}
const pp = (n, t, e) => {
  ti(n, e.deletions, (s) => {
    s instanceof xt && t.scope.some((i) => fo(i, s)) && $u(s, !1);
  });
}, gp = (n, t, e) => {
  let s = null;
  const i = n.doc, r = n.scope;
  if (kt(i, (o) => {
    for (; t.length > 0 && n.currStackItem === null; ) {
      const a = i.store, c = (
        /** @type {StackItem} */
        t.pop()
      ), l = /* @__PURE__ */ new Set(), h = [];
      let d = !1;
      ti(o, c.insertions, (u) => {
        if (u instanceof xt) {
          if (u.redone !== null) {
            let { item: f, diff: p } = sd(a, u.id);
            p > 0 && (f = Ee(o, st(f.id.client, f.id.clock + p))), u = f;
          }
          !u.deleted && r.some((f) => fo(
            f,
            /** @type {Item} */
            u
          )) && h.push(u);
        }
      }), ti(o, c.deletions, (u) => {
        u instanceof xt && r.some((f) => fo(f, u)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !fi(c.insertions, u.id) && l.add(u);
      }), l.forEach((u) => {
        d = Lg(o, u, l, c.insertions, n.ignoreRemoteMapChanges, n) !== null || d;
      });
      for (let u = h.length - 1; u >= 0; u--) {
        const f = h[u];
        n.deleteFilter(f) && (f.delete(o), d = !0);
      }
      n.currStackItem = d ? c : null;
    }
    o.changed.forEach((a, c) => {
      a.has(null) && c._searchMarker && (c._searchMarker.length = 0);
    }), s = o;
  }, n), n.currStackItem != null) {
    const o = s.changedParentTypes;
    n.emit("stack-item-popped", [{ stackItem: n.currStackItem, type: e, changedParentTypes: o, origin: n }, n]), n.currStackItem = null;
  }
  return n.currStackItem;
};
class ku extends hu {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(t, {
    captureTimeout: e = 500,
    captureTransaction: s = (c) => !0,
    deleteFilter: i = () => !0,
    trackedOrigins: r = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: a = (
      /** @type {Doc} */
      Wh(t) ? t[0].doc : t.doc
    )
  } = {}) {
    super(), this.scope = [], this.doc = a, this.addToScope(t), this.deleteFilter = i, r.add(this), this.trackedOrigins = r, this.captureTransaction = s, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = e, this.afterTransactionHandler = (c) => {
      if (!this.captureTransaction(c) || !this.scope.some((_) => c.changedParentTypes.has(_)) || !this.trackedOrigins.has(c.origin) && (!c.origin || !this.trackedOrigins.has(c.origin.constructor)))
        return;
      const l = this.undoing, h = this.redoing, d = l ? this.redoStack : this.undoStack;
      l ? this.stopCapturing() : h || this.clear(!1, !0);
      const u = new _r();
      c.afterState.forEach((_, v) => {
        const b = c.beforeState.get(v) || 0, g = _ - b;
        g > 0 && lo(u, v, b, g);
      });
      const f = Ka();
      let p = !1;
      if (this.lastChange > 0 && f - this.lastChange < this.captureTimeout && d.length > 0 && !l && !h) {
        const _ = d[d.length - 1];
        _.deletions = nr([_.deletions, c.deleteSet]), _.insertions = nr([_.insertions, u]);
      } else
        d.push(new r5(c.deleteSet, u)), p = !0;
      !l && !h && (this.lastChange = f), ti(
        c,
        c.deleteSet,
        /** @param {Item|GC} item */
        (_) => {
          _ instanceof xt && this.scope.some((v) => fo(v, _)) && $u(_, !0);
        }
      );
      const m = [{ stackItem: d[d.length - 1], origin: c.origin, type: l ? "redo" : "undo", changedParentTypes: c.changedParentTypes }, this];
      p ? this.emit("stack-item-added", m) : this.emit("stack-item-updated", m);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(t) {
    t = Wh(t) ? t : [t], t.forEach((e) => {
      this.scope.every((s) => s !== e) && (e.doc !== this.doc && C4("[yjs#509] Not same Y.Doc"), this.scope.push(e));
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(t) {
    this.trackedOrigins.add(t);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(t) {
    this.trackedOrigins.delete(t);
  }
  clear(t = !0, e = !0) {
    (t && this.canUndo() || e && this.canRedo()) && this.doc.transact((s) => {
      t && (this.undoStack.forEach((i) => pp(s, this, i)), this.undoStack = []), e && (this.redoStack.forEach((i) => pp(s, this, i)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: t, redoStackCleared: e }]);
    });
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = !0;
    let t;
    try {
      t = gp(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return t;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = !0;
    let t;
    try {
      t = gp(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return t;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* o5(n) {
  const t = ct(n.restDecoder);
  for (let e = 0; e < t; e++) {
    const s = ct(n.restDecoder), i = n.readClient();
    let r = ct(n.restDecoder);
    for (let o = 0; o < s; o++) {
      const a = n.readInfo();
      if (a === 10) {
        const c = ct(n.restDecoder);
        yield new Te(st(i, r), c), r += c;
      } else if (Rc & a) {
        const c = (a & (Us | Ae)) === 0, l = new xt(
          st(i, r),
          null,
          // left
          (a & Ae) === Ae ? n.readLeftID() : null,
          // origin
          null,
          // right
          (a & Us) === Us ? n.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          c ? n.readParentInfo() ? n.readString() : n.readLeftID() : null,
          // parent
          c && (a & ro) === ro ? n.readString() : null,
          // parentSub
          Ug(n, a)
          // item content
        );
        yield l, r += l.length;
      } else {
        const c = n.readLen();
        yield new Pe(st(i, r), c), r += c;
      }
    }
  }
}
class In {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(t, e) {
    this.gen = o5(t), this.curr = null, this.done = !1, this.filterSkips = e, this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === Te);
    return this.curr;
  }
}
const a5 = (n) => dg(n, Ze), dg = (n, t = Be) => {
  const e = [], s = new t(be(n)), i = new In(s, !1);
  for (let o = i.curr; o !== null; o = i.next())
    e.push(o);
  Jh("Structs: ", e);
  const r = Ws(s);
  Jh("DeleteSet: ", r);
}, c5 = (n) => ug(n, Ze), ug = (n, t = Be) => {
  const e = [], s = new t(be(n)), i = new In(s, !1);
  for (let r = i.curr; r !== null; r = i.next())
    e.push(r);
  return {
    structs: e,
    ds: Ws(s)
  };
};
class xu {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(t) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = t, this.clientStructs = [];
  }
}
const Eu = (n) => po(n, Ze, An), fg = (n, t = Fc, e = Be) => {
  const s = new t(), i = new In(new e(be(n)), !1);
  let r = i.curr;
  if (r !== null) {
    let o = 0, a = r.id.client, c = r.id.clock !== 0, l = c ? 0 : r.id.clock + r.length;
    for (; r !== null; r = i.next())
      a !== r.id.client && (l !== 0 && (o++, et(s.restEncoder, a), et(s.restEncoder, l)), a = r.id.client, l = 0, c = r.id.clock !== 0), r.constructor === Te && (c = !0), c || (l = r.id.clock + r.length);
    l !== 0 && (o++, et(s.restEncoder, a), et(s.restEncoder, l));
    const h = mr();
    return et(h, o), $v(h, s.restEncoder), s.restEncoder = h, s.toUint8Array();
  } else
    return et(s.restEncoder, 0), s.toUint8Array();
}, l5 = (n) => fg(n, ir, Ze), pg = (n, t = Be) => {
  const e = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = new In(new t(be(n)), !1);
  let r = i.curr;
  if (r !== null) {
    let o = r.id.client, a = r.id.clock;
    for (e.set(o, a); r !== null; r = i.next())
      o !== r.id.client && (s.set(o, a), e.set(r.id.client, r.id.clock), o = r.id.client), a = r.id.clock + r.length;
    s.set(o, a);
  }
  return { from: e, to: s };
}, h5 = (n) => pg(n, Ze), d5 = (n, t) => {
  if (n.constructor === Pe) {
    const { client: e, clock: s } = n.id;
    return new Pe(st(e, s + t), n.length - t);
  } else if (n.constructor === Te) {
    const { client: e, clock: s } = n.id;
    return new Te(st(e, s + t), n.length - t);
  } else {
    const e = (
      /** @type {Item} */
      n
    ), { client: s, clock: i } = e.id;
    return new xt(
      st(s, i + t),
      null,
      st(s, i + t - 1),
      null,
      e.rightOrigin,
      e.parent,
      e.parentSub,
      e.content.splice(t)
    );
  }
}, po = (n, t = Be, e = cs) => {
  if (n.length === 1)
    return n[0];
  const s = n.map((h) => new t(be(h)));
  let i = s.map((h) => new In(h, !0)), r = null;
  const o = new e(), a = new xu(o);
  for (; i = i.filter((u) => u.curr !== null), i.sort(
    /** @type {function(any,any):number} */
    (u, f) => {
      if (u.curr.id.client === f.curr.id.client) {
        const p = u.curr.id.clock - f.curr.id.clock;
        return p === 0 ? u.curr.constructor === f.curr.constructor ? 0 : u.curr.constructor === Te ? 1 : -1 : p;
      } else
        return f.curr.id.client - u.curr.id.client;
    }
  ), i.length !== 0; ) {
    const h = i[0], d = (
      /** @type {Item | GC} */
      h.curr.id.client
    );
    if (r !== null) {
      let u = (
        /** @type {Item | GC | null} */
        h.curr
      ), f = !1;
      for (; u !== null && u.id.clock + u.length <= r.struct.id.clock + r.struct.length && u.id.client >= r.struct.id.client; )
        u = h.next(), f = !0;
      if (u === null || // current decoder is empty
      u.id.client !== d || // check whether there is another decoder that has has updates from `firstClient`
      f && u.id.clock > r.struct.id.clock + r.struct.length)
        continue;
      if (d !== r.struct.id.client)
        cn(a, r.struct, r.offset), r = { struct: u, offset: 0 }, h.next();
      else if (r.struct.id.clock + r.struct.length < u.id.clock)
        if (r.struct.constructor === Te)
          r.struct.length = u.id.clock + u.length - r.struct.id.clock;
        else {
          cn(a, r.struct, r.offset);
          const p = u.id.clock - r.struct.id.clock - r.struct.length;
          r = { struct: new Te(st(d, r.struct.id.clock + r.struct.length), p), offset: 0 };
        }
      else {
        const p = r.struct.id.clock + r.struct.length - u.id.clock;
        p > 0 && (r.struct.constructor === Te ? r.struct.length -= p : u = d5(u, p)), r.struct.mergeWith(
          /** @type {any} */
          u
        ) || (cn(a, r.struct, r.offset), r = { struct: u, offset: 0 }, h.next());
      }
    } else
      r = { struct: (
        /** @type {Item | GC} */
        h.curr
      ), offset: 0 }, h.next();
    for (let u = h.curr; u !== null && u.id.client === d && u.id.clock === r.struct.id.clock + r.struct.length && u.constructor !== Te; u = h.next())
      cn(a, r.struct, r.offset), r = { struct: u, offset: 0 };
  }
  r !== null && (cn(a, r.struct, r.offset), r = null), Au(a);
  const c = s.map((h) => Ws(h)), l = nr(c);
  return Cs(o, l), o.toUint8Array();
}, Tu = (n, t, e = Be, s = cs) => {
  const i = yu(t), r = new s(), o = new xu(r), a = new e(be(n)), c = new In(a, !1);
  for (; c.curr; ) {
    const h = c.curr, d = h.id.client, u = i.get(d) || 0;
    if (c.curr.constructor === Te) {
      c.next();
      continue;
    }
    if (h.id.clock + h.length > u)
      for (cn(o, h, ui(u - h.id.clock, 0)), c.next(); c.curr && c.curr.id.client === d; )
        cn(o, c.curr, 0), c.next();
    else
      for (; c.curr && c.curr.id.client === d && c.curr.id.clock + c.curr.length <= u; )
        c.next();
  }
  Au(o);
  const l = Ws(a);
  return Cs(r, l), r.toUint8Array();
}, u5 = (n, t) => Tu(n, t, Ze, An), gg = (n) => {
  n.written > 0 && (n.clientStructs.push({ written: n.written, restEncoder: We(n.encoder.restEncoder) }), n.encoder.restEncoder = mr(), n.written = 0);
}, cn = (n, t, e) => {
  n.written > 0 && n.currClient !== t.id.client && gg(n), n.written === 0 && (n.currClient = t.id.client, n.encoder.writeClient(t.id.client), et(n.encoder.restEncoder, t.id.clock + e)), t.write(n.encoder, e), n.written++;
}, Au = (n) => {
  gg(n);
  const t = n.encoder.restEncoder;
  et(t, n.clientStructs.length);
  for (let e = 0; e < n.clientStructs.length; e++) {
    const s = n.clientStructs[e];
    et(t, s.written), Ko(t, s.restEncoder);
  }
}, jc = (n, t, e, s) => {
  const i = new e(be(n)), r = new In(i, !1), o = new s(), a = new xu(o);
  for (let l = r.curr; l !== null; l = r.next())
    cn(a, t(l), 0);
  Au(a);
  const c = Ws(i);
  return Cs(o, c), o.toUint8Array();
}, mg = ({ formatting: n = !0, subdocs: t = !0, yxml: e = !0 } = {}) => {
  let s = 0;
  const i = he(), r = he(), o = he(), a = he();
  return a.set(null, null), (c) => {
    switch (c.constructor) {
      case Pe:
      case Te:
        return c;
      case xt: {
        const l = (
          /** @type {Item} */
          c
        ), h = l.content;
        switch (h.constructor) {
          case ei:
            break;
          case qe: {
            if (e) {
              const d = (
                /** @type {ContentType} */
                h.type
              );
              d instanceof mn && (d.nodeName = De(r, d.nodeName, () => "node-" + s)), d instanceof rr && (d.hookName = De(r, d.hookName, () => "hook-" + s));
            }
            break;
          }
          case Ks: {
            const d = (
              /** @type {ContentAny} */
              h
            );
            d.arr = d.arr.map(() => s);
            break;
          }
          case pi: {
            const d = (
              /** @type {ContentBinary} */
              h
            );
            d.content = new Uint8Array([s]);
            break;
          }
          case gi: {
            const d = (
              /** @type {ContentDoc} */
              h
            );
            t && (d.opts = {}, d.doc.guid = s + "");
            break;
          }
          case qs: {
            const d = (
              /** @type {ContentEmbed} */
              h
            );
            d.embed = {};
            break;
          }
          case Kt: {
            const d = (
              /** @type {ContentFormat} */
              h
            );
            n && (d.key = De(o, d.key, () => s + ""), d.value = De(a, d.value, () => ({ i: s })));
            break;
          }
          case or: {
            const d = (
              /** @type {ContentJSON} */
              h
            );
            d.arr = d.arr.map(() => s);
            break;
          }
          case Ye: {
            const d = (
              /** @type {ContentString} */
              h
            );
            d.str = lv(s % 10 + "", d.str.length);
            break;
          }
          default:
            Re();
        }
        return l.parentSub && (l.parentSub = De(i, l.parentSub, () => s + "")), s++, c;
      }
      default:
        Re();
    }
  };
}, f5 = (n, t) => jc(n, mg(t), Ze, An), p5 = (n, t) => jc(n, mg(t), Be, cs), g5 = (n) => jc(n, M1, Ze, cs), _g = (n) => jc(n, M1, Be, An), mp = "You must not compute changes after the event-handler fired.";
class qo {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(t, e) {
    this.target = t, this.currentTarget = t, this.transaction = e, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = m5(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(t) {
    return fi(this.transaction.deleteSet, t.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw zs(mp);
      const t = /* @__PURE__ */ new Map(), e = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(e).forEach((i) => {
        if (i !== null) {
          const r = (
            /** @type {Item} */
            e._map.get(i)
          );
          let o, a;
          if (this.adds(r)) {
            let c = r.left;
            for (; c !== null && this.adds(c); )
              c = c.left;
            if (this.deletes(r))
              if (c !== null && this.deletes(c))
                o = "delete", a = eh(c.content.getContent());
              else
                return;
            else
              c !== null && this.deletes(c) ? (o = "update", a = eh(c.content.getContent())) : (o = "add", a = void 0);
          } else if (this.deletes(r))
            o = "delete", a = eh(
              /** @type {Item} */
              r.content.getContent()
            );
          else
            return;
          t.set(i, { action: o, oldValue: a });
        }
      }), this._keys = t;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(t) {
    return t.id.clock >= (this.transaction.beforeState.get(t.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let t = this._changes;
    if (t === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw zs(mp);
      const e = this.target, s = Qn(), i = Qn(), r = [];
      if (t = {
        added: s,
        deleted: i,
        delta: r,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(e).has(null)) {
        let a = null;
        const c = () => {
          a && r.push(a);
        };
        for (let l = e._start; l !== null; l = l.right)
          l.deleted ? this.deletes(l) && !this.adds(l) && ((a === null || a.delete === void 0) && (c(), a = { delete: 0 }), a.delete += l.length, i.add(l)) : this.adds(l) ? ((a === null || a.insert === void 0) && (c(), a = { insert: [] }), a.insert = a.insert.concat(l.content.getContent()), s.add(l)) : ((a === null || a.retain === void 0) && (c(), a = { retain: 0 }), a.retain += l.length);
        a !== null && a.retain === void 0 && c();
      }
      this._changes = t;
    }
    return (
      /** @type {any} */
      t
    );
  }
}
const m5 = (n, t) => {
  const e = [];
  for (; t._item !== null && t !== n; ) {
    if (t._item.parentSub !== null)
      e.unshift(t._item.parentSub);
    else {
      let s = 0, i = (
        /** @type {AbstractType<any>} */
        t._item.parent._start
      );
      for (; i !== t._item && i !== null; )
        i.deleted || s++, i = i.right;
      e.unshift(s);
    }
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  }
  return e;
}, yg = 80;
let Iu = 0;
class _5 {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(t, e) {
    t.marker = !0, this.p = t, this.index = e, this.timestamp = Iu++;
  }
}
const y5 = (n) => {
  n.timestamp = Iu++;
}, vg = (n, t, e) => {
  n.p.marker = !1, n.p = t, t.marker = !0, n.index = e, n.timestamp = Iu++;
}, v5 = (n, t, e) => {
  if (n.length >= yg) {
    const s = n.reduce((i, r) => i.timestamp < r.timestamp ? i : r);
    return vg(s, t, e), s;
  } else {
    const s = new _5(t, e);
    return n.push(s), s;
  }
}, Gc = (n, t) => {
  if (n._start === null || t === 0 || n._searchMarker === null)
    return null;
  const e = n._searchMarker.length === 0 ? null : n._searchMarker.reduce((r, o) => Ia(t - r.index) < Ia(t - o.index) ? r : o);
  let s = n._start, i = 0;
  for (e !== null && (s = e.p, i = e.index, y5(e)); s.right !== null && i < t; ) {
    if (!s.deleted && s.countable) {
      if (t < i + s.length)
        break;
      i += s.length;
    }
    s = s.right;
  }
  for (; s.left !== null && i > t; )
    s = s.left, !s.deleted && s.countable && (i -= s.length);
  for (; s.left !== null && s.left.id.client === s.id.client && s.left.id.clock + s.left.length === s.id.clock; )
    s = s.left, !s.deleted && s.countable && (i -= s.length);
  return e !== null && Ia(e.index - i) < /** @type {YText|YArray<any>} */
  s.parent.length / yg ? (vg(e, s, i), e) : v5(n._searchMarker, s, i);
}, go = (n, t, e) => {
  for (let s = n.length - 1; s >= 0; s--) {
    const i = n[s];
    if (e > 0) {
      let r = i.p;
      for (r.marker = !1; r && (r.deleted || !r.countable); )
        r = r.left, r && !r.deleted && r.countable && (i.index -= r.length);
      if (r === null || r.marker === !0) {
        n.splice(s, 1);
        continue;
      }
      i.p = r, r.marker = !0;
    }
    (t < i.index || e > 0 && t === i.index) && (i.index = ui(t, i.index + e));
  }
}, b5 = (n) => {
  let t = n._start;
  const e = [];
  for (; t; )
    e.push(t), t = t.right;
  return e;
}, Hc = (n, t, e) => {
  const s = n, i = t.changedParentTypes;
  for (; De(i, n, () => []).push(e), n._item !== null; )
    n = /** @type {AbstractType<any>} */
    n._item.parent;
  tg(s._eH, e, t);
};
class se {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = op(), this._dEH = op(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(t, e) {
    this.doc = t, this._item = e;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw bs();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw bs();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(t) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let t = this._start;
    for (; t !== null && t.deleted; )
      t = t.right;
    return t;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, e) {
    !t.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(t) {
    ap(this._eH, t);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(t) {
    ap(this._dEH, t);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(t) {
    cp(this._eH, t);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(t) {
    cp(this._dEH, t);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const bg = (n, t, e) => {
  t < 0 && (t = n._length + t), e < 0 && (e = n._length + e);
  let s = e - t;
  const i = [];
  let r = n._start;
  for (; r !== null && s > 0; ) {
    if (r.countable && !r.deleted) {
      const o = r.content.getContent();
      if (o.length <= t)
        t -= o.length;
      else {
        for (let a = t; a < o.length && s > 0; a++)
          i.push(o[a]), s--;
        t = 0;
      }
    }
    r = r.right;
  }
  return i;
}, wg = (n) => {
  const t = [];
  let e = n._start;
  for (; e !== null; ) {
    if (e.countable && !e.deleted) {
      const s = e.content.getContent();
      for (let i = 0; i < s.length; i++)
        t.push(s[i]);
    }
    e = e.right;
  }
  return t;
}, w5 = (n, t) => {
  const e = [];
  let s = n._start;
  for (; s !== null; ) {
    if (s.countable && an(s, t)) {
      const i = s.content.getContent();
      for (let r = 0; r < i.length; r++)
        e.push(i[r]);
    }
    s = s.right;
  }
  return e;
}, mo = (n, t) => {
  let e = 0, s = n._start;
  for (; s !== null; ) {
    if (s.countable && !s.deleted) {
      const i = s.content.getContent();
      for (let r = 0; r < i.length; r++)
        t(i[r], e++, n);
    }
    s = s.right;
  }
}, Sg = (n, t) => {
  const e = [];
  return mo(n, (s, i) => {
    e.push(t(s, i, n));
  }), e;
}, S5 = (n) => {
  let t = n._start, e = null, s = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (e === null) {
        for (; t !== null && t.deleted; )
          t = t.right;
        if (t === null)
          return {
            done: !0,
            value: void 0
          };
        e = t.content.getContent(), s = 0, t = t.right;
      }
      const i = e[s++];
      return e.length <= s && (e = null), {
        done: !1,
        value: i
      };
    }
  };
}, Cg = (n, t) => {
  const e = Gc(n, t);
  let s = n._start;
  for (e !== null && (s = e.p, t -= e.index); s !== null; s = s.right)
    if (!s.deleted && s.countable) {
      if (t < s.length)
        return s.content.getContent()[t];
      t -= s.length;
    }
}, Ya = (n, t, e, s) => {
  let i = e;
  const r = n.doc, o = r.clientID, a = r.store, c = e === null ? t._start : e.right;
  let l = [];
  const h = () => {
    l.length > 0 && (i = new xt(st(o, Bt(a, o)), i, i && i.lastId, c, c && c.id, t, null, new Ks(l)), i.integrate(n, 0), l = []);
  };
  s.forEach((d) => {
    if (d === null)
      l.push(d);
    else
      switch (d.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          l.push(d);
          break;
        default:
          switch (h(), d.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new xt(st(o, Bt(a, o)), i, i && i.lastId, c, c && c.id, t, null, new pi(new Uint8Array(
                /** @type {Uint8Array} */
                d
              ))), i.integrate(n, 0);
              break;
            case Tn:
              i = new xt(st(o, Bt(a, o)), i, i && i.lastId, c, c && c.id, t, null, new gi(
                /** @type {Doc} */
                d
              )), i.integrate(n, 0);
              break;
            default:
              if (d instanceof se)
                i = new xt(st(o, Bt(a, o)), i, i && i.lastId, c, c && c.id, t, null, new qe(d)), i.integrate(n, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), h();
}, kg = () => zs("Length exceeded!"), xg = (n, t, e, s) => {
  if (e > t._length)
    throw kg();
  if (e === 0)
    return t._searchMarker && go(t._searchMarker, e, s.length), Ya(n, t, null, s);
  const i = e, r = Gc(t, e);
  let o = t._start;
  for (r !== null && (o = r.p, e -= r.index, e === 0 && (o = o.prev, e += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (e <= o.length) {
        e < o.length && Ee(n, st(o.id.client, o.id.clock + e));
        break;
      }
      e -= o.length;
    }
  return t._searchMarker && go(t._searchMarker, i, s.length), Ya(n, t, o, s);
}, C5 = (n, t, e) => {
  let i = (t._searchMarker || []).reduce((r, o) => o.index > r.index ? o : r, { index: 0, p: t._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return Ya(n, t, i, e);
}, Eg = (n, t, e, s) => {
  if (s === 0)
    return;
  const i = e, r = s, o = Gc(t, e);
  let a = t._start;
  for (o !== null && (a = o.p, e -= o.index); a !== null && e > 0; a = a.right)
    !a.deleted && a.countable && (e < a.length && Ee(n, st(a.id.client, a.id.clock + e)), e -= a.length);
  for (; s > 0 && a !== null; )
    a.deleted || (s < a.length && Ee(n, st(a.id.client, a.id.clock + s)), a.delete(n), s -= a.length), a = a.right;
  if (s > 0)
    throw kg();
  t._searchMarker && go(
    t._searchMarker,
    i,
    -r + s
    /* in case we remove the above exception */
  );
}, Za = (n, t, e) => {
  const s = t._map.get(e);
  s !== void 0 && s.delete(n);
}, Ou = (n, t, e, s) => {
  const i = t._map.get(e) || null, r = n.doc, o = r.clientID;
  let a;
  if (s == null)
    a = new Ks([s]);
  else
    switch (s.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new Ks([s]);
        break;
      case Uint8Array:
        a = new pi(
          /** @type {Uint8Array} */
          s
        );
        break;
      case Tn:
        a = new gi(
          /** @type {Doc} */
          s
        );
        break;
      default:
        if (s instanceof se)
          a = new qe(s);
        else
          throw new Error("Unexpected content type");
    }
  new xt(st(o, Bt(r.store, o)), i, i && i.lastId, null, null, t, e, a).integrate(n, 0);
}, Du = (n, t) => {
  const e = n._map.get(t);
  return e !== void 0 && !e.deleted ? e.content.getContent()[e.length - 1] : void 0;
}, Tg = (n) => {
  const t = {};
  return n._map.forEach((e, s) => {
    e.deleted || (t[s] = e.content.getContent()[e.length - 1]);
  }), t;
}, Ag = (n, t) => {
  const e = n._map.get(t);
  return e !== void 0 && !e.deleted;
}, k5 = (n, t, e) => {
  let s = n._map.get(t) || null;
  for (; s !== null && (!e.sv.has(s.id.client) || s.id.clock >= (e.sv.get(s.id.client) || 0)); )
    s = s.left;
  return s !== null && an(s, e) ? s.content.getContent()[s.length - 1] : void 0;
}, Ig = (n, t) => {
  const e = {};
  return n._map.forEach((s, i) => {
    let r = s;
    for (; r !== null && (!t.sv.has(r.id.client) || r.id.clock >= (t.sv.get(r.id.client) || 0)); )
      r = r.left;
    r !== null && an(r, t) && (e[i] = r.content.getContent()[r.length - 1]);
  }), e;
}, ha = (n) => k4(
  n.entries(),
  /** @param {any} entry */
  (t) => !t[1].deleted
);
class Pu extends qo {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(t, e) {
    super(t, e), this._transaction = e;
  }
}
class de extends se {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(t) {
    const e = new de();
    return e.push(t), e;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, e) {
    super._integrate(t, e), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new de();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const t = new de();
    return t.insert(0, this.toArray().map(
      (e) => e instanceof se ? (
        /** @type {typeof el} */
        e.clone()
      ) : e
    )), t;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, e) {
    super._callObserver(t, e), Hc(this, t, new Pu(this, t));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(t, e) {
    this.doc !== null ? kt(this.doc, (s) => {
      xg(
        s,
        this,
        t,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.splice(t, 0, ...e);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(t) {
    this.doc !== null ? kt(this.doc, (e) => {
      C5(
        e,
        this,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.push(...t);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(t) {
    this.insert(0, t);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(t, e = 1) {
    this.doc !== null ? kt(this.doc, (s) => {
      Eg(s, this, t, e);
    }) : this._prelimContent.splice(t, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(t) {
    return Cg(this, t);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return wg(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(t = 0, e = this.length) {
    return bg(this, t, e);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((t) => t instanceof se ? t.toJSON() : t);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(t) {
    return Sg(
      this,
      /** @type {any} */
      t
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(t) {
    mo(this, t);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return S5(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(H5);
  }
}
const x5 = (n) => new de();
class Mu extends qo {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(t, e, s) {
    super(t, e), this.keysChanged = s;
  }
}
class ne extends se {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(t) {
    super(), this._prelimContent = null, t === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(t);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, e) {
    super._integrate(t, e), this._prelimContent.forEach((s, i) => {
      this.set(i, s);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new ne();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const t = new ne();
    return this.forEach((e, s) => {
      t.set(s, e instanceof se ? (
        /** @type {typeof value} */
        e.clone()
      ) : e);
    }), t;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, e) {
    Hc(this, t, new Mu(this, t, e));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const t = {};
    return this._map.forEach((e, s) => {
      if (!e.deleted) {
        const i = e.content.getContent()[e.length - 1];
        t[s] = i instanceof se ? i.toJSON() : i;
      }
    }), t;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...ha(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return oh(
      ha(this._map),
      /** @param {any} v */
      (t) => t[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return oh(
      ha(this._map),
      /** @param {any} v */
      (t) => t[1].content.getContent()[t[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return oh(
      ha(this._map),
      /** @param {any} v */
      (t) => (
        /** @type {any} */
        [t[0], t[1].content.getContent()[t[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(t) {
    this._map.forEach((e, s) => {
      e.deleted || t(e.content.getContent()[e.length - 1], s, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(t) {
    this.doc !== null ? kt(this.doc, (e) => {
      Za(e, this, t);
    }) : this._prelimContent.delete(t);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(t, e) {
    return this.doc !== null ? kt(this.doc, (s) => {
      Ou(
        s,
        this,
        t,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.set(t, e), e;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(t) {
    return (
      /** @type {any} */
      Du(this, t)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(t) {
    return Ag(this, t);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? kt(this.doc, (t) => {
      this.forEach(function(e, s, i) {
        Za(t, i, s);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(z5);
  }
}
const E5 = (n) => new ne(), un = (n, t) => n === t || typeof n == "object" && typeof t == "object" && n && t && bv(n, t);
class ed {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(t, e, s, i) {
    this.left = t, this.right = e, this.index = s, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Re(), this.right.content.constructor) {
      case Kt:
        this.right.deleted || yr(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const _p = (n, t, e) => {
  for (; t.right !== null && e > 0; ) {
    switch (t.right.content.constructor) {
      case Kt:
        t.right.deleted || yr(
          t.currentAttributes,
          /** @type {ContentFormat} */
          t.right.content
        );
        break;
      default:
        t.right.deleted || (e < t.right.length && Ee(n, st(t.right.id.client, t.right.id.clock + e)), t.index += t.right.length, e -= t.right.length);
        break;
    }
    t.left = t.right, t.right = t.right.right;
  }
  return t;
}, da = (n, t, e, s) => {
  const i = /* @__PURE__ */ new Map(), r = s ? Gc(t, e) : null;
  if (r) {
    const o = new ed(r.p.left, r.p, r.index, i);
    return _p(n, o, e - r.index);
  } else {
    const o = new ed(null, t._start, 0, i);
    return _p(n, o, e);
  }
}, Og = (n, t, e, s) => {
  for (; e.right !== null && (e.right.deleted === !0 || e.right.content.constructor === Kt && un(
    s.get(
      /** @type {ContentFormat} */
      e.right.content.key
    ),
    /** @type {ContentFormat} */
    e.right.content.value
  )); )
    e.right.deleted || s.delete(
      /** @type {ContentFormat} */
      e.right.content.key
    ), e.forward();
  const i = n.doc, r = i.clientID;
  s.forEach((o, a) => {
    const c = e.left, l = e.right, h = new xt(st(r, Bt(i.store, r)), c, c && c.lastId, l, l && l.id, t, null, new Kt(a, o));
    h.integrate(n, 0), e.right = h, e.forward();
  });
}, yr = (n, t) => {
  const { key: e, value: s } = t;
  s === null ? n.delete(e) : n.set(e, s);
}, Dg = (n, t) => {
  for (; n.right !== null; ) {
    if (!(n.right.deleted || n.right.content.constructor === Kt && un(
      t[
        /** @type {ContentFormat} */
        n.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      n.right.content.value
    )))
      break;
    n.forward();
  }
}, Pg = (n, t, e, s) => {
  const i = n.doc, r = i.clientID, o = /* @__PURE__ */ new Map();
  for (const a in s) {
    const c = s[a], l = e.currentAttributes.get(a) ?? null;
    if (!un(l, c)) {
      o.set(a, l);
      const { left: h, right: d } = e;
      e.right = new xt(st(r, Bt(i.store, r)), h, h && h.lastId, d, d && d.id, t, null, new Kt(a, c)), e.right.integrate(n, 0), e.forward();
    }
  }
  return o;
}, ah = (n, t, e, s, i) => {
  e.currentAttributes.forEach((u, f) => {
    i[f] === void 0 && (i[f] = null);
  });
  const r = n.doc, o = r.clientID;
  Dg(e, i);
  const a = Pg(n, t, e, i), c = s.constructor === String ? new Ye(
    /** @type {string} */
    s
  ) : s instanceof se ? new qe(s) : new qs(s);
  let { left: l, right: h, index: d } = e;
  t._searchMarker && go(t._searchMarker, e.index, c.getLength()), h = new xt(st(o, Bt(r.store, o)), l, l && l.lastId, h, h && h.id, t, null, c), h.integrate(n, 0), e.right = h, e.index = d, e.forward(), Og(n, t, e, a);
}, yp = (n, t, e, s, i) => {
  const r = n.doc, o = r.clientID;
  Dg(e, i);
  const a = Pg(n, t, e, i);
  t:
    for (; e.right !== null && (s > 0 || a.size > 0 && (e.right.deleted || e.right.content.constructor === Kt)); ) {
      if (!e.right.deleted)
        switch (e.right.content.constructor) {
          case Kt: {
            const { key: c, value: l } = (
              /** @type {ContentFormat} */
              e.right.content
            ), h = i[c];
            if (h !== void 0) {
              if (un(h, l))
                a.delete(c);
              else {
                if (s === 0)
                  break t;
                a.set(c, l);
              }
              e.right.delete(n);
            } else
              e.currentAttributes.set(c, l);
            break;
          }
          default:
            s < e.right.length && Ee(n, st(e.right.id.client, e.right.id.clock + s)), s -= e.right.length;
            break;
        }
      e.forward();
    }
  if (s > 0) {
    let c = "";
    for (; s > 0; s--)
      c += `
`;
    e.right = new xt(st(o, Bt(r.store, o)), e.left, e.left && e.left.lastId, e.right, e.right && e.right.id, t, null, new Ye(c)), e.right.integrate(n, 0), e.forward();
  }
  Og(n, t, e, a);
}, Mg = (n, t, e, s, i) => {
  let r = t;
  const o = he();
  for (; r && (!r.countable || r.deleted); ) {
    if (!r.deleted && r.content.constructor === Kt) {
      const l = (
        /** @type {ContentFormat} */
        r.content
      );
      o.set(l.key, l);
    }
    r = r.right;
  }
  let a = 0, c = !1;
  for (; t !== r; ) {
    if (e === t && (c = !0), !t.deleted) {
      const l = t.content;
      switch (l.constructor) {
        case Kt: {
          const { key: h, value: d } = (
            /** @type {ContentFormat} */
            l
          ), u = s.get(h) ?? null;
          (o.get(h) !== l || u === d) && (t.delete(n), a++, !c && (i.get(h) ?? null) === d && u !== d && (u === null ? i.delete(h) : i.set(h, u))), !c && !t.deleted && yr(
            i,
            /** @type {ContentFormat} */
            l
          );
          break;
        }
      }
    }
    t = /** @type {Item} */
    t.right;
  }
  return a;
}, T5 = (n, t) => {
  for (; t && t.right && (t.right.deleted || !t.right.countable); )
    t = t.right;
  const e = /* @__PURE__ */ new Set();
  for (; t && (t.deleted || !t.countable); ) {
    if (!t.deleted && t.content.constructor === Kt) {
      const s = (
        /** @type {ContentFormat} */
        t.content.key
      );
      e.has(s) ? t.delete(n) : e.add(s);
    }
    t = t.left;
  }
}, Rg = (n) => {
  let t = 0;
  return kt(
    /** @type {Doc} */
    n.doc,
    (e) => {
      let s = (
        /** @type {Item} */
        n._start
      ), i = n._start, r = he();
      const o = Kh(r);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case Kt:
              yr(
                o,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              t += Mg(e, s, i, r, o), r = Kh(o), s = i;
              break;
          }
        i = i.right;
      }
    }
  ), t;
}, A5 = (n) => {
  const t = /* @__PURE__ */ new Set(), e = n.doc;
  for (const [s, i] of n.afterState.entries()) {
    const r = n.beforeState.get(s) || 0;
    i !== r && og(
      n,
      /** @type {Array<Item|GC>} */
      e.store.clients.get(s),
      r,
      i,
      (o) => {
        !o.deleted && /** @type {Item} */
        o.content.constructor === Kt && o.constructor !== Pe && t.add(
          /** @type {any} */
          o.parent
        );
      }
    );
  }
  kt(e, (s) => {
    ti(n, n.deleteSet, (i) => {
      if (i instanceof Pe || !/** @type {YText} */
      i.parent._hasFormatting || t.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const r = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === Kt ? t.add(r) : T5(s, i);
    });
    for (const i of t)
      Rg(i);
  });
}, vp = (n, t, e) => {
  const s = e, i = Kh(t.currentAttributes), r = t.right;
  for (; e > 0 && t.right !== null; ) {
    if (t.right.deleted === !1)
      switch (t.right.content.constructor) {
        case qe:
        case qs:
        case Ye:
          e < t.right.length && Ee(n, st(t.right.id.client, t.right.id.clock + e)), e -= t.right.length, t.right.delete(n);
          break;
      }
    t.forward();
  }
  r && Mg(n, r, t.right, i, t.currentAttributes);
  const o = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (t.left || t.right).parent
  );
  return o._searchMarker && go(o._searchMarker, t.index, -s + e), t;
};
class Ru extends qo {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(t, e, s) {
    super(t, e), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), s.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const t = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = t;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const t = (
        /** @type {Doc} */
        this.target.doc
      ), e = [];
      kt(t, (s) => {
        const i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
        let o = this.target._start, a = null;
        const c = {};
        let l = "", h = 0, d = 0;
        const u = () => {
          if (a !== null) {
            let f = null;
            switch (a) {
              case "delete":
                d > 0 && (f = { delete: d }), d = 0;
                break;
              case "insert":
                (typeof l == "object" || l.length > 0) && (f = { insert: l }, i.size > 0 && (f.attributes = {}, i.forEach((p, m) => {
                  p !== null && (f.attributes[m] = p);
                }))), l = "";
                break;
              case "retain":
                h > 0 && (f = { retain: h }, yv(c) || (f.attributes = gv({}, c))), h = 0;
                break;
            }
            f && e.push(f), a = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case qe:
            case qs:
              this.adds(o) ? this.deletes(o) || (u(), a = "insert", l = o.content.getContent()[0], u()) : this.deletes(o) ? (a !== "delete" && (u(), a = "delete"), d += 1) : o.deleted || (a !== "retain" && (u(), a = "retain"), h += 1);
              break;
            case Ye:
              this.adds(o) ? this.deletes(o) || (a !== "insert" && (u(), a = "insert"), l += /** @type {ContentString} */
              o.content.str) : this.deletes(o) ? (a !== "delete" && (u(), a = "delete"), d += o.length) : o.deleted || (a !== "retain" && (u(), a = "retain"), h += o.length);
              break;
            case Kt: {
              const { key: f, value: p } = (
                /** @type {ContentFormat} */
                o.content
              );
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const m = i.get(f) ?? null;
                  un(m, p) ? p !== null && o.delete(s) : (a === "retain" && u(), un(p, r.get(f) ?? null) ? delete c[f] : c[f] = p);
                }
              } else if (this.deletes(o)) {
                r.set(f, p);
                const m = i.get(f) ?? null;
                un(m, p) || (a === "retain" && u(), c[f] = m);
              } else if (!o.deleted) {
                r.set(f, p);
                const m = c[f];
                m !== void 0 && (un(m, p) ? m !== null && o.delete(s) : (a === "retain" && u(), p === null ? delete c[f] : c[f] = p));
              }
              o.deleted || (a === "insert" && u(), yr(
                i,
                /** @type {ContentFormat} */
                o.content
              ));
              break;
            }
          }
          o = o.right;
        }
        for (u(); e.length > 0; ) {
          const f = e[e.length - 1];
          if (f.retain !== void 0 && f.attributes === void 0)
            e.pop();
          else
            break;
        }
      }), this._delta = e;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class pe extends se {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(t) {
    super(), this._pending = t !== void 0 ? [() => this.insert(0, t)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(t, e) {
    super._integrate(t, e);
    try {
      this._pending.forEach((s) => s());
    } catch (s) {
      console.error(s);
    }
    this._pending = null;
  }
  _copy() {
    return new pe();
  }
  /**
   * @return {YText}
   */
  clone() {
    const t = new pe();
    return t.applyDelta(this.toDelta()), t;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, e) {
    super._callObserver(t, e);
    const s = new Ru(this, t, e);
    Hc(this, t, s), !t.local && this._hasFormatting && (t._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let t = "", e = this._start;
    for (; e !== null; )
      !e.deleted && e.countable && e.content.constructor === Ye && (t += /** @type {ContentString} */
      e.content.str), e = e.right;
    return t;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(t, { sanitize: e = !0 } = {}) {
    this.doc !== null ? kt(this.doc, (s) => {
      const i = new ed(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let r = 0; r < t.length; r++) {
        const o = t[r];
        if (o.insert !== void 0) {
          const a = !e && typeof o.insert == "string" && r === t.length - 1 && i.right === null && o.insert.slice(-1) === `
` ? o.insert.slice(0, -1) : o.insert;
          (typeof a != "string" || a.length > 0) && ah(s, this, i, a, o.attributes || {});
        } else
          o.retain !== void 0 ? yp(s, this, i, o.retain, o.attributes || {}) : o.delete !== void 0 && vp(s, i, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(t));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(t, e, s) {
    const i = [], r = /* @__PURE__ */ new Map(), o = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", c = this._start;
    function l() {
      if (a.length > 0) {
        const d = {};
        let u = !1;
        r.forEach((p, m) => {
          u = !0, d[m] = p;
        });
        const f = { insert: a };
        u && (f.attributes = d), i.push(f), a = "";
      }
    }
    const h = () => {
      for (; c !== null; ) {
        if (an(c, t) || e !== void 0 && an(c, e))
          switch (c.content.constructor) {
            case Ye: {
              const d = r.get("ychange");
              t !== void 0 && !an(c, t) ? (d === void 0 || d.user !== c.id.client || d.type !== "removed") && (l(), r.set("ychange", s ? s("removed", c.id) : { type: "removed" })) : e !== void 0 && !an(c, e) ? (d === void 0 || d.user !== c.id.client || d.type !== "added") && (l(), r.set("ychange", s ? s("added", c.id) : { type: "added" })) : d !== void 0 && (l(), r.delete("ychange")), a += /** @type {ContentString} */
              c.content.str;
              break;
            }
            case qe:
            case qs: {
              l();
              const d = {
                insert: c.content.getContent()[0]
              };
              if (r.size > 0) {
                const u = (
                  /** @type {Object<string,any>} */
                  {}
                );
                d.attributes = u, r.forEach((f, p) => {
                  u[p] = f;
                });
              }
              i.push(d);
              break;
            }
            case Kt:
              an(c, t) && (l(), yr(
                r,
                /** @type {ContentFormat} */
                c.content
              ));
              break;
          }
        c = c.right;
      }
      l();
    };
    return t || e ? kt(o, (d) => {
      t && Qh(d, t), e && Qh(d, e), h();
    }, "cleanup") : h(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(t, e, s) {
    if (e.length <= 0)
      return;
    const i = this.doc;
    i !== null ? kt(i, (r) => {
      const o = da(r, this, t, !s);
      s || (s = {}, o.currentAttributes.forEach((a, c) => {
        s[c] = a;
      })), ah(r, this, o, e, s);
    }) : this._pending.push(() => this.insert(t, e, s));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(t, e, s) {
    const i = this.doc;
    i !== null ? kt(i, (r) => {
      const o = da(r, this, t, !s);
      ah(r, this, o, e, s || {});
    }) : this._pending.push(() => this.insertEmbed(t, e, s || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(t, e) {
    if (e === 0)
      return;
    const s = this.doc;
    s !== null ? kt(s, (i) => {
      vp(i, da(i, this, t, !0), e);
    }) : this._pending.push(() => this.delete(t, e));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(t, e, s) {
    if (e === 0)
      return;
    const i = this.doc;
    i !== null ? kt(i, (r) => {
      const o = da(r, this, t, !1);
      o.right !== null && yp(r, this, o, e, s);
    }) : this._pending.push(() => this.format(t, e, s));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(t) {
    this.doc !== null ? kt(this.doc, (e) => {
      Za(e, this, t);
    }) : this._pending.push(() => this.removeAttribute(t));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(t, e) {
    this.doc !== null ? kt(this.doc, (s) => {
      Ou(s, this, t, e);
    }) : this._pending.push(() => this.setAttribute(t, e));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(t) {
    return (
      /** @type {any} */
      Du(this, t)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return Tg(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(W5);
  }
}
const I5 = (n) => new pe();
class ch {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(t, e = () => !0) {
    this._filter = e, this._root = t, this._currentNode = /** @type {Item} */
    t._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let t = this._currentNode, e = t && t.content && /** @type {any} */
    t.content.type;
    if (t !== null && (!this._firstCall || t.deleted || !this._filter(e)))
      do
        if (e = /** @type {any} */
        t.content.type, !t.deleted && (e.constructor === mn || e.constructor === gn) && e._start !== null)
          t = e._start;
        else
          for (; t !== null; )
            if (t.right !== null) {
              t = t.right;
              break;
            } else
              t.parent === this._root ? t = null : t = /** @type {AbstractType<any>} */
              t.parent._item;
      while (t !== null && (t.deleted || !this._filter(
        /** @type {ContentType} */
        t.content.type
      )));
    return this._firstCall = !1, t === null ? { value: void 0, done: !0 } : (this._currentNode = t, { value: (
      /** @type {any} */
      t.content.type
    ), done: !1 });
  }
}
class gn extends se {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const t = this._first;
    return t ? t.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, e) {
    super._integrate(t, e), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new gn();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const t = new gn();
    return t.insert(0, this.toArray().map((e) => e instanceof se ? e.clone() : e)), t;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(t) {
    return new ch(this, t);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(t) {
    t = t.toUpperCase();
    const s = new ch(this, (i) => i.nodeName && i.nodeName.toUpperCase() === t).next();
    return s.done ? null : s.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(t) {
    return t = t.toUpperCase(), Gs(new ch(this, (e) => e.nodeName && e.nodeName.toUpperCase() === t));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, e) {
    Hc(this, t, new $g(this, e, t));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return Sg(this, (t) => t.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, e = {}, s) {
    const i = t.createDocumentFragment();
    return s !== void 0 && s._createAssociation(i, this), mo(this, (r) => {
      i.insertBefore(r.toDOM(t, e, s), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(t, e) {
    this.doc !== null ? kt(this.doc, (s) => {
      xg(s, this, t, e);
    }) : this._prelimContent.splice(t, 0, ...e);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(t, e) {
    if (this.doc !== null)
      kt(this.doc, (s) => {
        const i = t && t instanceof se ? t._item : t;
        Ya(s, this, i, e);
      });
    else {
      const s = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = t === null ? 0 : s.findIndex((r) => r === t) + 1;
      if (i === 0 && t !== null)
        throw zs("Reference item not found");
      s.splice(i, 0, ...e);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(t, e = 1) {
    this.doc !== null ? kt(this.doc, (s) => {
      Eg(s, this, t, e);
    }) : this._prelimContent.splice(t, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return wg(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(t) {
    this.insert(this.length, t);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(t) {
    this.insert(0, t);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(t) {
    return Cg(this, t);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(t = 0, e = this.length) {
    return bg(this, t, e);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(t) {
    mo(this, t);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(t) {
    t.writeTypeRef(Y5);
  }
}
const O5 = (n) => new gn();
class mn extends gn {
  constructor(t = "UNDEFINED") {
    super(), this.nodeName = t, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const t = this._item ? this._item.next : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const t = this._item ? this._item.prev : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, e) {
    super._integrate(t, e), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((s, i) => {
      this.setAttribute(i, s);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new mn(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const t = new mn(this.nodeName), e = this.getAttributes();
    return _v(e, (s, i) => {
      typeof s == "string" && t.setAttribute(i, s);
    }), t.insert(0, this.toArray().map((s) => s instanceof se ? s.clone() : s)), t;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const t = this.getAttributes(), e = [], s = [];
    for (const a in t)
      s.push(a);
    s.sort();
    const i = s.length;
    for (let a = 0; a < i; a++) {
      const c = s[a];
      e.push(c + '="' + t[c] + '"');
    }
    const r = this.nodeName.toLocaleLowerCase(), o = e.length > 0 ? " " + e.join(" ") : "";
    return `<${r}${o}>${super.toString()}</${r}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(t) {
    this.doc !== null ? kt(this.doc, (e) => {
      Za(e, this, t);
    }) : this._prelimAttrs.delete(t);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(t, e) {
    this.doc !== null ? kt(this.doc, (s) => {
      Ou(s, this, t, e);
    }) : this._prelimAttrs.set(t, e);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(t) {
    return (
      /** @type {any} */
      Du(this, t)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(t) {
    return (
      /** @type {any} */
      Ag(this, t)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(t) {
    return (
      /** @type {any} */
      t ? Ig(this, t) : Tg(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, e = {}, s) {
    const i = t.createElement(this.nodeName), r = this.getAttributes();
    for (const o in r) {
      const a = r[o];
      typeof a == "string" && i.setAttribute(o, a);
    }
    return mo(this, (o) => {
      i.appendChild(o.toDOM(t, e, s));
    }), s !== void 0 && s._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(t) {
    t.writeTypeRef(K5), t.writeKey(this.nodeName);
  }
}
const D5 = (n) => new mn(n.readKey());
class $g extends qo {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(t, e, s) {
    super(t, s), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), e.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class rr extends ne {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(t) {
    super(), this.hookName = t;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new rr(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const t = new rr(this.hookName);
    return this.forEach((e, s) => {
      t.set(s, e);
    }), t;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, e = {}, s) {
    const i = e[this.hookName];
    let r;
    return i !== void 0 ? r = i.createDom(this) : r = document.createElement(this.hookName), r.setAttribute("data-yjs-hook", this.hookName), s !== void 0 && s._createAssociation(r, this), r;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(t) {
    t.writeTypeRef(Z5), t.writeKey(this.hookName);
  }
}
const P5 = (n) => new rr(n.readKey());
class _o extends pe {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const t = this._item ? this._item.next : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const t = this._item ? this._item.prev : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  _copy() {
    return new _o();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const t = new _o();
    return t.applyDelta(this.toDelta()), t;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, e, s) {
    const i = t.createTextNode(this.toString());
    return s !== void 0 && s._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((t) => {
      const e = [];
      for (const i in t.attributes) {
        const r = [];
        for (const o in t.attributes[i])
          r.push({ key: o, value: t.attributes[i][o] });
        r.sort((o, a) => o.key < a.key ? -1 : 1), e.push({ nodeName: i, attrs: r });
      }
      e.sort((i, r) => i.nodeName < r.nodeName ? -1 : 1);
      let s = "";
      for (let i = 0; i < e.length; i++) {
        const r = e[i];
        s += `<${r.nodeName}`;
        for (let o = 0; o < r.attrs.length; o++) {
          const a = r.attrs[o];
          s += ` ${a.key}="${a.value}"`;
        }
        s += ">";
      }
      s += t.insert;
      for (let i = e.length - 1; i >= 0; i--)
        s += `</${e[i].nodeName}>`;
      return s;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(q5);
  }
}
const M5 = (n) => new _o();
class zc {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(t, e) {
    this.id = t, this.length = e;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw bs();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(t, e, s) {
    throw bs();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, e) {
    throw bs();
  }
}
const R5 = 0;
class Pe extends zc {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.constructor !== t.constructor ? !1 : (this.length += t.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, e) {
    e > 0 && (this.id.clock += e, this.length -= e), rg(t.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeInfo(R5), t.writeLen(this.length - e);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(t, e) {
    return null;
  }
}
class pi {
  /**
   * @param {Uint8Array} content
   */
  constructor(t) {
    this.content = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new pi(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(t) {
    throw bs();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
const $5 = (n) => new pi(n.readBuf());
class ei {
  /**
   * @param {number} len
   */
  constructor(t) {
    this.len = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ei(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(t) {
    const e = new ei(this.len - t);
    return this.len = t, e;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.len += t.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
    lo(t.deleteSet, e.id.client, e.id.clock, this.len), e.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeLen(this.len - e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const N5 = (n) => new ei(n.readLen()), Ng = (n, t) => new Tn({ guid: n, ...t, shouldLoad: t.shouldLoad || t.autoLoad || !1 });
class gi {
  /**
   * @param {Doc} doc
   */
  constructor(t) {
    t._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = t;
    const e = {};
    this.opts = e, t.gc || (e.gc = !1), t.autoLoad && (e.autoLoad = !0), t.meta !== null && (e.meta = t.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new gi(Ng(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(t) {
    throw bs();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
    this.doc._item = e, t.subdocsAdded.add(this.doc), this.doc.shouldLoad && t.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
    t.subdocsAdded.has(this.doc) ? t.subdocsAdded.delete(this.doc) : t.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeString(this.doc.guid), t.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
const L5 = (n) => new gi(Ng(n.readString(), n.readAny()));
class qs {
  /**
   * @param {Object} embed
   */
  constructor(t) {
    this.embed = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new qs(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(t) {
    throw bs();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
const U5 = (n) => new qs(n.readJSON());
class Kt {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(t, e) {
    this.key = t, this.value = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new Kt(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(t) {
    throw bs();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(t, e) {
    const s = (
      /** @type {YText} */
      e.parent
    );
    s._searchMarker = null, s._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeKey(this.key), t.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const F5 = (n) => new Kt(n.readKey(), n.readJSON());
class or {
  /**
   * @param {Array<any>} arr
   */
  constructor(t) {
    this.arr = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new or(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(t) {
    const e = new or(this.arr.slice(t));
    return this.arr = this.arr.slice(0, t), e;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.arr = this.arr.concat(t.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    const s = this.arr.length;
    t.writeLen(s - e);
    for (let i = e; i < s; i++) {
      const r = this.arr[i];
      t.writeString(r === void 0 ? "undefined" : JSON.stringify(r));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
}
const B5 = (n) => {
  const t = n.readLen(), e = [];
  for (let s = 0; s < t; s++) {
    const i = n.readString();
    i === "undefined" ? e.push(void 0) : e.push(JSON.parse(i));
  }
  return new or(e);
};
class Ks {
  /**
   * @param {Array<any>} arr
   */
  constructor(t) {
    this.arr = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Ks(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(t) {
    const e = new Ks(this.arr.slice(t));
    return this.arr = this.arr.slice(0, t), e;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.arr = this.arr.concat(t.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    const s = this.arr.length;
    t.writeLen(s - e);
    for (let i = e; i < s; i++) {
      const r = this.arr[i];
      t.writeAny(r);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
const V5 = (n) => {
  const t = n.readLen(), e = [];
  for (let s = 0; s < t; s++)
    e.push(n.readAny());
  return new Ks(e);
};
class Ye {
  /**
   * @param {string} str
   */
  constructor(t) {
    this.str = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Ye(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(t) {
    const e = new Ye(this.str.slice(t));
    this.str = this.str.slice(0, t);
    const s = this.str.charCodeAt(t - 1);
    return s >= 55296 && s <= 56319 && (this.str = this.str.slice(0, t - 1) + "", e.str = "" + e.str.slice(1)), e;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.str += t.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeString(e === 0 ? this.str : this.str.slice(e));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const j5 = (n) => new Ye(n.readString()), G5 = [
  x5,
  E5,
  I5,
  D5,
  O5,
  P5,
  M5
], H5 = 0, z5 = 1, W5 = 2, K5 = 3, Y5 = 4, Z5 = 5, q5 = 6;
class qe {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(t) {
    this.type = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new qe(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(t) {
    throw bs();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, e) {
    this.type._integrate(t.doc, e);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
    let e = this.type._start;
    for (; e !== null; )
      e.deleted ? e.id.clock < (t.beforeState.get(e.id.client) || 0) && t._mergeStructs.push(e) : e.delete(t), e = e.right;
    this.type._map.forEach((s) => {
      s.deleted ? s.id.clock < (t.beforeState.get(s.id.client) || 0) && t._mergeStructs.push(s) : s.delete(t);
    }), t.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
    let e = this.type._start;
    for (; e !== null; )
      e.gc(t, !0), e = e.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (s) => {
        for (; s !== null; )
          s.gc(t, !0), s = s.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    this.type._write(t);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const X5 = (n) => new qe(G5[n.readTypeRef()](n)), sd = (n, t) => {
  let e = t, s = 0, i;
  do
    s > 0 && (e = st(e.client, e.clock + s)), i = qr(n, e), s = e.clock - i.id.clock, e = i.redone;
  while (e !== null && i instanceof xt);
  return {
    item: i,
    diff: s
  };
}, $u = (n, t) => {
  for (; n !== null && n.keep !== t; )
    n.keep = t, n = /** @type {AbstractType<any>} */
    n.parent._item;
}, qa = (n, t, e) => {
  const { client: s, clock: i } = t.id, r = new xt(
    st(s, i + e),
    t,
    st(s, i + e - 1),
    t.right,
    t.rightOrigin,
    t.parent,
    t.parentSub,
    t.content.splice(e)
  );
  return t.deleted && r.markDeleted(), t.keep && (r.keep = !0), t.redone !== null && (r.redone = st(t.redone.client, t.redone.clock + e)), t.right = r, r.right !== null && (r.right.left = r), n._mergeStructs.push(r), r.parentSub !== null && r.right === null && r.parent._map.set(r.parentSub, r), t.length = e, r;
}, bp = (n, t) => Qy(
  n,
  /** @param {StackItem} s */
  (e) => fi(e.deletions, t)
), Lg = (n, t, e, s, i, r) => {
  const o = n.doc, a = o.store, c = o.clientID, l = t.redone;
  if (l !== null)
    return Ee(n, l);
  let h = (
    /** @type {AbstractType<any>} */
    t.parent._item
  ), d = null, u;
  if (h !== null && h.deleted === !0) {
    if (h.redone === null && (!e.has(h) || Lg(n, h, e, s, i, r) === null))
      return null;
    for (; h.redone !== null; )
      h = Ee(n, h.redone);
  }
  const f = h === null ? (
    /** @type {AbstractType<any>} */
    t.parent
  ) : (
    /** @type {ContentType} */
    h.content.type
  );
  if (t.parentSub === null) {
    for (d = t.left, u = t; d !== null; ) {
      let v = d;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== h; )
        v = v.redone === null ? null : Ee(n, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === h) {
        d = v;
        break;
      }
      d = d.left;
    }
    for (; u !== null; ) {
      let v = u;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== h; )
        v = v.redone === null ? null : Ee(n, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === h) {
        u = v;
        break;
      }
      u = u.right;
    }
  } else if (u = null, t.right && !i) {
    for (d = t; d !== null && d.right !== null && (d.right.redone || fi(s, d.right.id) || bp(r.undoStack, d.right.id) || bp(r.redoStack, d.right.id)); )
      for (d = d.right; d.redone; )
        d = Ee(n, d.redone);
    if (d && d.right !== null)
      return null;
  } else
    d = f._map.get(t.parentSub) || null;
  const p = Bt(a, c), m = st(c, p), _ = new xt(
    m,
    d,
    d && d.lastId,
    u,
    u && u.id,
    f,
    t.parentSub,
    t.content.copy()
  );
  return t.redone = m, $u(_, !0), _.integrate(n, 0), _;
};
class xt extends zc {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(t, e, s, i, r, o, a, c) {
    super(t, c.getLength()), this.origin = s, this.left = e, this.right = i, this.rightOrigin = r, this.parent = o, this.parentSub = a, this.redone = null, this.content = c, this.info = this.content.isCountable() ? Qf : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(t) {
    (this.info & nh) > 0 !== t && (this.info ^= nh);
  }
  get marker() {
    return (this.info & nh) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & Jf) > 0;
  }
  set keep(t) {
    this.keep !== t && (this.info ^= Jf);
  }
  get countable() {
    return (this.info & Qf) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & sh) > 0;
  }
  set deleted(t) {
    this.deleted !== t && (this.info ^= sh);
  }
  markDeleted() {
    this.info |= sh;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(t, e) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Bt(e, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Bt(e, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === Yn && this.id.client !== this.parent.client && this.parent.clock >= Bt(e, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = dp(t, e, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Ee(t, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === Pe || this.right && this.right.constructor === Pe)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === xt && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === xt && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === Yn) {
      const s = qr(e, this.parent);
      s.constructor === Pe ? this.parent = null : this.parent = /** @type {ContentType} */
      s.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, e) {
    if (e > 0 && (this.id.clock += e, this.left = dp(t, t.doc.store, st(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(e), this.length -= e), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let s = this.left, i;
        if (s !== null)
          i = s.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (o.add(i), r.add(i), Vn(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              s = i, r.clear();
            else if (Vn(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && o.has(qr(t.doc.store, i.origin)))
            r.has(qr(t.doc.store, i.origin)) || (s = i, r.clear());
          else
            break;
          i = i.right;
        }
        this.left = s;
      }
      if (this.left !== null) {
        const s = this.left.right;
        this.right = s, this.left.right = this;
      } else {
        let s;
        if (this.parentSub !== null)
          for (s = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; s !== null && s.left !== null; )
            s = s.left;
        else
          s = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = s;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(t)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), rg(t.doc.store, this), this.content.integrate(t, this), fp(
        t,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(t);
    } else
      new Pe(this.id, this.length).integrate(t, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let t = this.right;
    for (; t !== null && t.deleted; )
      t = t.right;
    return t;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let t = this.left;
    for (; t !== null && t.deleted; )
      t = t.left;
    return t;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : st(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(t) {
    if (this.constructor === t.constructor && Vn(t.origin, this.lastId) && this.right === t && Vn(this.rightOrigin, t.rightOrigin) && this.id.client === t.id.client && this.id.clock + this.length === t.id.clock && this.deleted === t.deleted && this.redone === null && t.redone === null && this.content.constructor === t.content.constructor && this.content.mergeWith(t.content)) {
      const e = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return e && e.forEach((s) => {
        s.p === t && (s.p = this, !this.deleted && this.countable && (s.index -= this.length));
      }), t.keep && (this.keep = !0), this.right = t.right, this.right !== null && (this.right.left = this), this.length += t.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(t) {
    if (!this.deleted) {
      const e = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (e._length -= this.length), this.markDeleted(), lo(t.deleteSet, this.id.client, this.id.clock, this.length), fp(t, e, this.parentSub), this.content.delete(t);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(t, e) {
    if (!this.deleted)
      throw Re();
    this.content.gc(t), e ? n5(t, this, new Pe(this.id, this.length)) : this.content = new ei(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(t, e) {
    const s = e > 0 ? st(this.id.client, this.id.clock + e - 1) : this.origin, i = this.rightOrigin, r = this.parentSub, o = this.content.getRef() & Rc | (s === null ? 0 : Ae) | // origin is defined
    (i === null ? 0 : Us) | // right origin is defined
    (r === null ? 0 : ro);
    if (t.writeInfo(o), s !== null && t.writeLeftID(s), i !== null && t.writeRightID(i), s === null && i === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const c = a._item;
        if (c === null) {
          const l = wu(a);
          t.writeParentInfo(!0), t.writeString(l);
        } else
          t.writeParentInfo(!1), t.writeLeftID(c.id);
      } else
        a.constructor === String ? (t.writeParentInfo(!0), t.writeString(a)) : a.constructor === Yn ? (t.writeParentInfo(!1), t.writeLeftID(a)) : Re();
      r !== null && t.writeString(r);
    }
    this.content.write(t, e);
  }
}
const Ug = (n, t) => J5[t & Rc](n), J5 = [
  () => {
    Re();
  },
  // GC is not ItemContent
  N5,
  // 1
  B5,
  // 2
  $5,
  // 3
  j5,
  // 4
  U5,
  // 5
  F5,
  // 6
  X5,
  // 7
  V5,
  // 8
  L5,
  // 9
  () => {
    Re();
  }
  // 10 - Skip is not ItemContent
], Q5 = 10;
class Te extends zc {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.constructor !== t.constructor ? !1 : (this.length += t.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, e) {
    Re();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, e) {
    t.writeInfo(Q5), et(t.restEncoder, this.length - e);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(t, e) {
    return null;
  }
}
const Fg = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), Bg = "__ $YJS$ __";
Fg[Bg] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
Fg[Bg] = !0;
const t3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbsolutePosition: eg,
  AbstractConnector: x4,
  AbstractStruct: zc,
  AbstractType: se,
  Array: de,
  ContentAny: Ks,
  ContentBinary: pi,
  ContentDeleted: ei,
  ContentDoc: gi,
  ContentEmbed: qs,
  ContentFormat: Kt,
  ContentJSON: or,
  ContentString: Ye,
  ContentType: qe,
  Doc: Tn,
  GC: Pe,
  ID: Yn,
  Item: xt,
  Map: ne,
  PermanentUserData: L4,
  RelativePosition: Vc,
  Skip: Te,
  Snapshot: Su,
  Text: pe,
  Transaction: ag,
  UndoManager: ku,
  UpdateDecoderV1: Ze,
  UpdateDecoderV2: Be,
  UpdateEncoderV1: An,
  UpdateEncoderV2: cs,
  XmlElement: mn,
  XmlFragment: gn,
  XmlHook: rr,
  XmlText: _o,
  YArrayEvent: Pu,
  YEvent: qo,
  YMapEvent: Mu,
  YTextEvent: Ru,
  YXmlEvent: $g,
  applyUpdate: uo,
  applyUpdateV2: Bc,
  cleanupYTextFormatting: Rg,
  compareIDs: Vn,
  compareRelativePositions: K4,
  convertUpdateFormatV1ToV2: g5,
  convertUpdateFormatV2ToV1: _g,
  createAbsolutePositionFromRelativePosition: W4,
  createDeleteSet: Uc,
  createDeleteSetFromStructStore: gu,
  createDocFromSnapshot: Q4,
  createID: st,
  createRelativePositionFromJSON: F4,
  createRelativePositionFromTypeIndex: V4,
  createSnapshot: Cu,
  decodeRelativePosition: z4,
  decodeSnapshot: q4,
  decodeSnapshotV2: ng,
  decodeStateVector: yu,
  decodeUpdate: c5,
  decodeUpdateV2: ug,
  diffUpdate: u5,
  diffUpdateV2: Tu,
  emptySnapshot: X4,
  encodeRelativePosition: G4,
  encodeSnapshot: Z4,
  encodeSnapshotV2: sg,
  encodeStateAsUpdate: Yo,
  encodeStateAsUpdateV2: J1,
  encodeStateVector: bu,
  encodeStateVectorFromUpdate: l5,
  encodeStateVectorFromUpdateV2: fg,
  equalDeleteSets: Y1,
  equalSnapshots: Y4,
  findIndexSS: Ke,
  findRootTypeKey: wu,
  getItem: qr,
  getState: Bt,
  getTypeChildren: b5,
  isDeleted: fi,
  isParentOf: fo,
  iterateDeletedStructs: ti,
  logType: N4,
  logUpdate: a5,
  logUpdateV2: dg,
  mergeUpdates: Eu,
  mergeUpdatesV2: po,
  obfuscateUpdate: f5,
  obfuscateUpdateV2: p5,
  parseUpdateMeta: h5,
  parseUpdateMetaV2: pg,
  readUpdate: D4,
  readUpdateV2: _u,
  relativePositionToJSON: U4,
  snapshot: J4,
  snapshotContainsUpdate: e5,
  transact: kt,
  tryGc: i5,
  typeListToArraySnapshot: w5,
  typeMapGetAllSnapshot: Ig,
  typeMapGetSnapshot: k5
}, Symbol.toStringTag, { value: "Module" })), e3 = [
  {
    desc: "frame element --> frame block (doc v1 --> v2)",
    condition: (n) => n < 2,
    migrate: (n, t) => {
      const e = t.getMap("blocks");
      let s, i;
      e.forEach((o) => {
        const a = o.get("sys:flavour");
        a === "affine:page" && (s = o), a === "affine:surface" && (i = o);
      }), B(s), B(i);
      const r = i.get("prop:elements").get("value");
      r.forEach((o) => {
        if (o.get("type") === "frame") {
          const a = new ne(), c = o.get("id");
          a.set("sys:flavour", "affine:frame"), a.set("sys:id", c), a.set("sys:children", new de()), a.set("prop:title", o.get("title").clone()), a.set("prop:xywh", o.get("xywh")), a.set("prop:index", o.get("index")), e.set(c, a), s.get("sys:children").push([c]), r.delete(c);
        }
      });
    }
  }
], s3 = (n) => {
  let t, e;
  const s = import("./index-B0nKyX_e.mjs").then(({ createStore: i, ...r }) => (t = i(`${n}_blob`, "blob"), e = i(`${n}_blob_mime`, "blob_mime"), r));
  return {
    crud: {
      get: async (i) => {
        const r = (await s).get, o = await r(i, t);
        return o ? new Blob([o], { type: await r(i, e) }) : null;
      },
      set: async (i, r) => {
        const o = (await s).set;
        return await o(i, await r.arrayBuffer(), t), await o(i, r.type, e), i;
      },
      delete: async (i) => {
        const r = (await s).del;
        await r(i, t), await r(i, e);
      },
      list: async () => {
        const i = (await s).keys;
        return i(t);
      }
    }
  };
}, n3 = () => {
  const n = /* @__PURE__ */ new Map();
  return {
    crud: {
      get: (t) => n.get(t) ?? null,
      set: (t, e) => (n.set(t, e), t),
      delete: (t) => {
        n.delete(t);
      },
      list: () => Array.from(n.keys())
    }
  };
}, lh = 2, hh = 2, dh = "Schema not found. The block flavour may not be registered.", Vg = "$blocksuite:internal:text$", Xr = "$blocksuite:internal:native$", i3 = /* @__PURE__ */ new Set(["id", "flavour", "children"]), eo = class eo {
  constructor(t) {
    t instanceof ne && t.get("type") === Xr ? this._map = t : (this._map = new ne(), this._map.set("type", Xr), this._map.set("value", t));
  }
  get yMap() {
    return this._map;
  }
  setValue(t) {
    return this._map.set("value", t);
  }
  getValue() {
    return this._map.get("value");
  }
};
eo.is = (t) => t instanceof ne && t.get("type") === Xr, eo.from = (t) => new eo(t.get("value"));
let ks = eo, vr = class Ma {
  constructor(t) {
    if (typeof t == "string") {
      const e = t.replaceAll(`\r
`, `
`);
      this._yText = new pe(e);
    } else if (t instanceof pe)
      this._yText = t;
    else if (t instanceof Array) {
      for (const s of t)
        s.insert && (s.insert = s.insert.replaceAll(`\r
`, `
`));
      const e = new pe();
      e.applyDelta(t), this._yText = e;
    } else
      this._yText = new pe();
  }
  static fromDelta(t) {
    const e = new pe();
    return e.applyDelta(t), new Ma(e);
  }
  get length() {
    return this._yText.length;
  }
  get yText() {
    return this._yText;
  }
  _transact(t) {
    const e = this._yText.doc;
    if (!e)
      throw new Error("Failed to transact text! yText is not attached to a doc");
    e.transact(() => {
      t();
    }, e.clientID);
  }
  clone() {
    return new Ma(this._yText.clone());
  }
  /**
   * NOTE: The string included in [index, index + length) will be deleted.
   *
   * Here are three cases for point position(index + length):
   * [{insert: 'abc', ...}, {insert: 'def', ...}, {insert: 'ghi', ...}]
   * 1. abc|de|fghi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'f', ...}, {insert: 'ghi', ...}]
   * 2. abc|def|ghi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'ghi', ...}]
   * 3. abc|defg|hi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'hi', ...}]
   */
  split(t, e = 0) {
    if (t < 0 || e < 0 || t + e > this._yText.length)
      throw new Error("Failed to split text! Index or length out of range, index: " + t + ", length: " + e + ", text length: " + this._yText.length);
    const s = this._yText.toDelta();
    if (!(s instanceof Array))
      throw new Error("This text cannot be split because we failed to get the deltas of it.");
    let i = 0;
    const r = [];
    for (let c = 0; c < s.length; c++) {
      const l = s[c].insert;
      if (typeof l == "string") {
        if (i + l.length >= t + e) {
          const h = l.slice(t + e - i);
          r.push({
            insert: h,
            attributes: s[c].attributes
          }), r.push(...s.slice(c + 1));
          break;
        }
        i += l.length;
      } else
        throw new Error("This text cannot be split because it contains non-string insert.");
    }
    this.delete(t, this.length - t);
    const o = new pe();
    return o.applyDelta(r), new Ma(o);
  }
  insert(t, e, s) {
    if (t.length) {
      if (e < 0 || e > this._yText.length)
        throw new Error("Failed to insert text! Index or length out of range, index: " + e + ", length: " + length + ", text length: " + this._yText.length);
      this._transact(() => {
        this._yText.insert(e, t, s);
      });
    }
  }
  join(t) {
    t.toDelta().length && this._transact(() => {
      const s = t._yText.toDelta();
      s.unshift({ retain: this._yText.length }), this._yText.applyDelta(s);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  format(t, e, s) {
    if (e !== 0) {
      if (t < 0 || e < 0 || t + e > this._yText.length)
        throw new Error("Failed to format text! Index or length out of range, index: " + t + ", length: " + e + ", text length: " + this._yText.length);
      this._transact(() => {
        this._yText.format(t, e, s);
      });
    }
  }
  delete(t, e) {
    if (e !== 0) {
      if (t < 0 || e < 0 || t + e > this._yText.length)
        throw new Error("Failed to delete text! Index or length out of range, index: " + t + ", length: " + e + ", text length: " + this._yText.length);
      this._transact(() => {
        this._yText.delete(t, e);
      });
    }
  }
  replace(t, e, s, i) {
    if (t < 0 || e < 0 || t + e > this._yText.length)
      throw new Error("Failed to replace text! The length of the text is" + this._yText.length + ", but you are trying to replace from" + t + "to" + t + e);
    this._transact(() => {
      this._yText.delete(t, e), this._yText.insert(t, s, i);
    });
  }
  clear() {
    this._yText.length && this._transact(() => {
      this._yText.delete(0, this._yText.length);
    });
  }
  applyDelta(t) {
    this._transact(() => {
      var e;
      (e = this._yText) == null || e.applyDelta(t);
    });
  }
  toDelta() {
    var t;
    return ((t = this._yText) == null ? void 0 : t.toDelta()) || [];
  }
  sliceToDelta(t, e) {
    const s = [];
    if (e && t >= e)
      return s;
    if (t === 0 && e === 0)
      return [];
    const i = this.toDelta();
    if (t < 1 && !e)
      return i;
    if (i && i instanceof Array) {
      let r = 0;
      for (let o = 0; o < i.length; o++) {
        const a = i[o];
        let c = a.insert || "";
        const l = c.length, h = e && r + l > e, d = r + l > t && s.length === 0;
        if (d && h) {
          c = c.slice(t - r, e - r), s.push({
            ...a,
            insert: c
          });
          break;
        } else
          d || h ? (c = h ? c.slice(0, e - r) : c.slice(t - r), s.push({
            ...a,
            insert: c
          })) : s.length > 0 && s.push(a);
        if (e && r + l > e)
          break;
        r = r + l;
      }
    }
    return s;
  }
  toString() {
    var t;
    return ((t = this._yText) == null ? void 0 : t.toString()) || "";
  }
};
function jg(n) {
  return n !== null && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && [Object, void 0, null].some((t) => t === n.constructor);
}
function _n(n, { deep: t = !0, transform: e = (s) => s } = {}) {
  if (n instanceof ks)
    return n.yMap;
  if (n instanceof vr)
    return n.yText.doc ? n.yText.clone() : n.yText;
  if (Array.isArray(n)) {
    const s = new de(), i = n.map((r) => t ? _n(r, { deep: t, transform: e }) : r);
    return s.insert(0, i), s;
  }
  if (jg(n)) {
    const s = new ne();
    return Object.entries(n).forEach(([i, r]) => {
      s.set(i, t ? _n(r, { deep: t, transform: e }) : r);
    }), s;
  }
  return n;
}
function Xa(n, { deep: t = !0, transform: e = (s) => s } = {}) {
  if (ks.is(n)) {
    const s = new ks(n);
    return e(s, n);
  }
  if (n instanceof pe) {
    const s = new vr(n);
    return e(s, n);
  }
  if (n instanceof de) {
    const s = n.toArray().map((i) => t ? Xa(i, { deep: t, transform: e }) : i);
    return e(s, n);
  }
  if (n instanceof ne) {
    const s = Object.fromEntries(Array.from(n.entries()).map(([i, r]) => [i, t ? Xa(r, { deep: t, transform: e }) : r]));
    return e(s, n);
  }
  return e(n, n);
}
class Gg {
  constructor() {
    this._skipNext = !1, this._stashed = /* @__PURE__ */ new Set(), this._getOrigin = (t) => ({
      doc: t,
      proxy: !0,
      target: this
    }), this._updateWithSkip = (t) => {
      this._skipNext = !0, t(), this._skipNext = !1;
    }, this._transact = (t, e) => {
      t.transact(e, this._getOrigin(t));
    }, this._onObserve = (t, e) => {
      var s, i, r;
      ((s = t.transaction.origin) == null ? void 0 : s.proxy) !== !0 && (!t.transaction.local || t.transaction.origin instanceof ku) && e(), (r = (i = this._options).onChange) == null || r.call(i, this._proxy);
    };
  }
  get proxy() {
    return this._proxy;
  }
}
const _s = /* @__PURE__ */ new WeakMap();
class r3 extends Gg {
  constructor(t, e, s) {
    super(), this._source = t, this._ySource = e, this._options = s, this._getProxy = () => new Proxy(this._source, {
      has: (i, r) => Reflect.has(i, r),
      set: (i, r, o, a) => {
        var f, p;
        if (typeof r != "string")
          throw new Error("key cannot be a symbol");
        const c = Number(r);
        if (this._skipNext || Number.isNaN(c))
          return Reflect.set(i, r, o, a);
        if (this._stashed.has(c)) {
          const m = Reflect.set(i, r, o, a);
          return (p = (f = this._options).onChange) == null || p.call(f, this._proxy), m;
        }
        const l = _s.get(this._ySource);
        B(l, "YData is not subscribed before changes");
        const h = this._ySource.doc;
        B(h, "YData is not bound to a Y.Doc");
        const d = _n(o);
        this._transact(h, () => {
          c < this._ySource.length && this._ySource.delete(c, 1), this._ySource.insert(c, [d]);
        });
        const u = si(d, this._options);
        return Reflect.set(i, r, u, a);
      },
      get: (i, r, o) => Reflect.get(i, r, o),
      deleteProperty: (i, r) => {
        if (typeof r != "string")
          throw new Error("key cannot be a symbol");
        const o = _s.get(this._ySource);
        B(o, "YData is not subscribed before changes");
        const a = this._ySource.doc;
        B(a, "YData is not bound to a Y.Doc");
        const c = Number(r);
        return this._skipNext || Number.isNaN(c) || this._transact(a, () => {
          this._ySource.delete(c, 1);
        }), Reflect.deleteProperty(i, r);
      }
    }), this._observer = (i) => {
      this._onObserve(i, () => {
        let r = 0;
        i.changes.delta.forEach((o) => {
          if (o.retain) {
            r += o.retain;
            return;
          }
          if (o.delete) {
            this._updateWithSkip(() => {
              this._source.splice(r, o.delete);
            });
            return;
          }
          if (o.insert) {
            const c = [o.insert].flat().map((l) => si(l));
            this._updateWithSkip(() => {
              this._source.splice(r, 0, ...c);
            }), r += o.insert.length;
          }
        });
      });
    }, this._proxy = this._getProxy(), _s.set(e, this), e.observe(this._observer);
  }
  stash(t) {
    this._stashed.add(t);
  }
  pop(t) {
    const e = this._source[t];
    this._stashed.delete(t), this._proxy[t] = e;
  }
}
class o3 extends Gg {
  constructor(t, e, s) {
    super(), this._source = t, this._ySource = e, this._options = s, this._getProxy = () => new Proxy(this._source, {
      has: (i, r) => Reflect.has(i, r),
      set: (i, r, o, a) => {
        var u, f;
        if (typeof r != "string")
          throw new Error("key cannot be a symbol");
        if (this._skipNext)
          return Reflect.set(i, r, o, a);
        if (this._stashed.has(r)) {
          const p = Reflect.set(i, r, o, a);
          return (f = (u = this._options).onChange) == null || f.call(u, this._proxy), p;
        }
        const c = _s.get(this._ySource);
        B(c, "YData is not subscribed before changes");
        const l = this._ySource.doc;
        B(l, "YData is not bound to a Y.Doc");
        const h = _n(o);
        this._transact(l, () => {
          this._ySource.set(r, h);
        });
        const d = si(h, this._options);
        return Reflect.set(i, r, d, a);
      },
      get: (i, r, o) => Reflect.get(i, r, o),
      deleteProperty: (i, r) => {
        if (typeof r != "string")
          throw new Error("key cannot be a symbol");
        if (this._skipNext)
          return Reflect.deleteProperty(i, r);
        const o = _s.get(this._ySource);
        B(o, "YData is not subscribed before changes");
        const a = this._ySource.doc;
        return B(a, "YData is not bound to a Y.Doc"), this._transact(a, () => {
          this._ySource.delete(r);
        }), Reflect.deleteProperty(i, r);
      }
    }), this._observer = (i) => {
      this._onObserve(i, () => {
        i.keysChanged.forEach((r) => {
          const o = i.changes.keys.get(r);
          if (o) {
            if (o.action === "delete")
              this._updateWithSkip(() => {
                delete this._source[r];
              });
            else if (o.action === "add" || o.action === "update") {
              const a = this._ySource.get(r);
              this._updateWithSkip(() => {
                this._source[r] = _s.has(a) ? _s.get(a) : si(a, this._options);
              });
            }
          }
        });
      });
    }, this._proxy = this._getProxy(), _s.set(e, this), e.observe(this._observer);
  }
  stash(t) {
    this._stashed.add(t);
  }
  pop(t) {
    const e = this._source[t];
    this._stashed.delete(t), this._proxy[t] = e;
  }
}
function si(n, t = {}) {
  return _s.has(n) ? _s.get(n).proxy : Xa(n, {
    transform: (e, s) => ks.is(s) ? e : s instanceof de ? new r3(e, s, t).proxy : s instanceof ne ? new o3(e, s, t).proxy : e
  });
}
var yt;
(function(n) {
  n.assertEqual = (i) => i;
  function t(i) {
  }
  n.assertIs = t;
  function e(i) {
    throw new Error();
  }
  n.assertNever = e, n.arrayToEnum = (i) => {
    const r = {};
    for (const o of i)
      r[o] = o;
    return r;
  }, n.getValidEnumValues = (i) => {
    const r = n.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), o = {};
    for (const a of r)
      o[a] = i[a];
    return n.objectValues(o);
  }, n.objectValues = (i) => n.objectKeys(i).map(function(r) {
    return i[r];
  }), n.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const r = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && r.push(o);
    return r;
  }, n.find = (i, r) => {
    for (const o of i)
      if (r(o))
        return o;
  }, n.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function s(i, r = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(r);
  }
  n.joinValues = s, n.jsonStringifyReplacer = (i, r) => typeof r == "bigint" ? r.toString() : r;
})(yt || (yt = {}));
var nd;
(function(n) {
  n.mergeShapes = (t, e) => ({
    ...t,
    ...e
    // second overwrites first
  });
})(nd || (nd = {}));
const G = yt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ln = (n) => {
  switch (typeof n) {
    case "undefined":
      return G.undefined;
    case "string":
      return G.string;
    case "number":
      return isNaN(n) ? G.nan : G.number;
    case "boolean":
      return G.boolean;
    case "function":
      return G.function;
    case "bigint":
      return G.bigint;
    case "symbol":
      return G.symbol;
    case "object":
      return Array.isArray(n) ? G.array : n === null ? G.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? G.promise : typeof Map < "u" && n instanceof Map ? G.map : typeof Set < "u" && n instanceof Set ? G.set : typeof Date < "u" && n instanceof Date ? G.date : G.object;
    default:
      return G.unknown;
  }
}, N = yt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), a3 = (n) => JSON.stringify(n, null, 2).replace(/"([^"]+)":/g, "$1:");
class ss extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (s) => {
      this.issues = [...this.issues, s];
    }, this.addIssues = (s = []) => {
      this.issues = [...this.issues, ...s];
    };
    const e = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e) : this.__proto__ = e, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const e = t || function(r) {
      return r.message;
    }, s = { _errors: [] }, i = (r) => {
      for (const o of r.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          s._errors.push(e(o));
        else {
          let a = s, c = 0;
          for (; c < o.path.length; ) {
            const l = o.path[c];
            c === o.path.length - 1 ? (a[l] = a[l] || { _errors: [] }, a[l]._errors.push(e(o))) : a[l] = a[l] || { _errors: [] }, a = a[l], c++;
          }
        }
    };
    return i(this), s;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, yt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (e) => e.message) {
    const e = {}, s = [];
    for (const i of this.issues)
      i.path.length > 0 ? (e[i.path[0]] = e[i.path[0]] || [], e[i.path[0]].push(t(i))) : s.push(t(i));
    return { formErrors: s, fieldErrors: e };
  }
  get formErrors() {
    return this.flatten();
  }
}
ss.create = (n) => new ss(n);
const yo = (n, t) => {
  let e;
  switch (n.code) {
    case N.invalid_type:
      n.received === G.undefined ? e = "Required" : e = `Expected ${n.expected}, received ${n.received}`;
      break;
    case N.invalid_literal:
      e = `Invalid literal value, expected ${JSON.stringify(n.expected, yt.jsonStringifyReplacer)}`;
      break;
    case N.unrecognized_keys:
      e = `Unrecognized key(s) in object: ${yt.joinValues(n.keys, ", ")}`;
      break;
    case N.invalid_union:
      e = "Invalid input";
      break;
    case N.invalid_union_discriminator:
      e = `Invalid discriminator value. Expected ${yt.joinValues(n.options)}`;
      break;
    case N.invalid_enum_value:
      e = `Invalid enum value. Expected ${yt.joinValues(n.options)}, received '${n.received}'`;
      break;
    case N.invalid_arguments:
      e = "Invalid function arguments";
      break;
    case N.invalid_return_type:
      e = "Invalid function return type";
      break;
    case N.invalid_date:
      e = "Invalid date";
      break;
    case N.invalid_string:
      typeof n.validation == "object" ? "includes" in n.validation ? (e = `Invalid input: must include "${n.validation.includes}"`, typeof n.validation.position == "number" && (e = `${e} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith" in n.validation ? e = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith" in n.validation ? e = `Invalid input: must end with "${n.validation.endsWith}"` : yt.assertNever(n.validation) : n.validation !== "regex" ? e = `Invalid ${n.validation}` : e = "Invalid";
      break;
    case N.too_small:
      n.type === "array" ? e = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? e = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? e = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? e = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : e = "Invalid input";
      break;
    case N.too_big:
      n.type === "array" ? e = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? e = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? e = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? e = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? e = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : e = "Invalid input";
      break;
    case N.custom:
      e = "Invalid input";
      break;
    case N.invalid_intersection_types:
      e = "Intersection results could not be merged";
      break;
    case N.not_multiple_of:
      e = `Number must be a multiple of ${n.multipleOf}`;
      break;
    case N.not_finite:
      e = "Number must be finite";
      break;
    default:
      e = t.defaultError, yt.assertNever(n);
  }
  return { message: e };
};
let Hg = yo;
function c3(n) {
  Hg = n;
}
function Ja() {
  return Hg;
}
const Qa = (n) => {
  const { data: t, path: e, errorMaps: s, issueData: i } = n, r = [...e, ...i.path || []], o = {
    ...i,
    path: r
  };
  let a = "";
  const c = s.filter((l) => !!l).slice().reverse();
  for (const l of c)
    a = l(o, { data: t, defaultError: a }).message;
  return {
    ...i,
    path: r,
    message: i.message || a
  };
}, l3 = [];
function H(n, t) {
  const e = Qa({
    issueData: t,
    data: n.data,
    path: n.path,
    errorMaps: [
      n.common.contextualErrorMap,
      n.schemaErrorMap,
      Ja(),
      yo
      // then global default map
    ].filter((s) => !!s)
  });
  n.common.issues.push(e);
}
class we {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, e) {
    const s = [];
    for (const i of e) {
      if (i.status === "aborted")
        return it;
      i.status === "dirty" && t.dirty(), s.push(i.value);
    }
    return { status: t.value, value: s };
  }
  static async mergeObjectAsync(t, e) {
    const s = [];
    for (const i of e)
      s.push({
        key: await i.key,
        value: await i.value
      });
    return we.mergeObjectSync(t, s);
  }
  static mergeObjectSync(t, e) {
    const s = {};
    for (const i of e) {
      const { key: r, value: o } = i;
      if (r.status === "aborted" || o.status === "aborted")
        return it;
      r.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), r.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (s[r.value] = o.value);
    }
    return { status: t.value, value: s };
  }
}
const it = Object.freeze({
  status: "aborted"
}), zg = (n) => ({ status: "dirty", value: n }), Ie = (n) => ({ status: "valid", value: n }), id = (n) => n.status === "aborted", rd = (n) => n.status === "dirty", vo = (n) => n.status === "valid", tc = (n) => typeof Promise < "u" && n instanceof Promise;
var Y;
(function(n) {
  n.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, n.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Y || (Y = {}));
class xs {
  constructor(t, e, s, i) {
    this._cachedPath = [], this.parent = t, this.data = e, this._path = s, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const wp = (n, t) => {
  if (vo(t))
    return { success: !0, data: t.value };
  if (!n.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const e = new ss(n.common.issues);
      return this._error = e, this._error;
    }
  };
};
function at(n) {
  if (!n)
    return {};
  const { errorMap: t, invalid_type_error: e, required_error: s, description: i } = n;
  if (t && (e || s))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, a) => o.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: s ?? a.defaultError } : { message: e ?? a.defaultError }, description: i };
}
class dt {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ln(t.data);
  }
  _getOrReturnCtx(t, e) {
    return e || {
      common: t.parent.common,
      data: t.data,
      parsedType: ln(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new we(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ln(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const e = this._parse(t);
    if (tc(e))
      throw new Error("Synchronous parse encountered promise.");
    return e;
  }
  _parseAsync(t) {
    const e = this._parse(t);
    return Promise.resolve(e);
  }
  parse(t, e) {
    const s = this.safeParse(t, e);
    if (s.success)
      return s.data;
    throw s.error;
  }
  safeParse(t, e) {
    var s;
    const i = {
      common: {
        issues: [],
        async: (s = e == null ? void 0 : e.async) !== null && s !== void 0 ? s : !1,
        contextualErrorMap: e == null ? void 0 : e.errorMap
      },
      path: (e == null ? void 0 : e.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ln(t)
    }, r = this._parseSync({ data: t, path: i.path, parent: i });
    return wp(i, r);
  }
  async parseAsync(t, e) {
    const s = await this.safeParseAsync(t, e);
    if (s.success)
      return s.data;
    throw s.error;
  }
  async safeParseAsync(t, e) {
    const s = {
      common: {
        issues: [],
        contextualErrorMap: e == null ? void 0 : e.errorMap,
        async: !0
      },
      path: (e == null ? void 0 : e.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ln(t)
    }, i = this._parse({ data: t, path: s.path, parent: s }), r = await (tc(i) ? i : Promise.resolve(i));
    return wp(s, r);
  }
  refine(t, e) {
    const s = (i) => typeof e == "string" || typeof e > "u" ? { message: e } : typeof e == "function" ? e(i) : e;
    return this._refinement((i, r) => {
      const o = t(i), a = () => r.addIssue({
        code: N.custom,
        ...s(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(t, e) {
    return this._refinement((s, i) => t(s) ? !0 : (i.addIssue(typeof e == "function" ? e(s, i) : e), !1));
  }
  _refinement(t) {
    return new ls({
      schema: this,
      typeName: Q.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Fs.create(this, this._def);
  }
  nullable() {
    return ri.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ns.create(this, this._def);
  }
  promise() {
    return cr.create(this, this._def);
  }
  or(t) {
    return Co.create([this, t], this._def);
  }
  and(t) {
    return ko.create(this, t, this._def);
  }
  transform(t) {
    return new ls({
      ...at(this._def),
      schema: this,
      typeName: Q.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const e = typeof t == "function" ? t : () => t;
    return new Io({
      ...at(this._def),
      innerType: this,
      defaultValue: e,
      typeName: Q.ZodDefault
    });
  }
  brand() {
    return new Kg({
      typeName: Q.ZodBranded,
      type: this,
      ...at(this._def)
    });
  }
  catch(t) {
    const e = typeof t == "function" ? t : () => t;
    return new ic({
      ...at(this._def),
      innerType: this,
      catchValue: e,
      typeName: Q.ZodCatch
    });
  }
  describe(t) {
    const e = this.constructor;
    return new e({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Xo.create(this, t);
  }
  readonly() {
    return oc.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const h3 = /^c[^\s-]{8,}$/i, d3 = /^[a-z][a-z0-9]*$/, u3 = /^[0-9A-HJKMNP-TV-Z]{26}$/, f3 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, p3 = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, g3 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let uh;
const m3 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, _3 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, y3 = (n) => n.precision ? n.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${n.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${n.precision}}Z$`) : n.precision === 0 ? n.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : n.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function v3(n, t) {
  return !!((t === "v4" || !t) && m3.test(n) || (t === "v6" || !t) && _3.test(n));
}
class es extends dt {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== G.string) {
      const r = this._getOrReturnCtx(t);
      return H(
        r,
        {
          code: N.invalid_type,
          expected: G.string,
          received: r.parsedType
        }
        //
      ), it;
    }
    const s = new we();
    let i;
    for (const r of this._def.checks)
      if (r.kind === "min")
        t.data.length < r.value && (i = this._getOrReturnCtx(t, i), H(i, {
          code: N.too_small,
          minimum: r.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: r.message
        }), s.dirty());
      else if (r.kind === "max")
        t.data.length > r.value && (i = this._getOrReturnCtx(t, i), H(i, {
          code: N.too_big,
          maximum: r.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: r.message
        }), s.dirty());
      else if (r.kind === "length") {
        const o = t.data.length > r.value, a = t.data.length < r.value;
        (o || a) && (i = this._getOrReturnCtx(t, i), o ? H(i, {
          code: N.too_big,
          maximum: r.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: r.message
        }) : a && H(i, {
          code: N.too_small,
          minimum: r.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: r.message
        }), s.dirty());
      } else if (r.kind === "email")
        p3.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "email",
          code: N.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "emoji")
        uh || (uh = new RegExp(g3, "u")), uh.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "emoji",
          code: N.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "uuid")
        f3.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "uuid",
          code: N.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "cuid")
        h3.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "cuid",
          code: N.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "cuid2")
        d3.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "cuid2",
          code: N.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "ulid")
        u3.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "ulid",
          code: N.invalid_string,
          message: r.message
        }), s.dirty());
      else if (r.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), H(i, {
            validation: "url",
            code: N.invalid_string,
            message: r.message
          }), s.dirty();
        }
      else
        r.kind === "regex" ? (r.regex.lastIndex = 0, r.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "regex",
          code: N.invalid_string,
          message: r.message
        }), s.dirty())) : r.kind === "trim" ? t.data = t.data.trim() : r.kind === "includes" ? t.data.includes(r.value, r.position) || (i = this._getOrReturnCtx(t, i), H(i, {
          code: N.invalid_string,
          validation: { includes: r.value, position: r.position },
          message: r.message
        }), s.dirty()) : r.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : r.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : r.kind === "startsWith" ? t.data.startsWith(r.value) || (i = this._getOrReturnCtx(t, i), H(i, {
          code: N.invalid_string,
          validation: { startsWith: r.value },
          message: r.message
        }), s.dirty()) : r.kind === "endsWith" ? t.data.endsWith(r.value) || (i = this._getOrReturnCtx(t, i), H(i, {
          code: N.invalid_string,
          validation: { endsWith: r.value },
          message: r.message
        }), s.dirty()) : r.kind === "datetime" ? y3(r).test(t.data) || (i = this._getOrReturnCtx(t, i), H(i, {
          code: N.invalid_string,
          validation: "datetime",
          message: r.message
        }), s.dirty()) : r.kind === "ip" ? v3(t.data, r.version) || (i = this._getOrReturnCtx(t, i), H(i, {
          validation: "ip",
          code: N.invalid_string,
          message: r.message
        }), s.dirty()) : yt.assertNever(r);
    return { status: s.value, value: t.data };
  }
  _regex(t, e, s) {
    return this.refinement((i) => t.test(i), {
      validation: e,
      code: N.invalid_string,
      ...Y.errToObj(s)
    });
  }
  _addCheck(t) {
    return new es({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Y.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Y.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Y.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Y.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Y.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Y.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Y.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Y.errToObj(t) });
  }
  datetime(t) {
    var e;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (e = t == null ? void 0 : t.offset) !== null && e !== void 0 ? e : !1,
      ...Y.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, e) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Y.errToObj(e)
    });
  }
  includes(t, e) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: e == null ? void 0 : e.position,
      ...Y.errToObj(e == null ? void 0 : e.message)
    });
  }
  startsWith(t, e) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Y.errToObj(e)
    });
  }
  endsWith(t, e) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Y.errToObj(e)
    });
  }
  min(t, e) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Y.errToObj(e)
    });
  }
  max(t, e) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Y.errToObj(e)
    });
  }
  length(t, e) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Y.errToObj(e)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, Y.errToObj(t));
  }
  trim() {
    return new es({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new es({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new es({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
}
es.create = (n) => {
  var t;
  return new es({
    checks: [],
    typeName: Q.ZodString,
    coerce: (t = n == null ? void 0 : n.coerce) !== null && t !== void 0 ? t : !1,
    ...at(n)
  });
};
function b3(n, t) {
  const e = (n.toString().split(".")[1] || "").length, s = (t.toString().split(".")[1] || "").length, i = e > s ? e : s, r = parseInt(n.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return r % o / Math.pow(10, i);
}
class yn extends dt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== G.number) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: N.invalid_type,
        expected: G.number,
        received: r.parsedType
      }), it;
    }
    let s;
    const i = new we();
    for (const r of this._def.checks)
      r.kind === "int" ? yt.isInteger(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.invalid_type,
        expected: "integer",
        received: "float",
        message: r.message
      }), i.dirty()) : r.kind === "min" ? (r.inclusive ? t.data < r.value : t.data <= r.value) && (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.too_small,
        minimum: r.value,
        type: "number",
        inclusive: r.inclusive,
        exact: !1,
        message: r.message
      }), i.dirty()) : r.kind === "max" ? (r.inclusive ? t.data > r.value : t.data >= r.value) && (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.too_big,
        maximum: r.value,
        type: "number",
        inclusive: r.inclusive,
        exact: !1,
        message: r.message
      }), i.dirty()) : r.kind === "multipleOf" ? b3(t.data, r.value) !== 0 && (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.not_multiple_of,
        multipleOf: r.value,
        message: r.message
      }), i.dirty()) : r.kind === "finite" ? Number.isFinite(t.data) || (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.not_finite,
        message: r.message
      }), i.dirty()) : yt.assertNever(r);
    return { status: i.value, value: t.data };
  }
  gte(t, e) {
    return this.setLimit("min", t, !0, Y.toString(e));
  }
  gt(t, e) {
    return this.setLimit("min", t, !1, Y.toString(e));
  }
  lte(t, e) {
    return this.setLimit("max", t, !0, Y.toString(e));
  }
  lt(t, e) {
    return this.setLimit("max", t, !1, Y.toString(e));
  }
  setLimit(t, e, s, i) {
    return new yn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: e,
          inclusive: s,
          message: Y.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new yn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Y.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Y.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Y.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Y.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Y.toString(t)
    });
  }
  multipleOf(t, e) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Y.toString(e)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Y.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Y.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Y.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && yt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, e = null;
    for (const s of this._def.checks) {
      if (s.kind === "finite" || s.kind === "int" || s.kind === "multipleOf")
        return !0;
      s.kind === "min" ? (e === null || s.value > e) && (e = s.value) : s.kind === "max" && (t === null || s.value < t) && (t = s.value);
    }
    return Number.isFinite(e) && Number.isFinite(t);
  }
}
yn.create = (n) => new yn({
  checks: [],
  typeName: Q.ZodNumber,
  coerce: (n == null ? void 0 : n.coerce) || !1,
  ...at(n)
});
class vn extends dt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== G.bigint) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: N.invalid_type,
        expected: G.bigint,
        received: r.parsedType
      }), it;
    }
    let s;
    const i = new we();
    for (const r of this._def.checks)
      r.kind === "min" ? (r.inclusive ? t.data < r.value : t.data <= r.value) && (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.too_small,
        type: "bigint",
        minimum: r.value,
        inclusive: r.inclusive,
        message: r.message
      }), i.dirty()) : r.kind === "max" ? (r.inclusive ? t.data > r.value : t.data >= r.value) && (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.too_big,
        type: "bigint",
        maximum: r.value,
        inclusive: r.inclusive,
        message: r.message
      }), i.dirty()) : r.kind === "multipleOf" ? t.data % r.value !== BigInt(0) && (s = this._getOrReturnCtx(t, s), H(s, {
        code: N.not_multiple_of,
        multipleOf: r.value,
        message: r.message
      }), i.dirty()) : yt.assertNever(r);
    return { status: i.value, value: t.data };
  }
  gte(t, e) {
    return this.setLimit("min", t, !0, Y.toString(e));
  }
  gt(t, e) {
    return this.setLimit("min", t, !1, Y.toString(e));
  }
  lte(t, e) {
    return this.setLimit("max", t, !0, Y.toString(e));
  }
  lt(t, e) {
    return this.setLimit("max", t, !1, Y.toString(e));
  }
  setLimit(t, e, s, i) {
    return new vn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: e,
          inclusive: s,
          message: Y.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new vn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Y.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Y.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Y.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Y.toString(t)
    });
  }
  multipleOf(t, e) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Y.toString(e)
    });
  }
  get minValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
}
vn.create = (n) => {
  var t;
  return new vn({
    checks: [],
    typeName: Q.ZodBigInt,
    coerce: (t = n == null ? void 0 : n.coerce) !== null && t !== void 0 ? t : !1,
    ...at(n)
  });
};
class bo extends dt {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== G.boolean) {
      const s = this._getOrReturnCtx(t);
      return H(s, {
        code: N.invalid_type,
        expected: G.boolean,
        received: s.parsedType
      }), it;
    }
    return Ie(t.data);
  }
}
bo.create = (n) => new bo({
  typeName: Q.ZodBoolean,
  coerce: (n == null ? void 0 : n.coerce) || !1,
  ...at(n)
});
class ni extends dt {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== G.date) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: N.invalid_type,
        expected: G.date,
        received: r.parsedType
      }), it;
    }
    if (isNaN(t.data.getTime())) {
      const r = this._getOrReturnCtx(t);
      return H(r, {
        code: N.invalid_date
      }), it;
    }
    const s = new we();
    let i;
    for (const r of this._def.checks)
      r.kind === "min" ? t.data.getTime() < r.value && (i = this._getOrReturnCtx(t, i), H(i, {
        code: N.too_small,
        message: r.message,
        inclusive: !0,
        exact: !1,
        minimum: r.value,
        type: "date"
      }), s.dirty()) : r.kind === "max" ? t.data.getTime() > r.value && (i = this._getOrReturnCtx(t, i), H(i, {
        code: N.too_big,
        message: r.message,
        inclusive: !0,
        exact: !1,
        maximum: r.value,
        type: "date"
      }), s.dirty()) : yt.assertNever(r);
    return {
      status: s.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new ni({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, e) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Y.toString(e)
    });
  }
  max(t, e) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Y.toString(e)
    });
  }
  get minDate() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t != null ? new Date(t) : null;
  }
}
ni.create = (n) => new ni({
  checks: [],
  coerce: (n == null ? void 0 : n.coerce) || !1,
  typeName: Q.ZodDate,
  ...at(n)
});
class ec extends dt {
  _parse(t) {
    if (this._getType(t) !== G.symbol) {
      const s = this._getOrReturnCtx(t);
      return H(s, {
        code: N.invalid_type,
        expected: G.symbol,
        received: s.parsedType
      }), it;
    }
    return Ie(t.data);
  }
}
ec.create = (n) => new ec({
  typeName: Q.ZodSymbol,
  ...at(n)
});
class wo extends dt {
  _parse(t) {
    if (this._getType(t) !== G.undefined) {
      const s = this._getOrReturnCtx(t);
      return H(s, {
        code: N.invalid_type,
        expected: G.undefined,
        received: s.parsedType
      }), it;
    }
    return Ie(t.data);
  }
}
wo.create = (n) => new wo({
  typeName: Q.ZodUndefined,
  ...at(n)
});
class So extends dt {
  _parse(t) {
    if (this._getType(t) !== G.null) {
      const s = this._getOrReturnCtx(t);
      return H(s, {
        code: N.invalid_type,
        expected: G.null,
        received: s.parsedType
      }), it;
    }
    return Ie(t.data);
  }
}
So.create = (n) => new So({
  typeName: Q.ZodNull,
  ...at(n)
});
class ar extends dt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Ie(t.data);
  }
}
ar.create = (n) => new ar({
  typeName: Q.ZodAny,
  ...at(n)
});
class Zn extends dt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Ie(t.data);
  }
}
Zn.create = (n) => new Zn({
  typeName: Q.ZodUnknown,
  ...at(n)
});
class Ys extends dt {
  _parse(t) {
    const e = this._getOrReturnCtx(t);
    return H(e, {
      code: N.invalid_type,
      expected: G.never,
      received: e.parsedType
    }), it;
  }
}
Ys.create = (n) => new Ys({
  typeName: Q.ZodNever,
  ...at(n)
});
class sc extends dt {
  _parse(t) {
    if (this._getType(t) !== G.undefined) {
      const s = this._getOrReturnCtx(t);
      return H(s, {
        code: N.invalid_type,
        expected: G.void,
        received: s.parsedType
      }), it;
    }
    return Ie(t.data);
  }
}
sc.create = (n) => new sc({
  typeName: Q.ZodVoid,
  ...at(n)
});
class ns extends dt {
  _parse(t) {
    const { ctx: e, status: s } = this._processInputParams(t), i = this._def;
    if (e.parsedType !== G.array)
      return H(e, {
        code: N.invalid_type,
        expected: G.array,
        received: e.parsedType
      }), it;
    if (i.exactLength !== null) {
      const o = e.data.length > i.exactLength.value, a = e.data.length < i.exactLength.value;
      (o || a) && (H(e, {
        code: o ? N.too_big : N.too_small,
        minimum: a ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), s.dirty());
    }
    if (i.minLength !== null && e.data.length < i.minLength.value && (H(e, {
      code: N.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), s.dirty()), i.maxLength !== null && e.data.length > i.maxLength.value && (H(e, {
      code: N.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), s.dirty()), e.common.async)
      return Promise.all([...e.data].map((o, a) => i.type._parseAsync(new xs(e, o, e.path, a)))).then((o) => we.mergeArray(s, o));
    const r = [...e.data].map((o, a) => i.type._parseSync(new xs(e, o, e.path, a)));
    return we.mergeArray(s, r);
  }
  get element() {
    return this._def.type;
  }
  min(t, e) {
    return new ns({
      ...this._def,
      minLength: { value: t, message: Y.toString(e) }
    });
  }
  max(t, e) {
    return new ns({
      ...this._def,
      maxLength: { value: t, message: Y.toString(e) }
    });
  }
  length(t, e) {
    return new ns({
      ...this._def,
      exactLength: { value: t, message: Y.toString(e) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ns.create = (n, t) => new ns({
  type: n,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Q.ZodArray,
  ...at(t)
});
function Ni(n) {
  if (n instanceof Ut) {
    const t = {};
    for (const e in n.shape) {
      const s = n.shape[e];
      t[e] = Fs.create(Ni(s));
    }
    return new Ut({
      ...n._def,
      shape: () => t
    });
  } else
    return n instanceof ns ? new ns({
      ...n._def,
      type: Ni(n.element)
    }) : n instanceof Fs ? Fs.create(Ni(n.unwrap())) : n instanceof ri ? ri.create(Ni(n.unwrap())) : n instanceof Es ? Es.create(n.items.map((t) => Ni(t))) : n;
}
class Ut extends dt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), e = yt.objectKeys(t);
    return this._cached = { shape: t, keys: e };
  }
  _parse(t) {
    if (this._getType(t) !== G.object) {
      const l = this._getOrReturnCtx(t);
      return H(l, {
        code: N.invalid_type,
        expected: G.object,
        received: l.parsedType
      }), it;
    }
    const { status: s, ctx: i } = this._processInputParams(t), { shape: r, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof Ys && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        o.includes(l) || a.push(l);
    const c = [];
    for (const l of o) {
      const h = r[l], d = i.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: h._parse(new xs(i, d, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof Ys) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const h of a)
          c.push({
            key: { status: "valid", value: h },
            value: { status: "valid", value: i.data[h] }
          });
      else if (l === "strict")
        a.length > 0 && (H(i, {
          code: N.unrecognized_keys,
          keys: a
        }), s.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const h of a) {
        const d = i.data[h];
        c.push({
          key: { status: "valid", value: h },
          value: l._parse(
            new xs(i, d, i.path, h)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: h in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const h of c) {
        const d = await h.key;
        l.push({
          key: d,
          value: await h.value,
          alwaysSet: h.alwaysSet
        });
      }
      return l;
    }).then((l) => we.mergeObjectSync(s, l)) : we.mergeObjectSync(s, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Y.errToObj, new Ut({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (e, s) => {
          var i, r, o, a;
          const c = (o = (r = (i = this._def).errorMap) === null || r === void 0 ? void 0 : r.call(i, e, s).message) !== null && o !== void 0 ? o : s.defaultError;
          return e.code === "unrecognized_keys" ? {
            message: (a = Y.errToObj(t).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ut({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ut({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Ut({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Ut({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Q.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, e) {
    return this.augment({ [t]: e });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Ut({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const e = {};
    return yt.objectKeys(t).forEach((s) => {
      t[s] && this.shape[s] && (e[s] = this.shape[s]);
    }), new Ut({
      ...this._def,
      shape: () => e
    });
  }
  omit(t) {
    const e = {};
    return yt.objectKeys(this.shape).forEach((s) => {
      t[s] || (e[s] = this.shape[s]);
    }), new Ut({
      ...this._def,
      shape: () => e
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ni(this);
  }
  partial(t) {
    const e = {};
    return yt.objectKeys(this.shape).forEach((s) => {
      const i = this.shape[s];
      t && !t[s] ? e[s] = i : e[s] = i.optional();
    }), new Ut({
      ...this._def,
      shape: () => e
    });
  }
  required(t) {
    const e = {};
    return yt.objectKeys(this.shape).forEach((s) => {
      if (t && !t[s])
        e[s] = this.shape[s];
      else {
        let r = this.shape[s];
        for (; r instanceof Fs; )
          r = r._def.innerType;
        e[s] = r;
      }
    }), new Ut({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return Wg(yt.objectKeys(this.shape));
  }
}
Ut.create = (n, t) => new Ut({
  shape: () => n,
  unknownKeys: "strip",
  catchall: Ys.create(),
  typeName: Q.ZodObject,
  ...at(t)
});
Ut.strictCreate = (n, t) => new Ut({
  shape: () => n,
  unknownKeys: "strict",
  catchall: Ys.create(),
  typeName: Q.ZodObject,
  ...at(t)
});
Ut.lazycreate = (n, t) => new Ut({
  shape: n,
  unknownKeys: "strip",
  catchall: Ys.create(),
  typeName: Q.ZodObject,
  ...at(t)
});
class Co extends dt {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t), s = this._def.options;
    function i(r) {
      for (const a of r)
        if (a.result.status === "valid")
          return a.result;
      for (const a of r)
        if (a.result.status === "dirty")
          return e.common.issues.push(...a.ctx.common.issues), a.result;
      const o = r.map((a) => new ss(a.ctx.common.issues));
      return H(e, {
        code: N.invalid_union,
        unionErrors: o
      }), it;
    }
    if (e.common.async)
      return Promise.all(s.map(async (r) => {
        const o = {
          ...e,
          common: {
            ...e.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await r._parseAsync({
            data: e.data,
            path: e.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let r;
      const o = [];
      for (const c of s) {
        const l = {
          ...e,
          common: {
            ...e.common,
            issues: []
          },
          parent: null
        }, h = c._parseSync({
          data: e.data,
          path: e.path,
          parent: l
        });
        if (h.status === "valid")
          return h;
        h.status === "dirty" && !r && (r = { result: h, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (r)
        return e.common.issues.push(...r.ctx.common.issues), r.result;
      const a = o.map((c) => new ss(c));
      return H(e, {
        code: N.invalid_union,
        unionErrors: a
      }), it;
    }
  }
  get options() {
    return this._def.options;
  }
}
Co.create = (n, t) => new Co({
  options: n,
  typeName: Q.ZodUnion,
  ...at(t)
});
const Ra = (n) => n instanceof Eo ? Ra(n.schema) : n instanceof ls ? Ra(n.innerType()) : n instanceof To ? [n.value] : n instanceof bn ? n.options : n instanceof Ao ? Object.keys(n.enum) : n instanceof Io ? Ra(n._def.innerType) : n instanceof wo ? [void 0] : n instanceof So ? [null] : null;
class Wc extends dt {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== G.object)
      return H(e, {
        code: N.invalid_type,
        expected: G.object,
        received: e.parsedType
      }), it;
    const s = this.discriminator, i = e.data[s], r = this.optionsMap.get(i);
    return r ? e.common.async ? r._parseAsync({
      data: e.data,
      path: e.path,
      parent: e
    }) : r._parseSync({
      data: e.data,
      path: e.path,
      parent: e
    }) : (H(e, {
      code: N.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [s]
    }), it);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, e, s) {
    const i = /* @__PURE__ */ new Map();
    for (const r of e) {
      const o = Ra(r.shape[t]);
      if (!o)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (i.has(a))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
        i.set(a, r);
      }
    }
    return new Wc({
      typeName: Q.ZodDiscriminatedUnion,
      discriminator: t,
      options: e,
      optionsMap: i,
      ...at(s)
    });
  }
}
function od(n, t) {
  const e = ln(n), s = ln(t);
  if (n === t)
    return { valid: !0, data: n };
  if (e === G.object && s === G.object) {
    const i = yt.objectKeys(t), r = yt.objectKeys(n).filter((a) => i.indexOf(a) !== -1), o = { ...n, ...t };
    for (const a of r) {
      const c = od(n[a], t[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (e === G.array && s === G.array) {
    if (n.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let r = 0; r < n.length; r++) {
      const o = n[r], a = t[r], c = od(o, a);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return e === G.date && s === G.date && +n == +t ? { valid: !0, data: n } : { valid: !1 };
}
class ko extends dt {
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t), i = (r, o) => {
      if (id(r) || id(o))
        return it;
      const a = od(r.value, o.value);
      return a.valid ? ((rd(r) || rd(o)) && e.dirty(), { status: e.value, value: a.data }) : (H(s, {
        code: N.invalid_intersection_types
      }), it);
    };
    return s.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      }),
      this._def.right._parseAsync({
        data: s.data,
        path: s.path,
        parent: s
      })
    ]).then(([r, o]) => i(r, o)) : i(this._def.left._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }), this._def.right._parseSync({
      data: s.data,
      path: s.path,
      parent: s
    }));
  }
}
ko.create = (n, t, e) => new ko({
  left: n,
  right: t,
  typeName: Q.ZodIntersection,
  ...at(e)
});
class Es extends dt {
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== G.array)
      return H(s, {
        code: N.invalid_type,
        expected: G.array,
        received: s.parsedType
      }), it;
    if (s.data.length < this._def.items.length)
      return H(s, {
        code: N.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), it;
    !this._def.rest && s.data.length > this._def.items.length && (H(s, {
      code: N.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), e.dirty());
    const r = [...s.data].map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new xs(s, o, s.path, a)) : null;
    }).filter((o) => !!o);
    return s.common.async ? Promise.all(r).then((o) => we.mergeArray(e, o)) : we.mergeArray(e, r);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Es({
      ...this._def,
      rest: t
    });
  }
}
Es.create = (n, t) => {
  if (!Array.isArray(n))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Es({
    items: n,
    typeName: Q.ZodTuple,
    rest: null,
    ...at(t)
  });
};
class xo extends dt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== G.object)
      return H(s, {
        code: N.invalid_type,
        expected: G.object,
        received: s.parsedType
      }), it;
    const i = [], r = this._def.keyType, o = this._def.valueType;
    for (const a in s.data)
      i.push({
        key: r._parse(new xs(s, a, s.path, a)),
        value: o._parse(new xs(s, s.data[a], s.path, a))
      });
    return s.common.async ? we.mergeObjectAsync(e, i) : we.mergeObjectSync(e, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, e, s) {
    return e instanceof dt ? new xo({
      keyType: t,
      valueType: e,
      typeName: Q.ZodRecord,
      ...at(s)
    }) : new xo({
      keyType: es.create(),
      valueType: t,
      typeName: Q.ZodRecord,
      ...at(e)
    });
  }
}
class nc extends dt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== G.map)
      return H(s, {
        code: N.invalid_type,
        expected: G.map,
        received: s.parsedType
      }), it;
    const i = this._def.keyType, r = this._def.valueType, o = [...s.data.entries()].map(([a, c], l) => ({
      key: i._parse(new xs(s, a, s.path, [l, "key"])),
      value: r._parse(new xs(s, c, s.path, [l, "value"]))
    }));
    if (s.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const l = await c.key, h = await c.value;
          if (l.status === "aborted" || h.status === "aborted")
            return it;
          (l.status === "dirty" || h.status === "dirty") && e.dirty(), a.set(l.value, h.value);
        }
        return { status: e.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const l = c.key, h = c.value;
        if (l.status === "aborted" || h.status === "aborted")
          return it;
        (l.status === "dirty" || h.status === "dirty") && e.dirty(), a.set(l.value, h.value);
      }
      return { status: e.value, value: a };
    }
  }
}
nc.create = (n, t, e) => new nc({
  valueType: t,
  keyType: n,
  typeName: Q.ZodMap,
  ...at(e)
});
class ii extends dt {
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t);
    if (s.parsedType !== G.set)
      return H(s, {
        code: N.invalid_type,
        expected: G.set,
        received: s.parsedType
      }), it;
    const i = this._def;
    i.minSize !== null && s.data.size < i.minSize.value && (H(s, {
      code: N.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), e.dirty()), i.maxSize !== null && s.data.size > i.maxSize.value && (H(s, {
      code: N.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), e.dirty());
    const r = this._def.valueType;
    function o(c) {
      const l = /* @__PURE__ */ new Set();
      for (const h of c) {
        if (h.status === "aborted")
          return it;
        h.status === "dirty" && e.dirty(), l.add(h.value);
      }
      return { status: e.value, value: l };
    }
    const a = [...s.data.values()].map((c, l) => r._parse(new xs(s, c, s.path, l)));
    return s.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(t, e) {
    return new ii({
      ...this._def,
      minSize: { value: t, message: Y.toString(e) }
    });
  }
  max(t, e) {
    return new ii({
      ...this._def,
      maxSize: { value: t, message: Y.toString(e) }
    });
  }
  size(t, e) {
    return this.min(t, e).max(t, e);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ii.create = (n, t) => new ii({
  valueType: n,
  minSize: null,
  maxSize: null,
  typeName: Q.ZodSet,
  ...at(t)
});
class Zi extends dt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== G.function)
      return H(e, {
        code: N.invalid_type,
        expected: G.function,
        received: e.parsedType
      }), it;
    function s(a, c) {
      return Qa({
        data: a,
        path: e.path,
        errorMaps: [
          e.common.contextualErrorMap,
          e.schemaErrorMap,
          Ja(),
          yo
        ].filter((l) => !!l),
        issueData: {
          code: N.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(a, c) {
      return Qa({
        data: a,
        path: e.path,
        errorMaps: [
          e.common.contextualErrorMap,
          e.schemaErrorMap,
          Ja(),
          yo
        ].filter((l) => !!l),
        issueData: {
          code: N.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const r = { errorMap: e.common.contextualErrorMap }, o = e.data;
    if (this._def.returns instanceof cr) {
      const a = this;
      return Ie(async function(...c) {
        const l = new ss([]), h = await a._def.args.parseAsync(c, r).catch((f) => {
          throw l.addIssue(s(c, f)), l;
        }), d = await Reflect.apply(o, this, h);
        return await a._def.returns._def.type.parseAsync(d, r).catch((f) => {
          throw l.addIssue(i(d, f)), l;
        });
      });
    } else {
      const a = this;
      return Ie(function(...c) {
        const l = a._def.args.safeParse(c, r);
        if (!l.success)
          throw new ss([s(c, l.error)]);
        const h = Reflect.apply(o, this, l.data), d = a._def.returns.safeParse(h, r);
        if (!d.success)
          throw new ss([i(h, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Zi({
      ...this._def,
      args: Es.create(t).rest(Zn.create())
    });
  }
  returns(t) {
    return new Zi({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, e, s) {
    return new Zi({
      args: t || Es.create([]).rest(Zn.create()),
      returns: e || Zn.create(),
      typeName: Q.ZodFunction,
      ...at(s)
    });
  }
}
class Eo extends dt {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    return this._def.getter()._parse({ data: e.data, path: e.path, parent: e });
  }
}
Eo.create = (n, t) => new Eo({
  getter: n,
  typeName: Q.ZodLazy,
  ...at(t)
});
class To extends dt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const e = this._getOrReturnCtx(t);
      return H(e, {
        received: e.data,
        code: N.invalid_literal,
        expected: this._def.value
      }), it;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
To.create = (n, t) => new To({
  value: n,
  typeName: Q.ZodLiteral,
  ...at(t)
});
function Wg(n, t) {
  return new bn({
    values: n,
    typeName: Q.ZodEnum,
    ...at(t)
  });
}
class bn extends dt {
  _parse(t) {
    if (typeof t.data != "string") {
      const e = this._getOrReturnCtx(t), s = this._def.values;
      return H(e, {
        expected: yt.joinValues(s),
        received: e.parsedType,
        code: N.invalid_type
      }), it;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const e = this._getOrReturnCtx(t), s = this._def.values;
      return H(e, {
        received: e.data,
        code: N.invalid_enum_value,
        options: s
      }), it;
    }
    return Ie(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const e of this._def.values)
      t[e] = e;
    return t;
  }
  get Values() {
    const t = {};
    for (const e of this._def.values)
      t[e] = e;
    return t;
  }
  get Enum() {
    const t = {};
    for (const e of this._def.values)
      t[e] = e;
    return t;
  }
  extract(t) {
    return bn.create(t);
  }
  exclude(t) {
    return bn.create(this.options.filter((e) => !t.includes(e)));
  }
}
bn.create = Wg;
class Ao extends dt {
  _parse(t) {
    const e = yt.getValidEnumValues(this._def.values), s = this._getOrReturnCtx(t);
    if (s.parsedType !== G.string && s.parsedType !== G.number) {
      const i = yt.objectValues(e);
      return H(s, {
        expected: yt.joinValues(i),
        received: s.parsedType,
        code: N.invalid_type
      }), it;
    }
    if (e.indexOf(t.data) === -1) {
      const i = yt.objectValues(e);
      return H(s, {
        received: s.data,
        code: N.invalid_enum_value,
        options: i
      }), it;
    }
    return Ie(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Ao.create = (n, t) => new Ao({
  values: n,
  typeName: Q.ZodNativeEnum,
  ...at(t)
});
class cr extends dt {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== G.promise && e.common.async === !1)
      return H(e, {
        code: N.invalid_type,
        expected: G.promise,
        received: e.parsedType
      }), it;
    const s = e.parsedType === G.promise ? e.data : Promise.resolve(e.data);
    return Ie(s.then((i) => this._def.type.parseAsync(i, {
      path: e.path,
      errorMap: e.common.contextualErrorMap
    })));
  }
}
cr.create = (n, t) => new cr({
  type: n,
  typeName: Q.ZodPromise,
  ...at(t)
});
class ls extends dt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Q.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t), i = this._def.effect || null, r = {
      addIssue: (o) => {
        H(s, o), o.fatal ? e.abort() : e.dirty();
      },
      get path() {
        return s.path;
      }
    };
    if (r.addIssue = r.addIssue.bind(r), i.type === "preprocess") {
      const o = i.transform(s.data, r);
      return s.common.issues.length ? {
        status: "dirty",
        value: s.data
      } : s.common.async ? Promise.resolve(o).then((a) => this._def.schema._parseAsync({
        data: a,
        path: s.path,
        parent: s
      })) : this._def.schema._parseSync({
        data: o,
        path: s.path,
        parent: s
      });
    }
    if (i.type === "refinement") {
      const o = (a) => {
        const c = i.refinement(a, r);
        if (s.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (s.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return a.status === "aborted" ? it : (a.status === "dirty" && e.dirty(), o(a.value), { status: e.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((a) => a.status === "aborted" ? it : (a.status === "dirty" && e.dirty(), o(a.value).then(() => ({ status: e.value, value: a.value }))));
    }
    if (i.type === "transform")
      if (s.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: s.data,
          path: s.path,
          parent: s
        });
        if (!vo(o))
          return o;
        const a = i.transform(o.value, r);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: e.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: s.data, path: s.path, parent: s }).then((o) => vo(o) ? Promise.resolve(i.transform(o.value, r)).then((a) => ({ status: e.value, value: a })) : o);
    yt.assertNever(i);
  }
}
ls.create = (n, t, e) => new ls({
  schema: n,
  typeName: Q.ZodEffects,
  effect: t,
  ...at(e)
});
ls.createWithPreprocess = (n, t, e) => new ls({
  schema: t,
  effect: { type: "preprocess", transform: n },
  typeName: Q.ZodEffects,
  ...at(e)
});
class Fs extends dt {
  _parse(t) {
    return this._getType(t) === G.undefined ? Ie(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Fs.create = (n, t) => new Fs({
  innerType: n,
  typeName: Q.ZodOptional,
  ...at(t)
});
class ri extends dt {
  _parse(t) {
    return this._getType(t) === G.null ? Ie(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ri.create = (n, t) => new ri({
  innerType: n,
  typeName: Q.ZodNullable,
  ...at(t)
});
class Io extends dt {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    let s = e.data;
    return e.parsedType === G.undefined && (s = this._def.defaultValue()), this._def.innerType._parse({
      data: s,
      path: e.path,
      parent: e
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Io.create = (n, t) => new Io({
  innerType: n,
  typeName: Q.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...at(t)
});
class ic extends dt {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t), s = {
      ...e,
      common: {
        ...e.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: s.data,
      path: s.path,
      parent: {
        ...s
      }
    });
    return tc(i) ? i.then((r) => ({
      status: "valid",
      value: r.status === "valid" ? r.value : this._def.catchValue({
        get error() {
          return new ss(s.common.issues);
        },
        input: s.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new ss(s.common.issues);
        },
        input: s.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ic.create = (n, t) => new ic({
  innerType: n,
  typeName: Q.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...at(t)
});
class rc extends dt {
  _parse(t) {
    if (this._getType(t) !== G.nan) {
      const s = this._getOrReturnCtx(t);
      return H(s, {
        code: N.invalid_type,
        expected: G.nan,
        received: s.parsedType
      }), it;
    }
    return { status: "valid", value: t.data };
  }
}
rc.create = (n) => new rc({
  typeName: Q.ZodNaN,
  ...at(n)
});
const w3 = Symbol("zod_brand");
class Kg extends dt {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t), s = e.data;
    return this._def.type._parse({
      data: s,
      path: e.path,
      parent: e
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Xo extends dt {
  _parse(t) {
    const { status: e, ctx: s } = this._processInputParams(t);
    if (s.common.async)
      return (async () => {
        const r = await this._def.in._parseAsync({
          data: s.data,
          path: s.path,
          parent: s
        });
        return r.status === "aborted" ? it : r.status === "dirty" ? (e.dirty(), zg(r.value)) : this._def.out._parseAsync({
          data: r.value,
          path: s.path,
          parent: s
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: s.data,
        path: s.path,
        parent: s
      });
      return i.status === "aborted" ? it : i.status === "dirty" ? (e.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: s.path,
        parent: s
      });
    }
  }
  static create(t, e) {
    return new Xo({
      in: t,
      out: e,
      typeName: Q.ZodPipeline
    });
  }
}
class oc extends dt {
  _parse(t) {
    const e = this._def.innerType._parse(t);
    return vo(e) && (e.value = Object.freeze(e.value)), e;
  }
}
oc.create = (n, t) => new oc({
  innerType: n,
  typeName: Q.ZodReadonly,
  ...at(t)
});
const Yg = (n, t = {}, e) => n ? ar.create().superRefine((s, i) => {
  var r, o;
  if (!n(s)) {
    const a = typeof t == "function" ? t(s) : typeof t == "string" ? { message: t } : t, c = (o = (r = a.fatal) !== null && r !== void 0 ? r : e) !== null && o !== void 0 ? o : !0, l = typeof a == "string" ? { message: a } : a;
    i.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : ar.create(), S3 = {
  object: Ut.lazycreate
};
var Q;
(function(n) {
  n.ZodString = "ZodString", n.ZodNumber = "ZodNumber", n.ZodNaN = "ZodNaN", n.ZodBigInt = "ZodBigInt", n.ZodBoolean = "ZodBoolean", n.ZodDate = "ZodDate", n.ZodSymbol = "ZodSymbol", n.ZodUndefined = "ZodUndefined", n.ZodNull = "ZodNull", n.ZodAny = "ZodAny", n.ZodUnknown = "ZodUnknown", n.ZodNever = "ZodNever", n.ZodVoid = "ZodVoid", n.ZodArray = "ZodArray", n.ZodObject = "ZodObject", n.ZodUnion = "ZodUnion", n.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", n.ZodIntersection = "ZodIntersection", n.ZodTuple = "ZodTuple", n.ZodRecord = "ZodRecord", n.ZodMap = "ZodMap", n.ZodSet = "ZodSet", n.ZodFunction = "ZodFunction", n.ZodLazy = "ZodLazy", n.ZodLiteral = "ZodLiteral", n.ZodEnum = "ZodEnum", n.ZodEffects = "ZodEffects", n.ZodNativeEnum = "ZodNativeEnum", n.ZodOptional = "ZodOptional", n.ZodNullable = "ZodNullable", n.ZodDefault = "ZodDefault", n.ZodCatch = "ZodCatch", n.ZodPromise = "ZodPromise", n.ZodBranded = "ZodBranded", n.ZodPipeline = "ZodPipeline", n.ZodReadonly = "ZodReadonly";
})(Q || (Q = {}));
const C3 = (n, t = {
  message: `Input not instance of ${n.name}`
}) => Yg((e) => e instanceof n, t), Zg = es.create, qg = yn.create, k3 = rc.create, x3 = vn.create, Xg = bo.create, E3 = ni.create, T3 = ec.create, A3 = wo.create, I3 = So.create, O3 = ar.create, D3 = Zn.create, P3 = Ys.create, M3 = sc.create, R3 = ns.create, $3 = Ut.create, N3 = Ut.strictCreate, L3 = Co.create, U3 = Wc.create, F3 = ko.create, B3 = Es.create, V3 = xo.create, j3 = nc.create, G3 = ii.create, H3 = Zi.create, z3 = Eo.create, W3 = To.create, K3 = bn.create, Y3 = Ao.create, Z3 = cr.create, Sp = ls.create, q3 = Fs.create, X3 = ri.create, J3 = ls.createWithPreprocess, Q3 = Xo.create, t6 = () => Zg().optional(), e6 = () => qg().optional(), s6 = () => Xg().optional(), n6 = {
  string: (n) => es.create({ ...n, coerce: !0 }),
  number: (n) => yn.create({ ...n, coerce: !0 }),
  boolean: (n) => bo.create({
    ...n,
    coerce: !0
  }),
  bigint: (n) => vn.create({ ...n, coerce: !0 }),
  date: (n) => ni.create({ ...n, coerce: !0 })
}, i6 = it;
var U = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: yo,
  setErrorMap: c3,
  getErrorMap: Ja,
  makeIssue: Qa,
  EMPTY_PATH: l3,
  addIssueToContext: H,
  ParseStatus: we,
  INVALID: it,
  DIRTY: zg,
  OK: Ie,
  isAborted: id,
  isDirty: rd,
  isValid: vo,
  isAsync: tc,
  get util() {
    return yt;
  },
  get objectUtil() {
    return nd;
  },
  ZodParsedType: G,
  getParsedType: ln,
  ZodType: dt,
  ZodString: es,
  ZodNumber: yn,
  ZodBigInt: vn,
  ZodBoolean: bo,
  ZodDate: ni,
  ZodSymbol: ec,
  ZodUndefined: wo,
  ZodNull: So,
  ZodAny: ar,
  ZodUnknown: Zn,
  ZodNever: Ys,
  ZodVoid: sc,
  ZodArray: ns,
  ZodObject: Ut,
  ZodUnion: Co,
  ZodDiscriminatedUnion: Wc,
  ZodIntersection: ko,
  ZodTuple: Es,
  ZodRecord: xo,
  ZodMap: nc,
  ZodSet: ii,
  ZodFunction: Zi,
  ZodLazy: Eo,
  ZodLiteral: To,
  ZodEnum: bn,
  ZodNativeEnum: Ao,
  ZodPromise: cr,
  ZodEffects: ls,
  ZodTransformer: ls,
  ZodOptional: Fs,
  ZodNullable: ri,
  ZodDefault: Io,
  ZodCatch: ic,
  ZodNaN: rc,
  BRAND: w3,
  ZodBranded: Kg,
  ZodPipeline: Xo,
  ZodReadonly: oc,
  custom: Yg,
  Schema: dt,
  ZodSchema: dt,
  late: S3,
  get ZodFirstPartyTypeKind() {
    return Q;
  },
  coerce: n6,
  any: O3,
  array: R3,
  bigint: x3,
  boolean: Xg,
  date: E3,
  discriminatedUnion: U3,
  effect: Sp,
  enum: K3,
  function: H3,
  instanceof: C3,
  intersection: F3,
  lazy: z3,
  literal: W3,
  map: j3,
  nan: k3,
  nativeEnum: Y3,
  never: P3,
  null: I3,
  nullable: X3,
  number: qg,
  object: $3,
  oboolean: s6,
  onumber: e6,
  optional: q3,
  ostring: t6,
  pipeline: Q3,
  preprocess: J3,
  promise: Z3,
  record: V3,
  set: G3,
  strictObject: N3,
  string: Zg,
  symbol: T3,
  transformer: Sp,
  tuple: B3,
  undefined: A3,
  union: L3,
  unknown: D3,
  void: M3,
  NEVER: i6,
  ZodIssueCode: N,
  quotelessJson: a3,
  ZodError: ss
}), Cp;
const r6 = U.string(), o6 = U.array(U.string()).optional(), a6 = U.array(U.string()).optional(), c6 = ["root", "hub", "content"], l6 = U.enum(c6), Kc = Object.freeze({
  Text: (n = "") => new vr(n),
  Boxed: (n) => new ks(n)
}), Jg = U.object({
  version: U.number(),
  model: U.object({
    role: l6,
    flavour: r6,
    parent: o6,
    children: a6,
    props: U.function().args(U.custom()).returns(U.record(U.any())).optional(),
    toModel: U.function().args().returns(U.custom()).optional()
  }),
  transformer: U.function().args().returns(U.custom()).optional(),
  onUpgrade: U.function().args(U.any(), U.number(), U.number()).returns(U.void()).optional()
});
function h6({ flavour: n, props: t, metadata: e, onUpgrade: s, toModel: i, transformer: r }) {
  const o = {
    version: e.version,
    model: {
      role: e.role,
      parent: e.parent,
      children: e.children,
      flavour: n,
      props: t,
      toModel: i
    },
    onUpgrade: s,
    transformer: r
  };
  return Jg.parse(o), o;
}
function d6() {
  return class {
  };
}
const u6 = Symbol("model_label");
class Nu extends d6() {
  constructor() {
    super(...arguments), this[Cp] = "type_info_label", this.created = new lt(), this.deleted = new lt(), this.propsUpdated = new lt(), this.childrenUpdated = new lt();
  }
  get doc() {
    return this.page;
  }
  set doc(t) {
    this.page = t;
  }
  get childMap() {
    return this.children.reduce((t, e, s) => (t.set(e.id, s), t), /* @__PURE__ */ new Map());
  }
  get children() {
    const t = this.yBlock.get("sys:children");
    if (!t)
      return [];
    const e = [];
    return t.forEach((s) => {
      const i = this.doc.getBlockById(s);
      i && e.push(i);
    }), e;
  }
  isEmpty() {
    return this.children.length === 0;
  }
  firstChild() {
    return this.children[0] || null;
  }
  lastChild() {
    return this.children.length ? this.children[this.children.length - 1].lastChild() : this;
  }
  dispose() {
    this.created.dispose(), this.deleted.dispose(), this.propsUpdated.dispose(), this.childrenUpdated.dispose();
  }
}
Cp = u6;
var f6 = Qg;
function Qg(n, t, e) {
  n instanceof RegExp && (n = kp(n, e)), t instanceof RegExp && (t = kp(t, e));
  var s = t2(n, t, e);
  return s && {
    start: s[0],
    end: s[1],
    pre: e.slice(0, s[0]),
    body: e.slice(s[0] + n.length, s[1]),
    post: e.slice(s[1] + t.length)
  };
}
function kp(n, t) {
  var e = t.match(n);
  return e ? e[0] : null;
}
Qg.range = t2;
function t2(n, t, e) {
  var s, i, r, o, a, c = e.indexOf(n), l = e.indexOf(t, c + 1), h = c;
  if (c >= 0 && l > 0) {
    if (n === t)
      return [c, l];
    for (s = [], r = e.length; h >= 0 && !a; )
      h == c ? (s.push(h), c = e.indexOf(n, h + 1)) : s.length == 1 ? a = [s.pop(), l] : (i = s.pop(), i < r && (r = i, o = l), l = e.indexOf(t, h + 1)), h = c < l && c >= 0 ? c : l;
    s.length && (a = [r, o]);
  }
  return a;
}
var e2 = f6, p6 = _6, s2 = "\0SLASH" + Math.random() + "\0", n2 = "\0OPEN" + Math.random() + "\0", Lu = "\0CLOSE" + Math.random() + "\0", i2 = "\0COMMA" + Math.random() + "\0", r2 = "\0PERIOD" + Math.random() + "\0";
function fh(n) {
  return parseInt(n, 10) == n ? parseInt(n, 10) : n.charCodeAt(0);
}
function g6(n) {
  return n.split("\\\\").join(s2).split("\\{").join(n2).split("\\}").join(Lu).split("\\,").join(i2).split("\\.").join(r2);
}
function m6(n) {
  return n.split(s2).join("\\").split(n2).join("{").split(Lu).join("}").split(i2).join(",").split(r2).join(".");
}
function o2(n) {
  if (!n)
    return [""];
  var t = [], e = e2("{", "}", n);
  if (!e)
    return n.split(",");
  var s = e.pre, i = e.body, r = e.post, o = s.split(",");
  o[o.length - 1] += "{" + i + "}";
  var a = o2(r);
  return r.length && (o[o.length - 1] += a.shift(), o.push.apply(o, a)), t.push.apply(t, o), t;
}
function _6(n) {
  return n ? (n.substr(0, 2) === "{}" && (n = "\\{\\}" + n.substr(2)), Gr(g6(n), !0).map(m6)) : [];
}
function y6(n) {
  return "{" + n + "}";
}
function v6(n) {
  return /^-?0\d/.test(n);
}
function b6(n, t) {
  return n <= t;
}
function w6(n, t) {
  return n >= t;
}
function Gr(n, t) {
  var e = [], s = e2("{", "}", n);
  if (!s)
    return [n];
  var i = s.pre, r = s.post.length ? Gr(s.post, !1) : [""];
  if (/\$$/.test(s.pre))
    for (var o = 0; o < r.length; o++) {
      var a = i + "{" + s.body + "}" + r[o];
      e.push(a);
    }
  else {
    var c = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(s.body), l = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(s.body), h = c || l, d = s.body.indexOf(",") >= 0;
    if (!h && !d)
      return s.post.match(/,.*\}/) ? (n = s.pre + "{" + s.body + Lu + s.post, Gr(n)) : [n];
    var u;
    if (h)
      u = s.body.split(/\.\./);
    else if (u = o2(s.body), u.length === 1 && (u = Gr(u[0], !1).map(y6), u.length === 1))
      return r.map(function(E) {
        return s.pre + u[0] + E;
      });
    var f;
    if (h) {
      var p = fh(u[0]), m = fh(u[1]), _ = Math.max(u[0].length, u[1].length), v = u.length == 3 ? Math.abs(fh(u[2])) : 1, b = b6, g = m < p;
      g && (v *= -1, b = w6);
      var y = u.some(v6);
      f = [];
      for (var S = p; b(S, m); S += v) {
        var w;
        if (l)
          w = String.fromCharCode(S), w === "\\" && (w = "");
        else if (w = String(S), y) {
          var k = _ - w.length;
          if (k > 0) {
            var C = new Array(k + 1).join("0");
            S < 0 ? w = "-" + C + w.slice(1) : w = C + w;
          }
        }
        f.push(w);
      }
    } else {
      f = [];
      for (var A = 0; A < u.length; A++)
        f.push.apply(f, Gr(u[A], !1));
    }
    for (var A = 0; A < f.length; A++)
      for (var o = 0; o < r.length; o++) {
        var a = i + f[A] + r[o];
        (!t || h || a) && e.push(a);
      }
  }
  return e;
}
const S6 = /* @__PURE__ */ ou(p6), C6 = 1024 * 64, ac = (n) => {
  if (typeof n != "string")
    throw new TypeError("invalid pattern");
  if (n.length > C6)
    throw new TypeError("pattern is too long");
}, k6 = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, Pr = (n) => n.replace(/[[\]\\-]/g, "\\$&"), x6 = (n) => n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), xp = (n) => n.join(""), E6 = (n, t) => {
  const e = t;
  if (n.charAt(e) !== "[")
    throw new Error("not in a brace expression");
  const s = [], i = [];
  let r = e + 1, o = !1, a = !1, c = !1, l = !1, h = e, d = "";
  t:
    for (; r < n.length; ) {
      const m = n.charAt(r);
      if ((m === "!" || m === "^") && r === e + 1) {
        l = !0, r++;
        continue;
      }
      if (m === "]" && o && !c) {
        h = r + 1;
        break;
      }
      if (o = !0, m === "\\" && !c) {
        c = !0, r++;
        continue;
      }
      if (m === "[" && !c) {
        for (const [_, [v, b, g]] of Object.entries(k6))
          if (n.startsWith(_, r)) {
            if (d)
              return ["$.", !1, n.length - e, !0];
            r += _.length, g ? i.push(v) : s.push(v), a = a || b;
            continue t;
          }
      }
      if (c = !1, d) {
        m > d ? s.push(Pr(d) + "-" + Pr(m)) : m === d && s.push(Pr(m)), d = "", r++;
        continue;
      }
      if (n.startsWith("-]", r + 1)) {
        s.push(Pr(m + "-")), r += 2;
        continue;
      }
      if (n.startsWith("-", r + 1)) {
        d = m, r += 2;
        continue;
      }
      s.push(Pr(m)), r++;
    }
  if (h < r)
    return ["", !1, 0, !1];
  if (!s.length && !i.length)
    return ["$.", !1, n.length - e, !0];
  if (i.length === 0 && s.length === 1 && /^\\?.$/.test(s[0]) && !l) {
    const m = s[0].length === 2 ? s[0].slice(-1) : s[0];
    return [x6(m), !1, h - e, !1];
  }
  const u = "[" + (l ? "^" : "") + xp(s) + "]", f = "[" + (l ? "" : "^") + xp(i) + "]";
  return [s.length && i.length ? "(" + u + "|" + f + ")" : s.length ? u : f, a, h - e, !0];
}, Hr = (n, { windowsPathsNoEscape: t = !1 } = {}) => t ? n.replace(/\[([^\/\\])\]/g, "$1") : n.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), T6 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), Ep = (n) => T6.has(n), A6 = "(?!(?:^|/)\\.\\.?(?:$|/))", ua = "(?!\\.)", I6 = /* @__PURE__ */ new Set(["[", "."]), O6 = /* @__PURE__ */ new Set(["..", "."]), D6 = new Set("().*{}+?[]^$\\!"), P6 = (n) => n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Uu = "[^/]", Tp = Uu + "*?", Ap = Uu + "+?";
var te, ce, Ns, Rt, qt, hn, Gn, dn, ms, Hn, Fo, kc, a2, Qi, $a, Bo, ad, xc, c2;
const ye = class ye {
  constructor(t, e, s = {}) {
    _e(this, kc);
    _e(this, Bo);
    Qt(this, "type");
    _e(this, te, void 0);
    _e(this, ce, void 0);
    _e(this, Ns, !1);
    _e(this, Rt, []);
    _e(this, qt, void 0);
    _e(this, hn, void 0);
    _e(this, Gn, void 0);
    _e(this, dn, !1);
    _e(this, ms, void 0);
    _e(this, Hn, void 0);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    _e(this, Fo, !1);
    this.type = t, t && zt(this, ce, !0), zt(this, qt, e), zt(this, te, L(this, qt) ? L(L(this, qt), te) : this), zt(this, ms, L(this, te) === this ? s : L(L(this, te), ms)), zt(this, Gn, L(this, te) === this ? [] : L(L(this, te), Gn)), t === "!" && !L(L(this, te), dn) && L(this, Gn).push(this), zt(this, hn, L(this, qt) ? L(L(this, qt), Rt).length : 0);
  }
  get hasMagic() {
    if (L(this, ce) !== void 0)
      return L(this, ce);
    for (const t of L(this, Rt))
      if (typeof t != "string" && (t.type || t.hasMagic))
        return zt(this, ce, !0);
    return L(this, ce);
  }
  // reconstructs the pattern
  toString() {
    return L(this, Hn) !== void 0 ? L(this, Hn) : this.type ? zt(this, Hn, this.type + "(" + L(this, Rt).map((t) => String(t)).join("|") + ")") : zt(this, Hn, L(this, Rt).map((t) => String(t)).join(""));
  }
  push(...t) {
    for (const e of t)
      if (e !== "") {
        if (typeof e != "string" && !(e instanceof ye && L(e, qt) === this))
          throw new Error("invalid part: " + e);
        L(this, Rt).push(e);
      }
  }
  toJSON() {
    var e;
    const t = this.type === null ? L(this, Rt).slice().map((s) => typeof s == "string" ? s : s.toJSON()) : [this.type, ...L(this, Rt).map((s) => s.toJSON())];
    return this.isStart() && !this.type && t.unshift([]), this.isEnd() && (this === L(this, te) || L(L(this, te), dn) && ((e = L(this, qt)) == null ? void 0 : e.type) === "!") && t.push({}), t;
  }
  isStart() {
    var e;
    if (L(this, te) === this)
      return !0;
    if (!((e = L(this, qt)) != null && e.isStart()))
      return !1;
    if (L(this, hn) === 0)
      return !0;
    const t = L(this, qt);
    for (let s = 0; s < L(this, hn); s++) {
      const i = L(t, Rt)[s];
      if (!(i instanceof ye && i.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    var e, s, i;
    if (L(this, te) === this || ((e = L(this, qt)) == null ? void 0 : e.type) === "!")
      return !0;
    if (!((s = L(this, qt)) != null && s.isEnd()))
      return !1;
    if (!this.type)
      return (i = L(this, qt)) == null ? void 0 : i.isEnd();
    const t = L(this, qt) ? L(L(this, qt), Rt).length : 0;
    return L(this, hn) === t - 1;
  }
  copyIn(t) {
    typeof t == "string" ? this.push(t) : this.push(t.clone(this));
  }
  clone(t) {
    const e = new ye(this.type, t);
    for (const s of L(this, Rt))
      e.copyIn(s);
    return e;
  }
  static fromGlob(t, e = {}) {
    var i;
    const s = new ye(null, void 0, e);
    return nn(i = ye, Qi, $a).call(i, t, s, 0, e), s;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== L(this, te))
      return L(this, te).toMMPattern();
    const t = this.toString(), [e, s, i, r] = this.toRegExpSource();
    if (!(i || L(this, ce) || L(this, ms).nocase && !L(this, ms).nocaseMagicOnly && t.toUpperCase() !== t.toLowerCase()))
      return s;
    const a = (L(this, ms).nocase ? "i" : "") + (r ? "u" : "");
    return Object.assign(new RegExp(`^${e}$`, a), {
      _src: e,
      _glob: t
    });
  }
  get options() {
    return L(this, ms);
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(t) {
    var c;
    const e = t ?? !!L(this, ms).dot;
    if (L(this, te) === this && nn(this, kc, a2).call(this), !this.type) {
      const l = this.isStart() && this.isEnd(), h = L(this, Rt).map((p) => {
        var g;
        const [m, _, v, b] = typeof p == "string" ? nn(g = ye, xc, c2).call(g, p, L(this, ce), l) : p.toRegExpSource(t);
        return zt(this, ce, L(this, ce) || v), zt(this, Ns, L(this, Ns) || b), m;
      }).join("");
      let d = "";
      if (this.isStart() && typeof L(this, Rt)[0] == "string" && !(L(this, Rt).length === 1 && O6.has(L(this, Rt)[0]))) {
        const m = I6, _ = (
          // dots are allowed, and the pattern starts with [ or .
          e && m.has(h.charAt(0)) || // the pattern starts with \., and then [ or .
          h.startsWith("\\.") && m.has(h.charAt(2)) || // the pattern starts with \.\., and then [ or .
          h.startsWith("\\.\\.") && m.has(h.charAt(4))
        ), v = !e && !t && m.has(h.charAt(0));
        d = _ ? A6 : v ? ua : "";
      }
      let u = "";
      return this.isEnd() && L(L(this, te), dn) && ((c = L(this, qt)) == null ? void 0 : c.type) === "!" && (u = "(?:$|\\/)"), [
        d + h + u,
        Hr(h),
        zt(this, ce, !!L(this, ce)),
        L(this, Ns)
      ];
    }
    const s = this.type === "*" || this.type === "+", i = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let r = nn(this, Bo, ad).call(this, e);
    if (this.isStart() && this.isEnd() && !r && this.type !== "!") {
      const l = this.toString();
      return zt(this, Rt, [l]), this.type = null, zt(this, ce, void 0), [l, Hr(this.toString()), !1, !1];
    }
    let o = !s || t || e || !ua ? "" : nn(this, Bo, ad).call(this, !0);
    o === r && (o = ""), o && (r = `(?:${r})(?:${o})*?`);
    let a = "";
    if (this.type === "!" && L(this, Fo))
      a = (this.isStart() && !e ? ua : "") + Ap;
    else {
      const l = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !e && !t ? ua : "") + Tp + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && o ? ")" : this.type === "*" && o ? ")?" : `)${this.type}`;
      a = i + r + l;
    }
    return [
      a,
      Hr(r),
      zt(this, ce, !!L(this, ce)),
      L(this, Ns)
    ];
  }
};
te = new WeakMap(), ce = new WeakMap(), Ns = new WeakMap(), Rt = new WeakMap(), qt = new WeakMap(), hn = new WeakMap(), Gn = new WeakMap(), dn = new WeakMap(), ms = new WeakMap(), Hn = new WeakMap(), Fo = new WeakMap(), kc = new WeakSet(), a2 = function() {
  if (this !== L(this, te))
    throw new Error("should only call on root");
  if (L(this, dn))
    return this;
  this.toString(), zt(this, dn, !0);
  let t;
  for (; t = L(this, Gn).pop(); ) {
    if (t.type !== "!")
      continue;
    let e = t, s = L(e, qt);
    for (; s; ) {
      for (let i = L(e, hn) + 1; !s.type && i < L(s, Rt).length; i++)
        for (const r of L(t, Rt)) {
          if (typeof r == "string")
            throw new Error("string part in extglob AST??");
          r.copyIn(L(s, Rt)[i]);
        }
      e = s, s = L(e, qt);
    }
  }
  return this;
}, Qi = new WeakSet(), $a = function(t, e, s, i) {
  var f, p;
  let r = !1, o = !1, a = -1, c = !1;
  if (e.type === null) {
    let m = s, _ = "";
    for (; m < t.length; ) {
      const v = t.charAt(m++);
      if (r || v === "\\") {
        r = !r, _ += v;
        continue;
      }
      if (o) {
        m === a + 1 ? (v === "^" || v === "!") && (c = !0) : v === "]" && !(m === a + 2 && c) && (o = !1), _ += v;
        continue;
      } else if (v === "[") {
        o = !0, a = m, c = !1, _ += v;
        continue;
      }
      if (!i.noext && Ep(v) && t.charAt(m) === "(") {
        e.push(_), _ = "";
        const b = new ye(v, e);
        m = nn(f = ye, Qi, $a).call(f, t, b, m, i), e.push(b);
        continue;
      }
      _ += v;
    }
    return e.push(_), m;
  }
  let l = s + 1, h = new ye(null, e);
  const d = [];
  let u = "";
  for (; l < t.length; ) {
    const m = t.charAt(l++);
    if (r || m === "\\") {
      r = !r, u += m;
      continue;
    }
    if (o) {
      l === a + 1 ? (m === "^" || m === "!") && (c = !0) : m === "]" && !(l === a + 2 && c) && (o = !1), u += m;
      continue;
    } else if (m === "[") {
      o = !0, a = l, c = !1, u += m;
      continue;
    }
    if (Ep(m) && t.charAt(l) === "(") {
      h.push(u), u = "";
      const _ = new ye(m, h);
      h.push(_), l = nn(p = ye, Qi, $a).call(p, t, _, l, i);
      continue;
    }
    if (m === "|") {
      h.push(u), u = "", d.push(h), h = new ye(null, e);
      continue;
    }
    if (m === ")")
      return u === "" && L(e, Rt).length === 0 && zt(e, Fo, !0), h.push(u), u = "", e.push(...d, h), l;
    u += m;
  }
  return e.type = null, zt(e, ce, void 0), zt(e, Rt, [t.substring(s - 1)]), l;
}, Bo = new WeakSet(), ad = function(t) {
  return L(this, Rt).map((e) => {
    if (typeof e == "string")
      throw new Error("string type in extglob ast??");
    const [s, i, r, o] = e.toRegExpSource(t);
    return zt(this, Ns, L(this, Ns) || o), s;
  }).filter((e) => !(this.isStart() && this.isEnd()) || !!e).join("|");
}, xc = new WeakSet(), c2 = function(t, e, s = !1) {
  let i = !1, r = "", o = !1;
  for (let a = 0; a < t.length; a++) {
    const c = t.charAt(a);
    if (i) {
      i = !1, r += (D6.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      a === t.length - 1 ? r += "\\\\" : i = !0;
      continue;
    }
    if (c === "[") {
      const [l, h, d, u] = E6(t, a);
      if (d) {
        r += l, o = o || h, a += d - 1, e = e || u;
        continue;
      }
    }
    if (c === "*") {
      s && t === "*" ? r += Ap : r += Tp, e = !0;
      continue;
    }
    if (c === "?") {
      r += Uu, e = !0;
      continue;
    }
    r += P6(c);
  }
  return [r, Hr(t), !!e, o];
}, _e(ye, Qi), _e(ye, xc);
let cc = ye;
const M6 = (n, { windowsPathsNoEscape: t = !1 } = {}) => t ? n.replace(/[?*()[\]]/g, "[$&]") : n.replace(/[?*()[\]\\]/g, "\\$&"), me = (n, t, e = {}) => (ac(t), !e.nocomment && t.charAt(0) === "#" ? !1 : new Yc(t, e).match(n)), R6 = /^\*+([^+@!?\*\[\(]*)$/, $6 = (n) => (t) => !t.startsWith(".") && t.endsWith(n), N6 = (n) => (t) => t.endsWith(n), L6 = (n) => (n = n.toLowerCase(), (t) => !t.startsWith(".") && t.toLowerCase().endsWith(n)), U6 = (n) => (n = n.toLowerCase(), (t) => t.toLowerCase().endsWith(n)), F6 = /^\*+\.\*+$/, B6 = (n) => !n.startsWith(".") && n.includes("."), V6 = (n) => n !== "." && n !== ".." && n.includes("."), j6 = /^\.\*+$/, G6 = (n) => n !== "." && n !== ".." && n.startsWith("."), H6 = /^\*+$/, z6 = (n) => n.length !== 0 && !n.startsWith("."), W6 = (n) => n.length !== 0 && n !== "." && n !== "..", K6 = /^\?+([^+@!?\*\[\(]*)?$/, Y6 = ([n, t = ""]) => {
  const e = l2([n]);
  return t ? (t = t.toLowerCase(), (s) => e(s) && s.toLowerCase().endsWith(t)) : e;
}, Z6 = ([n, t = ""]) => {
  const e = h2([n]);
  return t ? (t = t.toLowerCase(), (s) => e(s) && s.toLowerCase().endsWith(t)) : e;
}, q6 = ([n, t = ""]) => {
  const e = h2([n]);
  return t ? (s) => e(s) && s.endsWith(t) : e;
}, X6 = ([n, t = ""]) => {
  const e = l2([n]);
  return t ? (s) => e(s) && s.endsWith(t) : e;
}, l2 = ([n]) => {
  const t = n.length;
  return (e) => e.length === t && !e.startsWith(".");
}, h2 = ([n]) => {
  const t = n.length;
  return (e) => e.length === t && e !== "." && e !== "..";
}, d2 = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", Ip = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
}, J6 = d2 === "win32" ? Ip.win32.sep : Ip.posix.sep;
me.sep = J6;
const He = Symbol("globstar **");
me.GLOBSTAR = He;
const Q6 = "[^/]", t9 = Q6 + "*?", e9 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", s9 = "(?:(?!(?:\\/|^)\\.).)*?", n9 = (n, t = {}) => (e) => me(e, n, t);
me.filter = n9;
const je = (n, t = {}) => Object.assign({}, n, t), i9 = (n) => {
  if (!n || typeof n != "object" || !Object.keys(n).length)
    return me;
  const t = me;
  return Object.assign((s, i, r = {}) => t(s, i, je(n, r)), {
    Minimatch: class extends t.Minimatch {
      constructor(i, r = {}) {
        super(i, je(n, r));
      }
      static defaults(i) {
        return t.defaults(je(n, i)).Minimatch;
      }
    },
    AST: class extends t.AST {
      /* c8 ignore start */
      constructor(i, r, o = {}) {
        super(i, r, je(n, o));
      }
      /* c8 ignore stop */
      static fromGlob(i, r = {}) {
        return t.AST.fromGlob(i, je(n, r));
      }
    },
    unescape: (s, i = {}) => t.unescape(s, je(n, i)),
    escape: (s, i = {}) => t.escape(s, je(n, i)),
    filter: (s, i = {}) => t.filter(s, je(n, i)),
    defaults: (s) => t.defaults(je(n, s)),
    makeRe: (s, i = {}) => t.makeRe(s, je(n, i)),
    braceExpand: (s, i = {}) => t.braceExpand(s, je(n, i)),
    match: (s, i, r = {}) => t.match(s, i, je(n, r)),
    sep: t.sep,
    GLOBSTAR: He
  });
};
me.defaults = i9;
const u2 = (n, t = {}) => (ac(n), t.nobrace || !/\{(?:(?!\{).)*\}/.test(n) ? [n] : S6(n));
me.braceExpand = u2;
const r9 = (n, t = {}) => new Yc(n, t).makeRe();
me.makeRe = r9;
const o9 = (n, t, e = {}) => {
  const s = new Yc(t, e);
  return n = n.filter((i) => s.match(i)), s.options.nonull && !n.length && n.push(t), n;
};
me.match = o9;
const Op = /[?*]|[+@!]\(.*?\)|\[|\]/, a9 = (n) => n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class Yc {
  constructor(t, e = {}) {
    Qt(this, "options");
    Qt(this, "set");
    Qt(this, "pattern");
    Qt(this, "windowsPathsNoEscape");
    Qt(this, "nonegate");
    Qt(this, "negate");
    Qt(this, "comment");
    Qt(this, "empty");
    Qt(this, "preserveMultipleSlashes");
    Qt(this, "partial");
    Qt(this, "globSet");
    Qt(this, "globParts");
    Qt(this, "nocase");
    Qt(this, "isWindows");
    Qt(this, "platform");
    Qt(this, "windowsNoMagicRoot");
    Qt(this, "regexp");
    ac(t), e = e || {}, this.options = e, this.pattern = t, this.platform = e.platform || d2, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!e.windowsPathsNoEscape || e.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!e.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!e.nonegate, this.comment = !1, this.empty = !1, this.partial = !!e.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = e.windowsNoMagicRoot !== void 0 ? e.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1)
      return !0;
    for (const t of this.set)
      for (const e of t)
        if (typeof e != "string")
          return !0;
    return !1;
  }
  debug(...t) {
  }
  make() {
    const t = this.pattern, e = this.options;
    if (!e.nocomment && t.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!t) {
      this.empty = !0;
      return;
    }
    this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], e.debug && (this.debug = (...r) => console.error(...r)), this.debug(this.pattern, this.globSet);
    const s = this.globSet.map((r) => this.slashSplit(r));
    this.globParts = this.preprocess(s), this.debug(this.pattern, this.globParts);
    let i = this.globParts.map((r, o, a) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const c = r[0] === "" && r[1] === "" && (r[2] === "?" || !Op.test(r[2])) && !Op.test(r[3]), l = /^[a-z]:/i.test(r[0]);
        if (c)
          return [...r.slice(0, 4), ...r.slice(4).map((h) => this.parse(h))];
        if (l)
          return [r[0], ...r.slice(1).map((h) => this.parse(h))];
      }
      return r.map((c) => this.parse(c));
    });
    if (this.debug(this.pattern, i), this.set = i.filter((r) => r.indexOf(!1) === -1), this.isWindows)
      for (let r = 0; r < this.set.length; r++) {
        const o = this.set[r];
        o[0] === "" && o[1] === "" && this.globParts[r][2] === "?" && typeof o[3] == "string" && /^[a-z]:$/i.test(o[3]) && (o[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(t) {
    if (this.options.noglobstar)
      for (let s = 0; s < t.length; s++)
        for (let i = 0; i < t[s].length; i++)
          t[s][i] === "**" && (t[s][i] = "*");
    const { optimizationLevel: e = 1 } = this.options;
    return e >= 2 ? (t = this.firstPhasePreProcess(t), t = this.secondPhasePreProcess(t)) : e >= 1 ? t = this.levelOneOptimize(t) : t = this.adjascentGlobstarOptimize(t), t;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(t) {
    return t.map((e) => {
      let s = -1;
      for (; (s = e.indexOf("**", s + 1)) !== -1; ) {
        let i = s;
        for (; e[i + 1] === "**"; )
          i++;
        i !== s && e.splice(s, i - s);
      }
      return e;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(t) {
    return t.map((e) => (e = e.reduce((s, i) => {
      const r = s[s.length - 1];
      return i === "**" && r === "**" ? s : i === ".." && r && r !== ".." && r !== "." && r !== "**" ? (s.pop(), s) : (s.push(i), s);
    }, []), e.length === 0 ? [""] : e));
  }
  levelTwoFileOptimize(t) {
    Array.isArray(t) || (t = this.slashSplit(t));
    let e = !1;
    do {
      if (e = !1, !this.preserveMultipleSlashes) {
        for (let i = 1; i < t.length - 1; i++) {
          const r = t[i];
          i === 1 && r === "" && t[0] === "" || (r === "." || r === "") && (e = !0, t.splice(i, 1), i--);
        }
        t[0] === "." && t.length === 2 && (t[1] === "." || t[1] === "") && (e = !0, t.pop());
      }
      let s = 0;
      for (; (s = t.indexOf("..", s + 1)) !== -1; ) {
        const i = t[s - 1];
        i && i !== "." && i !== ".." && i !== "**" && (e = !0, t.splice(s - 1, 2), s -= 2);
      }
    } while (e);
    return t.length === 0 ? [""] : t;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(t) {
    let e = !1;
    do {
      e = !1;
      for (let s of t) {
        let i = -1;
        for (; (i = s.indexOf("**", i + 1)) !== -1; ) {
          let o = i;
          for (; s[o + 1] === "**"; )
            o++;
          o > i && s.splice(i + 1, o - i);
          let a = s[i + 1];
          const c = s[i + 2], l = s[i + 3];
          if (a !== ".." || !c || c === "." || c === ".." || !l || l === "." || l === "..")
            continue;
          e = !0, s.splice(i, 1);
          const h = s.slice(0);
          h[i] = "**", t.push(h), i--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let o = 1; o < s.length - 1; o++) {
            const a = s[o];
            o === 1 && a === "" && s[0] === "" || (a === "." || a === "") && (e = !0, s.splice(o, 1), o--);
          }
          s[0] === "." && s.length === 2 && (s[1] === "." || s[1] === "") && (e = !0, s.pop());
        }
        let r = 0;
        for (; (r = s.indexOf("..", r + 1)) !== -1; ) {
          const o = s[r - 1];
          if (o && o !== "." && o !== ".." && o !== "**") {
            e = !0;
            const c = r === 1 && s[r + 1] === "**" ? ["."] : [];
            s.splice(r - 1, 2, ...c), s.length === 0 && s.push(""), r -= 2;
          }
        }
      }
    } while (e);
    return t;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(t) {
    for (let e = 0; e < t.length - 1; e++)
      for (let s = e + 1; s < t.length; s++) {
        const i = this.partsMatch(t[e], t[s], !this.preserveMultipleSlashes);
        i && (t[e] = i, t[s] = []);
      }
    return t.filter((e) => e.length);
  }
  partsMatch(t, e, s = !1) {
    let i = 0, r = 0, o = [], a = "";
    for (; i < t.length && r < e.length; )
      if (t[i] === e[r])
        o.push(a === "b" ? e[r] : t[i]), i++, r++;
      else if (s && t[i] === "**" && e[r] === t[i + 1])
        o.push(t[i]), i++;
      else if (s && e[r] === "**" && t[i] === e[r + 1])
        o.push(e[r]), r++;
      else if (t[i] === "*" && e[r] && (this.options.dot || !e[r].startsWith(".")) && e[r] !== "**") {
        if (a === "b")
          return !1;
        a = "a", o.push(t[i]), i++, r++;
      } else if (e[r] === "*" && t[i] && (this.options.dot || !t[i].startsWith(".")) && t[i] !== "**") {
        if (a === "a")
          return !1;
        a = "b", o.push(e[r]), i++, r++;
      } else
        return !1;
    return t.length === e.length && o;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const t = this.pattern;
    let e = !1, s = 0;
    for (let i = 0; i < t.length && t.charAt(i) === "!"; i++)
      e = !e, s++;
    s && (this.pattern = t.slice(s)), this.negate = e;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(t, e, s = !1) {
    const i = this.options;
    if (this.isWindows) {
      const m = typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]), _ = !m && t[0] === "" && t[1] === "" && t[2] === "?" && /^[a-z]:$/i.test(t[3]), v = typeof e[0] == "string" && /^[a-z]:$/i.test(e[0]), b = !v && e[0] === "" && e[1] === "" && e[2] === "?" && typeof e[3] == "string" && /^[a-z]:$/i.test(e[3]), g = _ ? 3 : m ? 0 : void 0, y = b ? 3 : v ? 0 : void 0;
      if (typeof g == "number" && typeof y == "number") {
        const [S, w] = [t[g], e[y]];
        S.toLowerCase() === w.toLowerCase() && (e[y] = S, y > g ? e = e.slice(y) : g > y && (t = t.slice(g)));
      }
    }
    const { optimizationLevel: r = 1 } = this.options;
    r >= 2 && (t = this.levelTwoFileOptimize(t)), this.debug("matchOne", this, { file: t, pattern: e }), this.debug("matchOne", t.length, e.length);
    for (var o = 0, a = 0, c = t.length, l = e.length; o < c && a < l; o++, a++) {
      this.debug("matchOne loop");
      var h = e[a], d = t[o];
      if (this.debug(e, h, d), h === !1)
        return !1;
      if (h === He) {
        this.debug("GLOBSTAR", [e, h, d]);
        var u = o, f = a + 1;
        if (f === l) {
          for (this.debug("** at the end"); o < c; o++)
            if (t[o] === "." || t[o] === ".." || !i.dot && t[o].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; u < c; ) {
          var p = t[u];
          if (this.debug(`
globstar while`, t, u, e, f, p), this.matchOne(t.slice(u), e.slice(f), s))
            return this.debug("globstar found match!", u, c, p), !0;
          if (p === "." || p === ".." || !i.dot && p.charAt(0) === ".") {
            this.debug("dot detected!", t, u, e, f);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), u++;
        }
        return !!(s && (this.debug(`
>>> no match, partial?`, t, u, e, f), u === c));
      }
      let m;
      if (typeof h == "string" ? (m = d === h, this.debug("string match", h, d, m)) : (m = h.test(d), this.debug("pattern match", h, d, m)), !m)
        return !1;
    }
    if (o === c && a === l)
      return !0;
    if (o === c)
      return s;
    if (a === l)
      return o === c - 1 && t[o] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return u2(this.pattern, this.options);
  }
  parse(t) {
    ac(t);
    const e = this.options;
    if (t === "**")
      return He;
    if (t === "")
      return "";
    let s, i = null;
    (s = t.match(H6)) ? i = e.dot ? W6 : z6 : (s = t.match(R6)) ? i = (e.nocase ? e.dot ? U6 : L6 : e.dot ? N6 : $6)(s[1]) : (s = t.match(K6)) ? i = (e.nocase ? e.dot ? Z6 : Y6 : e.dot ? q6 : X6)(s) : (s = t.match(F6)) ? i = e.dot ? V6 : B6 : (s = t.match(j6)) && (i = G6);
    const r = cc.fromGlob(t, this.options).toMMPattern();
    return i && typeof r == "object" && Reflect.defineProperty(r, "test", { value: i }), r;
  }
  makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    const t = this.set;
    if (!t.length)
      return this.regexp = !1, this.regexp;
    const e = this.options, s = e.noglobstar ? t9 : e.dot ? e9 : s9, i = new Set(e.nocase ? ["i"] : []);
    let r = t.map((c) => {
      const l = c.map((h) => {
        if (h instanceof RegExp)
          for (const d of h.flags.split(""))
            i.add(d);
        return typeof h == "string" ? a9(h) : h === He ? He : h._src;
      });
      return l.forEach((h, d) => {
        const u = l[d + 1], f = l[d - 1];
        h !== He || f === He || (f === void 0 ? u !== void 0 && u !== He ? l[d + 1] = "(?:\\/|" + s + "\\/)?" + u : l[d] = s : u === void 0 ? l[d - 1] = f + "(?:\\/|" + s + ")?" : u !== He && (l[d - 1] = f + "(?:\\/|\\/" + s + "\\/)" + u, l[d + 1] = He));
      }), l.filter((h) => h !== He).join("/");
    }).join("|");
    const [o, a] = t.length > 1 ? ["(?:", ")"] : ["", ""];
    r = "^" + o + r + a + "$", this.negate && (r = "^(?!" + r + ").+$");
    try {
      this.regexp = new RegExp(r, [...i].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(t) {
    return this.preserveMultipleSlashes ? t.split("/") : this.isWindows && /^\/\/[^\/]+/.test(t) ? ["", ...t.split(/\/+/)] : t.split(/\/+/);
  }
  match(t, e = this.partial) {
    if (this.debug("match", t, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return t === "";
    if (t === "/" && e)
      return !0;
    const s = this.options;
    this.isWindows && (t = t.split("\\").join("/"));
    const i = this.slashSplit(t);
    this.debug(this.pattern, "split", i);
    const r = this.set;
    this.debug(this.pattern, "set", r);
    let o = i[i.length - 1];
    if (!o)
      for (let a = i.length - 2; !o && a >= 0; a--)
        o = i[a];
    for (let a = 0; a < r.length; a++) {
      const c = r[a];
      let l = i;
      if (s.matchBase && c.length === 1 && (l = [o]), this.matchOne(l, c, e))
        return s.flipNegate ? !0 : !this.negate;
    }
    return s.flipNegate ? !1 : this.negate;
  }
  static defaults(t) {
    return me.defaults(t).Minimatch;
  }
}
me.AST = cc;
me.Minimatch = Yc;
me.escape = M6;
me.unescape = Hr;
class f2 {
  _stashProp(t) {
    this.model[t] = Xa(this.yBlock.get(`prop:${t}`), {
      transform: (e, s) => ks.is(s) ? e : s instanceof ne ? new Proxy(e, {
        get: (i, r, o) => Reflect.get(i, r, o),
        set: (i, r, o, a) => {
          var l, h;
          const c = Reflect.set(i, r, o, a);
          return (h = (l = this.options).onChange) == null || h.call(l, this, t, o), c;
        },
        deleteProperty: (i, r) => {
          var a, c;
          const o = Reflect.deleteProperty(i, r);
          return (c = (a = this.options).onChange) == null || c.call(a, this, t, void 0), o;
        }
      }) : s instanceof de ? new Proxy(e, {
        get: (i, r, o) => Reflect.get(i, r, o),
        set: (i, r, o, a) => {
          var h, d;
          const c = Number(r);
          if (Number.isNaN(c))
            return Reflect.set(i, r, o, a);
          const l = Reflect.set(i, r, o, a);
          return (d = (h = this.options).onChange) == null || d.call(h, this, t, o), l;
        },
        deleteProperty: (i, r) => {
          var a, c;
          const o = Reflect.deleteProperty(i, r);
          return (c = (a = this.options).onChange) == null || c.call(a, this, r, void 0), o;
        }
      }) : e
    });
  }
  _popProp(t) {
    const e = this.model, s = e[t];
    this._stashed.delete(t), e[t] = s;
  }
  constructor(t, e, s, i = {}) {
    this.schema = t, this.yBlock = e, this.doc = s, this.options = i, this._byPassProxy = !1, this._stashed = /* @__PURE__ */ new Set(), this.stash = (h) => {
      this._stashed.has(h) || (this._stashed.add(h), this._stashProp(h));
    }, this.pop = (h) => {
      this._stashed.has(h) && this._popProp(h);
    }, this._byPassUpdate = (h) => {
      this._byPassProxy = !0, h(), this._byPassProxy = !1;
    }, this._getPropsProxy = (h, d) => si(d, {
      onChange: () => {
        var u, f;
        (f = (u = this.options).onChange) == null || f.call(u, this, h, d);
      }
    });
    const { id: r, flavour: o, version: a, yChildren: c, props: l } = this._parseYBlock();
    this.id = r, this.flavour = o, this.yChildren = c, this.version = a, this.model = this._createModel(l), this.yChildren.observe(() => {
      this.model.childrenUpdated.emit();
    }), this.yBlock.observe((h) => {
      h.keysChanged.forEach((d) => {
        var f, p, m, _;
        const u = h.changes.keys.get(d);
        if (u) {
          if (u.action === "update" || u.action === "add") {
            const v = this.yBlock.get(d), b = d.replace("prop:", ""), g = this._getPropsProxy(b, v);
            this._byPassUpdate(() => {
              this.model[b] = g;
            }), (p = (f = this.options).onChange) == null || p.call(f, this, b, v);
            return;
          }
          if (u.action === "delete") {
            const v = d.replace("prop:", "");
            this._byPassUpdate(() => {
              delete this.model[v];
            }), (_ = (m = this.options).onChange) == null || _.call(m, this, v, void 0);
            return;
          }
        }
      });
    }), this.yBlock.observeDeep((h) => {
      var u, f;
      const d = h[0];
      !d || d.currentTarget === d.target || (f = (u = this.options).onChange) == null || f.call(u, this, "", void 0);
    }), s && (this.model.doc = s);
  }
  _parseYBlock() {
    var c, l;
    let t, e, s, i;
    const r = {};
    this.yBlock.forEach((h, d) => {
      if (d.startsWith("prop:")) {
        const u = d.replace("prop:", "");
        r[u] = this._getPropsProxy(u, h);
        return;
      }
      if (d === "sys:id" && typeof h == "string") {
        t = h;
        return;
      }
      if (d === "sys:flavour" && typeof h == "string") {
        e = h;
        return;
      }
      if (d === "sys:children" && h instanceof de) {
        i = h;
        return;
      }
      if (d === "sys:version" && typeof h == "number") {
        s = h;
        return;
      }
    }), B(t, "Block id is not found"), B(e, "Block flavour is not found"), B(i, "Block children is not found");
    const o = this.schema.flavourSchemaMap.get(e);
    B(o, `Cannot find schema for flavour ${e}`);
    const a = (l = (c = o.model).props) == null ? void 0 : l.call(c, Kc);
    return typeof s != "number" && (s = o.version), a && Object.entries(a).forEach(([h, d]) => {
      if (r[h] !== void 0)
        return;
      const u = _n(d);
      this.yBlock.set(`prop:${h}`, u), r[h] = this._getPropsProxy(h, u);
    }), {
      id: t,
      flavour: e,
      version: s,
      props: r,
      yChildren: i
    };
  }
  _createModel(t) {
    var i, r;
    const e = this.schema.flavourSchemaMap.get(this.flavour);
    B(e, `Cannot find schema for flavour ${this.flavour}`);
    const s = ((r = (i = e.model).toModel) == null ? void 0 : r.call(i)) ?? new Nu();
    return Object.assign(s, t), s.id = this.id, s.version = this.version, s.keys = Object.keys(t), s.flavour = e.model.flavour, s.role = e.model.role, s.yBlock = this.yBlock, s.stash = this.stash, s.pop = this.pop, new Proxy(s, {
      has: (o, a) => Reflect.has(o, a),
      set: (o, a, c, l) => {
        var h, d;
        if (!this._byPassProxy && typeof a == "string" && s.keys.includes(a)) {
          if (this._stashed.has(a)) {
            const p = Reflect.set(o, a, c, l);
            return (d = (h = this.options).onChange) == null || d.call(h, this, a, c), p;
          }
          const u = _n(c);
          this.yBlock.set(`prop:${a}`, u);
          const f = this._getPropsProxy(a, u);
          return Reflect.set(o, a, f, l);
        }
        return Reflect.set(o, a, c, l);
      },
      get: (o, a, c) => Reflect.get(o, a, c),
      deleteProperty: (o, a) => (!this._byPassProxy && typeof a == "string" && s.keys.includes(a) && this.yBlock.delete(`prop:${a}`), Reflect.deleteProperty(o, a))
    });
  }
}
class ph extends Mc {
  constructor(t) {
    super(no.MIGRATION_ERROR, `Migration failed. Please report to https://github.com/toeverything/blocksuite/issues
          ${t}`);
  }
}
class Os extends Mc {
  constructor(t, e) {
    super(no.SCHEMA_VALIDATE_ERROR, `Invalid schema for ${t}: ${e}`);
  }
}
class c9 {
  constructor() {
    this.flavourSchemaMap = /* @__PURE__ */ new Map(), this.validate = (t, e, s) => {
      const i = this.flavourSchemaMap.get(t);
      B(i, new Os(t, dh));
      const r = () => {
        s == null || s.forEach((a) => {
          const c = this.flavourSchemaMap.get(a);
          B(c, new Os(a, dh)), this.validateSchema(c, i);
        });
      };
      if (i.model.role === "root") {
        if (e)
          throw new Os(i.model.flavour, "Root block cannot have parent.");
        r();
        return;
      }
      if (!e)
        throw new Os(i.model.flavour, "Hub/Content must have parent.");
      const o = this.flavourSchemaMap.get(e);
      B(o, new Os(e, dh)), this.validateSchema(i, o), r();
    }, this.upgradeCollection = (t) => {
      this._upgradeBlockVersions(t), h4.forEach((e) => {
        try {
          e.condition(t) && e.migrate(t);
        } catch (s) {
          throw console.error(s), new ph(e.desc);
        }
      });
    }, this.upgradeDoc = (t, e, s) => {
      const i = s.getMap("blocks");
      Array.from(i.values()).forEach((r) => {
        const o = r.get("sys:flavour"), a = e[o] ?? 0;
        B(a, `previous version for flavour ${o} not found`), this.upgradeBlock(o, a, r);
      }), e3.forEach((r) => {
        try {
          r.condition(t, s) && r.migrate(t, s);
        } catch (o) {
          throw new ph(`${r.desc}
            ${o}`);
        }
      });
    }, this.upgradeBlock = (t, e, s) => {
      try {
        const i = this.flavourSchemaMap.get(t);
        B(i);
        const { onUpgrade: r, version: o } = i;
        if (!r)
          return;
        const a = new f2(this, s);
        return r(a.model, e, o);
      } catch (i) {
        throw new ph(`upgrade block ${t} failed.
          ${i}`);
      }
    }, this._upgradeBlockVersions = (t) => {
      const s = t.getMap("meta").get("blockVersions");
      s && s.forEach((i, r) => {
        const o = this.flavourSchemaMap.get(r);
        o && i !== o.version && s.set(r, o.version);
      });
    };
  }
  get versions() {
    return Object.fromEntries(Array.from(this.flavourSchemaMap.values()).map((t) => [t.model.flavour, t.version]));
  }
  toJSON() {
    return Object.fromEntries(Array.from(this.flavourSchemaMap.values()).map((t) => [
      t.model.flavour,
      {
        role: t.model.role,
        parent: t.model.parent,
        children: t.model.children
      }
    ]));
  }
  register(t) {
    return t.forEach((e) => {
      Jg.parse(e), this.flavourSchemaMap.set(e.model.flavour, e);
    }), this;
  }
  validateSchema(t, e) {
    if (this._validateRole(t, e), !this._validateParent(t, e))
      throw new Os(t.model.flavour, `Block cannot have parent: ${e.model.flavour}.`);
  }
  _validateRole(t, e) {
    const s = t.model.role, i = e.model.role, r = t.model.flavour, o = e.model.flavour;
    if (s === "root")
      throw new Os(r, `Root block cannot have parent: ${o}.`);
    if (s === "hub" && i === "content")
      throw new Os(r, `Hub block cannot be child of content block: ${o}.`);
    if (s === "content" && i === "root")
      throw new Os(r, `Content block can only be child of hub block or itself. But get: ${o}.`);
  }
  _matchFlavour(t, e) {
    return me(t, e) || me(e, t);
  }
  _validateParent(t, e) {
    const s = t.model.flavour, i = e.model.flavour, r = t.model.parent || ["*"];
    return (e.model.children || ["*"]).some((a) => r.some((c) => a === "*" && c === "*" ? !0 : a === "*" ? this._matchFlavour(c, i) : c === "*" ? this._matchFlavour(s, a) : this._matchFlavour(s, a) && this._matchFlavour(c, i)));
  }
}
const l9 = (n) => class extends n {
  constructor(t) {
    super(t), this._storages = [], this._storages = (t.blobStorages ?? [n3]).map((e) => e(t.id || "")), this.blob = {
      get: async (e) => {
        let s = !1, i = 0;
        return new Promise((r) => {
          this._storages.map(async (o) => {
            try {
              const a = await o.crud.get(e);
              a && !s && (s = !0, r(a)), ++i === this._storages.length && !s && r(null);
            } catch (a) {
              console.error(a), ++i === this._storages.length && !s && r(null);
            }
          });
        });
      },
      set: async (e, s) => {
        const i = s || await c4(await e.arrayBuffer());
        return await Promise.all(this._storages.map((r) => r.crud.set(i, e))), i;
      },
      delete: async (e) => {
        await Promise.all(this._storages.map((s) => s.crud.delete(e)));
      },
      list: async () => {
        const e = /* @__PURE__ */ new Set();
        return await Promise.all(this._storages.map(async (s) => {
          (await s.crud.list()).forEach((r) => e.add(r));
        })), Array.from(e);
      }
    };
  }
};
function h9(n, t, e = (s, i) => s === i) {
  const s = [], i = [], r = [];
  for (const o of n)
    t.some((a) => e(a, o)) ? r.push(o) : i.push(o);
  for (const o of t)
    n.some((a) => e(a, o)) || s.push(o);
  return { changed: s.length || i.length, add: s, remove: i, unchanged: r };
}
class d9 {
  get linkIndexMap() {
    return this._linkIndexMap;
  }
  constructor(t) {
    this._disposables = new as(), this._linkIndexMap = {}, this.slots = {
      /**
       * Note: sys:children update will not trigger event
       */
      indexUpdated: new lt()
    }, this._backlinkIndexMapCache = null, this._disposables.add(t.slots.refreshIndex.on(() => this._onRefreshIndex())), this._disposables.add(t.slots.docRemoved.on((e) => this._onDocRemoved(e))), this._disposables.add(t.slots.blockUpdated.on((e) => this._onBlockUpdated(e))), this.slots.indexUpdated.on(() => {
      this._backlinkIndexMapCache = null;
    });
  }
  /**
   * Get the list of backlinks for a given doc
   */
  getBacklink(t) {
    if (this._backlinkIndexMapCache)
      return this._backlinkIndexMapCache[t] ?? [];
    const e = {};
    for (const [s, i] of Object.entries(this._linkIndexMap))
      for (const [r, o] of Object.entries(i))
        o.forEach(({ pageId: a, type: c }) => {
          a in e || (e[a] = []), e[a].push({
            pageId: s,
            blockId: r,
            type: c
          });
        });
    return this._backlinkIndexMapCache = e, this._backlinkIndexMapCache[t] ?? [];
  }
  _onRefreshIndex() {
    this._linkIndexMap = {};
  }
  _onDocRemoved(t) {
    this._linkIndexMap[t] && (this._linkIndexMap[t] = {}, this.slots.indexUpdated.emit({ action: "delete", docId: t }));
  }
  _onBlockUpdated({ action: t, docId: e, block: s, blockId: i }) {
    switch (t) {
      case "add":
      case "update": {
        let r = [];
        const o = s.get("prop:text");
        if (o)
          if (o instanceof pe) {
            const c = o.toDelta();
            r = [
              ...r,
              ...c.filter((l) => l.attributes && l.attributes.reference).map((l) => ({ ...l.attributes.reference, blockId: i }))
            ];
          } else
            console.warn("Unexpected prop:text type", o);
        const a = s.get("sys:flavour");
        if (a === "affine:embed-linked-doc" || a === "affine:embed-synced-doc") {
          const c = s.get("prop:pageId");
          typeof c == "string" ? r = [...r, { pageId: c, blockId: i, type: "LinkedPage" }] : console.warn("Unexpected prop:pageId type", c);
        }
        this._indexDelta({ action: t, docId: e, blockId: i, links: r });
        return;
      }
      case "delete": {
        this._removeIndex(e, i);
        break;
      }
    }
  }
  _indexDelta({ action: t, docId: e, blockId: s, links: i }) {
    var a;
    const r = ((a = this._linkIndexMap[e]) == null ? void 0 : a[s]) ?? [];
    h9(r, i).changed && (this._linkIndexMap[e] = {
      ...this._linkIndexMap[e],
      [s]: i
    }, this.slots.indexUpdated.emit({ action: t, docId: e, blockId: s }));
  }
  _removeIndex(t, e) {
    if (!this._linkIndexMap[t] || !this._linkIndexMap[t][e])
      return;
    const s = this._linkIndexMap[t][e];
    delete this._linkIndexMap[t][e], s.length && this.slots.indexUpdated.emit({
      action: "delete",
      docId: t,
      blockId: e
    });
  }
  dispose() {
    this._disposables.dispose();
  }
}
class u9 {
  constructor(t, { immediately: e = !1, slots: s }) {
    if (this._disposables = new as(), this.slots = {
      docRemoved: new lt(),
      /**
       * Note: sys:children update will not trigger event
       */
      blockUpdated: new lt(),
      refreshIndex: new lt()
    }, this._yDocObserver = (i, r, { docId: o, yDoc: a }) => {
      i.forEach((c) => {
        if (!(c instanceof Pu)) {
          if (c instanceof Mu) {
            if (c.target !== c.currentTarget) {
              if (c.keysChanged.has("prop:text")) {
                const l = c.path[0], h = a.get(l);
                B(h), this._indexBlock({
                  action: "update",
                  docId: o,
                  blockId: l,
                  block: h
                });
              }
              return;
            }
            Array.from(c.changes.keys.entries()).forEach(([l, { action: h }]) => {
              if (h === "delete") {
                this._indexBlock({
                  action: h,
                  docId: o,
                  blockId: l
                });
                return;
              }
              const d = a.get(l);
              B(d), this._indexBlock({
                action: h,
                docId: o,
                blockId: l,
                block: d
              });
            });
            return;
          }
          if (c instanceof Ru) {
            const l = c.path[0];
            if (!l || typeof l != "string")
              throw new Error("Failed to update index! Unexpected YText Event!");
            const h = a.get(l);
            B(h), this._indexBlock({
              action: "update",
              docId: o,
              blockId: l,
              block: h
            });
            return;
          }
        }
      });
    }, this._doc = t, this._collectionSlots = s, e) {
      this._initIndex();
      return;
    }
    setTimeout(() => {
      this._initIndex();
    }, 0);
  }
  _initIndex() {
    const t = this._doc;
    if (!t.share.has("meta"))
      throw new Error("Failed to initialize indexer: collection meta not found");
    let s = {};
    this._disposables.add(() => {
      Object.values(s).forEach((i) => i == null ? void 0 : i()), s = {};
    }), Array.from(t.spaces.keys()).map((i) => ({ docId: i, doc: this._getDoc(i) })).forEach(({ docId: i, doc: r }) => {
      if (B(r, `Failed to find doc '${i}'`), s[i]) {
        console.warn(`Duplicated docAdded event! ${i} already observed`, s);
        return;
      }
      const o = this._indexDoc(i, r);
      s[i] = o;
    }), this._collectionSlots.docAdded.on((i) => {
      const r = this._getDoc(i);
      if (B(r, `Failed to find doc '${i}'`), s[i])
        return;
      const o = this._indexDoc(i, r);
      s[i] = o;
    }), this._collectionSlots.docRemoved.on((i) => {
      var r;
      (r = s[i]) == null || r.call(s), s[i] = null, this.slots.docRemoved.emit(i);
    });
  }
  _indexDoc(t, e) {
    const s = e.getMap("blocks");
    s.forEach((r, o) => {
      this._indexBlock({ action: "add", docId: t, blockId: o, block: r });
    });
    const i = (r, o) => this._yDocObserver(r, o, { docId: t, yDoc: s });
    return s.observeDeep(i), () => {
      s.unobserveDeep(i);
    };
  }
  _indexBlock(t) {
    this.slots.blockUpdated.emit(t);
  }
  _getDoc(t) {
    return this._doc.spaces.get(t);
  }
  refreshIndex() {
    this.slots.refreshIndex.emit(), this._initIndex();
  }
  dispose() {
    this._disposables.dispose();
  }
}
const Fu = typeof window < "u" && typeof document < "u", f9 = typeof process < "u" && !Fu;
Fu && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
const p9 = {}, g9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: p9
}, Symbol.toStringTag, { value: "Module" })), m9 = /* @__PURE__ */ jy(g9);
var Gt;
function Na(n) {
  return typeof n < "u" ? n : !0;
}
function Dp(n) {
  const t = Array(n);
  for (let e = 0; e < n; e++)
    t[e] = $t();
  return t;
}
function $t() {
  return /* @__PURE__ */ Object.create(null);
}
function _9(n, t) {
  return t.length - n.length;
}
function ve(n) {
  return typeof n == "string";
}
function wn(n) {
  return typeof n == "object";
}
function Bu(n) {
  return typeof n == "function";
}
function p2(n, t) {
  var e = y9;
  if (n && (t && (n = La(n, t)), this.H && (n = La(n, this.H)), this.J && 1 < n.length && (n = La(n, this.J)), e || e === "")) {
    if (t = n.split(e), this.filter) {
      n = this.filter, e = t.length;
      const s = [];
      for (let i = 0, r = 0; i < e; i++) {
        const o = t[i];
        o && !n[o] && (s[r++] = o);
      }
      n = s;
    } else
      n = t;
    return n;
  }
  return n;
}
const y9 = /[\p{Z}\p{S}\p{P}\p{C}]+/u, v9 = /[\u0300-\u036f]/g;
function Pp(n, t) {
  const e = Object.keys(n), s = e.length, i = [];
  let r = "", o = 0;
  for (let a = 0, c, l; a < s; a++)
    c = e[a], (l = n[c]) ? (i[o++] = Wt(t ? "(?!\\b)" + c + "(\\b|_)" : c), i[o++] = l) : r += (r ? "|" : "") + c;
  return r && (i[o++] = Wt(t ? "(?!\\b)(" + r + ")(\\b|_)" : "(" + r + ")"), i[o] = ""), i;
}
function La(n, t) {
  for (let e = 0, s = t.length; e < s && (n = n.replace(t[e], t[e + 1]), n); e += 2)
    ;
  return n;
}
function Wt(n) {
  return new RegExp(n, "g");
}
function g2(n) {
  let t = "", e = "";
  for (let s = 0, i = n.length, r; s < i; s++)
    (r = n[s]) !== e && (t += e = r);
  return t;
}
var b9 = { encode: m2, F: !1, G: "" };
function m2(n) {
  return p2.call(this, ("" + n).toLowerCase(), !1);
}
const _2 = {}, mi = {};
function y2(n) {
  Mr(n, "add"), Mr(n, "append"), Mr(n, "search"), Mr(n, "update"), Mr(n, "remove");
}
function Mr(n, t) {
  n[t + "Async"] = function() {
    const e = this, s = arguments;
    var i = s[s.length - 1];
    let r;
    return Bu(i) && (r = i, delete s[s.length - 1]), i = new Promise(function(o) {
      setTimeout(function() {
        e.async = !0;
        const a = e[t].apply(e, s);
        e.async = !1, o(a);
      });
    }), r ? (i.then(r), this) : i;
  };
}
function v2(n, t, e, s) {
  const i = n.length;
  let r = [], o, a, c = 0;
  s && (s = []);
  for (let l = i - 1; 0 <= l; l--) {
    const h = n[l], d = h.length, u = $t();
    let f = !o;
    for (let p = 0; p < d; p++) {
      const m = h[p], _ = m.length;
      if (_)
        for (let v = 0, b, g; v < _; v++)
          if (g = m[v], o) {
            if (o[g]) {
              if (!l) {
                if (e)
                  e--;
                else if (r[c++] = g, c === t)
                  return r;
              }
              (l || s) && (u[g] = 1), f = !0;
            }
            if (s && (b = (a[g] || 0) + 1, a[g] = b, b < i)) {
              const y = s[b - 2] || (s[b - 2] = []);
              y[y.length] = g;
            }
          } else
            u[g] = 1;
    }
    if (s)
      o || (a = u);
    else if (!f)
      return [];
    o = u;
  }
  if (s)
    for (let l = s.length - 1, h, d; 0 <= l; l--) {
      h = s[l], d = h.length;
      for (let u = 0, f; u < d; u++)
        if (f = h[u], !o[f]) {
          if (e)
            e--;
          else if (r[c++] = f, c === t)
            return r;
          o[f] = 1;
        }
    }
  return r;
}
function w9(n, t) {
  const e = $t(), s = $t(), i = [];
  for (let r = 0; r < n.length; r++)
    e[n[r]] = 1;
  for (let r = 0, o; r < t.length; r++) {
    o = t[r];
    for (let a = 0, c; a < o.length; a++)
      c = o[a], e[c] && !s[c] && (s[c] = 1, i[i.length] = c);
  }
  return i;
}
function Zc(n) {
  this.l = n !== !0 && n, this.cache = $t(), this.h = [];
}
function b2(n, t, e) {
  wn(n) && (n = n.query);
  let s = this.cache.get(n);
  return s || (s = this.search(n, t, e), this.cache.set(n, s)), s;
}
Zc.prototype.set = function(n, t) {
  if (!this.cache[n]) {
    var e = this.h.length;
    for (e === this.l ? delete this.cache[this.h[e - 1]] : e++, --e; 0 < e; e--)
      this.h[e] = this.h[e - 1];
    this.h[0] = n;
  }
  this.cache[n] = t;
};
Zc.prototype.get = function(n) {
  const t = this.cache[n];
  if (this.l && t && (n = this.h.indexOf(n))) {
    const e = this.h[n - 1];
    this.h[n - 1] = this.h[n], this.h[n] = e;
  }
  return t;
};
const S9 = { memory: { charset: "latin:extra", D: 3, B: 4, m: !1 }, performance: { D: 3, B: 3, s: !1, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, default: {} };
function w2(n, t, e, s, i, r, o, a) {
  setTimeout(function() {
    const c = n(e ? e + "." + s : s, JSON.stringify(o));
    c && c.then ? c.then(function() {
      t.export(n, t, e, i, r + 1, a);
    }) : t.export(n, t, e, i, r + 1, a);
  });
}
function oi(n, t) {
  if (!(this instanceof oi))
    return new oi(n);
  var e;
  if (n) {
    ve(n) ? n = S9[n] : (e = n.preset) && (n = Object.assign({}, e[e], n)), e = n.charset;
    var s = n.lang;
    ve(e) && (e.indexOf(":") === -1 && (e += ":default"), e = mi[e]), ve(s) && (s = _2[s]);
  } else
    n = {};
  let i, r, o = n.context || {};
  if (this.encode = n.encode || e && e.encode || m2, this.register = t || $t(), this.D = i = n.resolution || 9, this.G = t = e && e.G || n.tokenize || "strict", this.depth = t === "strict" && o.depth, this.l = Na(o.bidirectional), this.s = r = Na(n.optimize), this.m = Na(n.fastupdate), this.B = n.minlength || 1, this.C = n.boost, this.map = r ? Dp(i) : $t(), this.A = i = o.resolution || 1, this.h = r ? Dp(i) : $t(), this.F = e && e.F || n.rtl, this.H = (t = n.matcher || s && s.H) && Pp(t, !1), this.J = (t = n.stemmer || s && s.J) && Pp(t, !0), e = t = n.filter || s && s.filter) {
    e = t, s = $t();
    for (let a = 0, c = e.length; a < c; a++)
      s[e[a]] = 1;
    e = s;
  }
  this.filter = e, this.cache = (t = n.cache) && new Zc(t);
}
Gt = oi.prototype;
Gt.append = function(n, t) {
  return this.add(n, t, !0);
};
Gt.add = function(n, t, e, s) {
  if (t && (n || n === 0)) {
    if (!s && !e && this.register[n])
      return this.update(n, t);
    if (t = this.encode(t), s = t.length) {
      const l = $t(), h = $t(), d = this.depth, u = this.D;
      for (let f = 0; f < s; f++) {
        let p = t[this.F ? s - 1 - f : f];
        var i = p.length;
        if (p && i >= this.B && (d || !h[p])) {
          var r = fa(u, s, f), o = "";
          switch (this.G) {
            case "full":
              if (2 < i) {
                for (r = 0; r < i; r++)
                  for (var a = i; a > r; a--)
                    if (a - r >= this.B) {
                      var c = fa(u, s, f, i, r);
                      o = p.substring(r, a), Rr(this, h, o, c, n, e);
                    }
                break;
              }
            case "reverse":
              if (1 < i) {
                for (a = i - 1; 0 < a; a--)
                  o = p[a] + o, o.length >= this.B && Rr(
                    this,
                    h,
                    o,
                    fa(u, s, f, i, a),
                    n,
                    e
                  );
                o = "";
              }
            case "forward":
              if (1 < i) {
                for (a = 0; a < i; a++)
                  o += p[a], o.length >= this.B && Rr(this, h, o, r, n, e);
                break;
              }
            default:
              if (this.C && (r = Math.min(r / this.C(t, p, f) | 0, u - 1)), Rr(this, h, p, r, n, e), d && 1 < s && f < s - 1) {
                for (i = $t(), o = this.A, r = p, a = Math.min(d + 1, s - f), i[r] = 1, c = 1; c < a; c++)
                  if ((p = t[this.F ? s - 1 - f - c : f + c]) && p.length >= this.B && !i[p]) {
                    i[p] = 1;
                    const m = this.l && p > r;
                    Rr(this, l, m ? r : p, fa(o + (s / 2 > o ? 0 : 1), s, f, a - 1, c - 1), n, e, m ? p : r);
                  }
              }
          }
        }
      }
      this.m || (this.register[n] = 1);
    }
  }
  return this;
};
function fa(n, t, e, s, i) {
  return e && 1 < n ? t + (s || 0) <= n ? e + (i || 0) : (n - 1) / (t + (s || 0)) * (e + (i || 0)) + 1 | 0 : 0;
}
function Rr(n, t, e, s, i, r, o) {
  let a = o ? n.h : n.map;
  (!t[e] || o && !t[e][o]) && (n.s && (a = a[s]), o ? (t = t[e] || (t[e] = $t()), t[o] = 1, a = a[o] || (a[o] = $t())) : t[e] = 1, a = a[e] || (a[e] = []), n.s || (a = a[s] || (a[s] = [])), r && a.includes(i) || (a[a.length] = i, n.m && (n = n.register[i] || (n.register[i] = []), n[n.length] = a)));
}
Gt.search = function(n, t, e) {
  e || (!t && wn(n) ? (e = n, n = e.query) : wn(t) && (e = t));
  let s = [], i, r, o = 0;
  if (e) {
    n = e.query || n, t = e.limit, o = e.offset || 0;
    var a = e.context;
    r = e.suggest;
  }
  if (n && (n = this.encode("" + n), i = n.length, 1 < i)) {
    e = $t();
    var c = [];
    for (let h = 0, d = 0, u; h < i; h++)
      if ((u = n[h]) && u.length >= this.B && !e[u])
        if (this.s || r || this.map[u])
          c[d++] = u, e[u] = 1;
        else
          return s;
    n = c, i = n.length;
  }
  if (!i)
    return s;
  t || (t = 100), a = this.depth && 1 < i && a !== !1, e = 0;
  let l;
  a ? (l = n[0], e = 1) : 1 < i && n.sort(_9);
  for (let h, d; e < i; e++) {
    if (d = n[e], a ? (h = Mp(
      this,
      s,
      r,
      t,
      o,
      i === 2,
      d,
      l
    ), r && h === !1 && s.length || (l = d)) : h = Mp(this, s, r, t, o, i === 1, d), h)
      return h;
    if (r && e === i - 1) {
      if (c = s.length, !c) {
        if (a) {
          a = 0, e = -1;
          continue;
        }
        return s;
      }
      if (c === 1)
        return S2(s[0], t, o);
    }
  }
  return v2(s, t, o, r);
};
function Mp(n, t, e, s, i, r, o, a) {
  let c = [], l = a ? n.h : n.map;
  if (n.s || (l = Rp(l, o, a, n.l)), l) {
    let h = 0;
    const d = Math.min(l.length, a ? n.A : n.D);
    for (let u = 0, f = 0, p, m; u < d && !((p = l[u]) && (n.s && (p = Rp(p, o, a, n.l)), i && p && r && (m = p.length, m <= i ? (i -= m, p = null) : (p = p.slice(i), i = 0)), p && (c[h++] = p, r && (f += p.length, f >= s)))); u++)
      ;
    if (h) {
      if (r)
        return S2(c, s, 0);
      t[t.length] = c;
      return;
    }
  }
  return !e && c;
}
function S2(n, t, e) {
  return n = n.length === 1 ? n[0] : [].concat.apply([], n), e || n.length > t ? n.slice(e, e + t) : n;
}
function Rp(n, t, e, s) {
  return e ? (s = s && t > e, n = (n = n[s ? t : e]) && n[s ? e : t]) : n = n[t], n;
}
Gt.contain = function(n) {
  return !!this.register[n];
};
Gt.update = function(n, t) {
  return this.remove(n).add(n, t);
};
Gt.remove = function(n, t) {
  const e = this.register[n];
  if (e) {
    if (this.m)
      for (let s = 0, i; s < e.length; s++)
        i = e[s], i.splice(i.indexOf(n), 1);
    else
      lc(this.map, n, this.D, this.s), this.depth && lc(this.h, n, this.A, this.s);
    if (t || delete this.register[n], this.cache) {
      t = this.cache;
      for (let s = 0, i, r; s < t.h.length; s++)
        r = t.h[s], i = t.cache[r], i.includes(n) && (t.h.splice(s--, 1), delete t.cache[r]);
    }
  }
  return this;
};
function lc(n, t, e, s, i) {
  let r = 0;
  if (n.constructor === Array)
    if (i)
      t = n.indexOf(t), t !== -1 ? 1 < n.length && (n.splice(t, 1), r++) : r++;
    else {
      i = Math.min(n.length, e);
      for (let o = 0, a; o < i; o++)
        (a = n[o]) && (r = lc(a, t, e, s, i), s || r || delete n[o]);
    }
  else
    for (let o in n)
      (r = lc(n[o], t, e, s, i)) || delete n[o];
  return r;
}
Gt.searchCache = b2;
Gt.export = function(n, t, e, s, i, r) {
  let o = !0;
  typeof r > "u" && (o = new Promise((l) => {
    r = l;
  }));
  let a, c;
  switch (i || (i = 0)) {
    case 0:
      if (a = "reg", this.m) {
        c = $t();
        for (let l in this.register)
          c[l] = 1;
      } else
        c = this.register;
      break;
    case 1:
      a = "cfg", c = { doc: 0, opt: this.s ? 1 : 0 };
      break;
    case 2:
      a = "map", c = this.map;
      break;
    case 3:
      a = "ctx", c = this.h;
      break;
    default:
      typeof e > "u" && r && r();
      return;
  }
  return w2(n, t || this, e, a, s, i, c, r), o;
};
Gt.import = function(n, t) {
  if (t)
    switch (ve(t) && (t = JSON.parse(t)), n) {
      case "cfg":
        this.s = !!t.opt;
        break;
      case "reg":
        this.m = !1, this.register = t;
        break;
      case "map":
        this.map = t;
        break;
      case "ctx":
        this.h = t;
    }
};
y2(oi.prototype);
function C9(n) {
  n = n.data;
  var t = self._index;
  const e = n.args;
  var s = n.task;
  switch (s) {
    case "init":
      s = n.options || {}, n = n.factory, t = s.encode, s.cache = !1, t && t.indexOf("function") === 0 && (s.encode = Function("return " + t)()), n ? (Function("return " + n)()(self), self._index = new self.FlexSearch.Index(s), delete self.FlexSearch) : self._index = new oi(s);
      break;
    default:
      n = n.id, t = t[s].apply(t, e), postMessage(s === "search" ? { id: n, msg: t } : { id: n });
  }
}
let $p = 0;
function lr(n) {
  if (!(this instanceof lr))
    return new lr(n);
  var t;
  n ? Bu(t = n.encode) && (n.encode = t.toString()) : n = {}, (t = (self || window)._factory) && (t = t.toString());
  const e = typeof window > "u" && self.exports, s = this;
  this.o = k9(t, e, n.worker), this.h = $t(), this.o && (e ? this.o.on("message", function(i) {
    s.h[i.id](i.msg), delete s.h[i.id];
  }) : this.o.onmessage = function(i) {
    i = i.data, s.h[i.id](i.msg), delete s.h[i.id];
  }, this.o.postMessage({ task: "init", factory: t, options: n }));
}
Jo("add");
Jo("append");
Jo("search");
Jo("update");
Jo("remove");
function Jo(n) {
  lr.prototype[n] = lr.prototype[n + "Async"] = function() {
    const t = this, e = [].slice.call(arguments);
    var s = e[e.length - 1];
    let i;
    return Bu(s) && (i = s, e.splice(e.length - 1, 1)), s = new Promise(function(r) {
      setTimeout(function() {
        t.h[++$p] = r, t.o.postMessage({ task: n, id: $p, args: e });
      });
    }), i ? (s.then(i), this) : s;
  };
}
function k9(n, t, e) {
  let s;
  try {
    s = t ? new m9.Worker(__dirname + "/node/node.js") : n ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + C9.toString()], { type: "text/javascript" }))) : new Worker(ve(e) ? e : "worker/worker.js", { type: "module" });
  } catch {
  }
  return s;
}
function Oo(n) {
  if (!(this instanceof Oo))
    return new Oo(n);
  var t = n.document || n.doc || n, e;
  this.K = [], this.h = [], this.A = [], this.register = $t(), this.key = (e = t.key || t.id) && pa(e, this.A) || "id", this.m = Na(n.fastupdate), this.C = (e = t.store) && e !== !0 && [], this.store = e && $t(), this.I = (e = t.tag) && pa(e, this.A), this.l = e && $t(), this.cache = (e = n.cache) && new Zc(e), n.cache = !1, this.o = n.worker, this.async = !1, e = $t();
  let s = t.index || t.field || t;
  ve(s) && (s = [s]);
  for (let i = 0, r, o; i < s.length; i++)
    r = s[i], ve(r) || (o = r, r = r.field), o = wn(o) ? Object.assign({}, n, o) : n, this.o && (e[r] = new lr(o), e[r].o || (this.o = !1)), this.o || (e[r] = new oi(o, this.register)), this.K[i] = pa(r, this.A), this.h[i] = r;
  if (this.C)
    for (n = t.store, ve(n) && (n = [n]), t = 0; t < n.length; t++)
      this.C[t] = pa(n[t], this.A);
  this.index = e;
}
function pa(n, t) {
  const e = n.split(":");
  let s = 0;
  for (let i = 0; i < e.length; i++)
    n = e[i], 0 <= n.indexOf("[]") && (n = n.substring(0, n.length - 2)) && (t[s] = !0), n && (e[s++] = n);
  return s < e.length && (e.length = s), 1 < s ? e : e[0];
}
function cd(n, t) {
  if (ve(t))
    n = n[t];
  else
    for (let e = 0; n && e < t.length; e++)
      n = n[t[e]];
  return n;
}
function ld(n, t, e, s, i) {
  if (n = n[i], s === e.length - 1)
    t[i] = n;
  else if (n)
    if (n.constructor === Array)
      for (t = t[i] = Array(n.length), i = 0; i < n.length; i++)
        ld(n, t, e, s, i);
    else
      t = t[i] || (t[i] = $t()), i = e[++s], ld(n, t, e, s, i);
}
function hd(n, t, e, s, i, r, o, a) {
  if (n = n[o])
    if (s === t.length - 1) {
      if (n.constructor === Array) {
        if (e[s]) {
          for (t = 0; t < n.length; t++)
            i.add(r, n[t], !0, !0);
          return;
        }
        n = n.join(" ");
      }
      i.add(r, n, a, !0);
    } else if (n.constructor === Array)
      for (o = 0; o < n.length; o++)
        hd(n, t, e, s, i, r, o, a);
    else
      o = t[++s], hd(n, t, e, s, i, r, o, a);
}
Gt = Oo.prototype;
Gt.add = function(n, t, e) {
  if (wn(n) && (t = n, n = cd(t, this.key)), t && (n || n === 0)) {
    if (!e && this.register[n])
      return this.update(n, t);
    for (let s = 0, i, r; s < this.h.length; s++)
      r = this.h[s], i = this.K[s], ve(i) && (i = [i]), hd(t, i, this.A, 0, this.index[r], n, i[0], e);
    if (this.I) {
      let s = cd(t, this.I), i = $t();
      ve(s) && (s = [s]);
      for (let r = 0, o, a; r < s.length; r++)
        if (o = s[r], !i[o] && (i[o] = 1, a = this.l[o] || (this.l[o] = []), !e || !a.includes(n)) && (a[a.length] = n, this.m)) {
          const c = this.register[n] || (this.register[n] = []);
          c[c.length] = a;
        }
    }
    if (this.store && (!e || !this.store[n])) {
      let s;
      if (this.C) {
        s = $t();
        for (let i = 0, r; i < this.C.length; i++)
          r = this.C[i], ve(r) ? s[r] = t[r] : ld(t, s, r, 0, r[0]);
      }
      this.store[n] = s || t;
    }
  }
  return this;
};
Gt.append = function(n, t) {
  return this.add(n, t, !0);
};
Gt.update = function(n, t) {
  return this.remove(n).add(n, t);
};
Gt.remove = function(n) {
  if (wn(n) && (n = cd(n, this.key)), this.register[n]) {
    for (var t = 0; t < this.h.length && (this.index[this.h[t]].remove(n, !this.o), !this.m); t++)
      ;
    if (this.I && !this.m)
      for (let e in this.l) {
        t = this.l[e];
        const s = t.indexOf(n);
        s !== -1 && (1 < t.length ? t.splice(s, 1) : delete this.l[e]);
      }
    this.store && delete this.store[n], delete this.register[n];
  }
  return this;
};
Gt.search = function(n, t, e, s) {
  e || (!t && wn(n) ? (e = n, n = "") : wn(t) && (e = t, t = 0));
  let i = [], r = [], o, a, c, l, h, d, u = 0;
  if (e)
    if (e.constructor === Array)
      c = e, e = null;
    else {
      if (n = e.query || n, c = (o = e.pluck) || e.index || e.field, l = e.tag, a = this.store && e.enrich, h = e.bool === "and", t = e.limit || t || 100, d = e.offset || 0, l && (ve(l) && (l = [l]), !n)) {
        for (let p = 0, m; p < l.length; p++)
          (m = x9.call(this, l[p], t, d, a)) && (i[i.length] = m, u++);
        return u ? i : [];
      }
      ve(c) && (c = [c]);
    }
  c || (c = this.h), h = h && (1 < c.length || l && 1 < l.length);
  const f = !s && (this.o || this.async) && [];
  for (let p = 0, m, _, v; p < c.length; p++) {
    let b;
    if (_ = c[p], ve(_) || (b = _, _ = b.field, n = b.query || n, t = b.limit || t, a = b.enrich || a), f)
      f[p] = this.index[_].searchAsync(n, t, b || e);
    else {
      if (s ? m = s[p] : m = this.index[_].search(n, t, b || e), v = m && m.length, l && v) {
        const g = [];
        let y = 0;
        h && (g[0] = [m]);
        for (let S = 0, w, k; S < l.length; S++)
          w = l[S], (v = (k = this.l[w]) && k.length) && (y++, g[g.length] = h ? [k] : k);
        y && (m = h ? v2(g, t || 100, d || 0) : w9(m, g), v = m.length);
      }
      if (v)
        r[u] = _, i[u++] = m;
      else if (h)
        return [];
    }
  }
  if (f) {
    const p = this;
    return new Promise(function(m) {
      Promise.all(f).then(function(_) {
        m(p.search(
          n,
          t,
          e,
          _
        ));
      });
    });
  }
  if (!u)
    return [];
  if (o && (!a || !this.store))
    return i[0];
  for (let p = 0, m; p < r.length; p++) {
    if (m = i[p], m.length && a && (m = C2.call(this, m)), o)
      return m;
    i[p] = { field: r[p], result: m };
  }
  return i;
};
function x9(n, t, e, s) {
  let i = this.l[n], r = i && i.length - e;
  if (r && 0 < r)
    return (r > t || e) && (i = i.slice(e, e + t)), s && (i = C2.call(this, i)), { tag: n, result: i };
}
function C2(n) {
  const t = Array(n.length);
  for (let e = 0, s; e < n.length; e++)
    s = n[e], t[e] = { id: s, doc: this.store[s] };
  return t;
}
Gt.contain = function(n) {
  return !!this.register[n];
};
Gt.get = function(n) {
  return this.store[n];
};
Gt.set = function(n, t) {
  return this.store[n] = t, this;
};
Gt.searchCache = b2;
Gt.export = function(n, t, e, s, i, r) {
  let o;
  if (typeof r > "u" && (o = new Promise((a) => {
    r = a;
  })), i || (i = 0), s || (s = 0), s < this.h.length) {
    const a = this.h[s], c = this.index[a];
    t = this, setTimeout(function() {
      c.export(n, t, i ? a : "", s, i++, r) || (s++, i = 1, t.export(n, t, a, s, i, r));
    });
  } else {
    let a, c;
    switch (i) {
      case 1:
        a = "tag", c = this.l, e = null;
        break;
      case 2:
        a = "store", c = this.store, e = null;
        break;
      default:
        r();
        return;
    }
    w2(n, this, e, a, s, i, c, r);
  }
  return o;
};
Gt.import = function(n, t) {
  if (t)
    switch (ve(t) && (t = JSON.parse(t)), n) {
      case "tag":
        this.l = t;
        break;
      case "reg":
        this.m = !1, this.register = t;
        for (let s = 0, i; s < this.h.length; s++)
          i = this.index[this.h[s]], i.register = t, i.m = !1;
        break;
      case "store":
        this.store = t;
        break;
      default:
        n = n.split(".");
        const e = n[0];
        n = n[1], e && n && this.index[e].import(n, t);
    }
};
y2(Oo.prototype);
var E9 = { encode: k2, F: !1, G: "" };
const T9 = [Wt("[]"), "a", Wt("[]"), "e", Wt("[]"), "i", Wt("[]"), "o", Wt("[]"), "u", Wt("[]"), "y", Wt(""), "n", Wt("[c]"), "k", Wt(""), "s", Wt(" & "), " and "];
function k2(n) {
  var t = n = "" + n;
  return t.normalize && (t = t.normalize("NFD").replace(v9, "")), p2.call(this, t.toLowerCase(), !n.normalize && T9);
}
var A9 = { encode: x2, F: !1, G: "strict" };
const I9 = /[^a-z0-9]+/, Np = { b: "p", v: "f", w: "f", z: "s", x: "s", : "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" };
function x2(n) {
  n = k2.call(this, n).join(" ");
  const t = [];
  if (n) {
    const e = n.split(I9), s = e.length;
    for (let i = 0, r, o = 0; i < s; i++)
      if ((n = e[i]) && (!this.filter || !this.filter[n])) {
        r = n[0];
        let a = Np[r] || r, c = a;
        for (let l = 1; l < n.length; l++) {
          r = n[l];
          const h = Np[r] || r;
          h && h !== c && (a += h, c = h);
        }
        t[o++] = a;
      }
  }
  return t;
}
var O9 = { encode: E2, F: !1, G: "" };
const D9 = [Wt("ae"), "a", Wt("oe"), "o", Wt("sh"), "s", Wt("th"), "t", Wt("ph"), "f", Wt("pf"), "f", Wt("(?![aeo])h(?![aeo])"), "", Wt("(?!^[aeo])h(?!^[aeo])"), ""];
function E2(n, t) {
  return n && (n = x2.call(this, n).join(" "), 2 < n.length && (n = La(n, D9)), t || (1 < n.length && (n = g2(n)), n && (n = n.split(" ")))), n || [];
}
var P9 = { encode: R9, F: !1, G: "" };
const M9 = Wt("(?!\\b)[aeo]");
function R9(n) {
  return n && (n = E2.call(this, n, !0), 1 < n.length && (n = n.replace(M9, "")), 1 < n.length && (n = g2(n)), n && (n = n.split(" "))), n || [];
}
mi["latin:default"] = b9;
mi["latin:simple"] = E9;
mi["latin:balance"] = A9;
mi["latin:advanced"] = O9;
mi["latin:extra"] = P9;
const T2 = { Index: oi, Document: Oo, Worker: lr, registerCharset: function(n, t) {
  mi[n] = t;
}, registerLanguage: function(n, t) {
  _2[n] = t;
} }, $9 = T2.Document, N9 = T2.Index;
function L9(n) {
  const t = Intl.Segmenter;
  if (t) {
    const e = new N9({ charset: "latin:advanced" }), s = e.encode.bind(e), i = /^[\p{Script=Latin}\p{Mark}\d]+$/u, r = new t([n], { granularity: "word" });
    return (o) => {
      const a = [];
      return [...Array.from(r.segment(o)).filter((l) => {
        if (l.isWordLike) {
          if (!i.test(l.segment))
            return !0;
          a.push(l.segment);
        }
        return !1;
      }).map((l) => l.segment), ...s(a.join(" "))];
    };
  }
  return (e) => e.replace(/[\x00-\x7F]/g, "").split("");
}
const U9 = 200;
class F9 {
  constructor(t, e = "en-US") {
    this._reindexMap = null, this._reindex = () => {
      if (this._reindexMap) {
        for (const s of this._reindexMap.keys()) {
          const i = this._reindexMap.get(s);
          i && (this._reindexMap.delete(s), this._indexer.add(s, i));
        }
        setTimeout(() => {
          this._reindexMap && (globalThis.requestIdleCallback !== void 0 ? requestIdleCallback(this._reindex, { timeout: 1e3 }) : setTimeout(this._reindex, 1e3));
        }, U9);
      }
    }, this._doc = t, this._indexer = new $9({
      document: {
        id: "id",
        index: ["content", "reference", "space"],
        tag: "tags",
        store: ["space", "content"]
      },
      encode: L9(e),
      tokenize: "forward",
      context: !0
    }), this._reindexMap = /* @__PURE__ */ new Map(), this._reindex(), t.spaces.observe((s) => {
      s.keysChanged.forEach((i) => {
        const r = this._getDoc(i);
        r != null && this._handleDocIndexing(i, r);
      });
    }), Fu && window.addEventListener("beforeunload", () => {
      this._reindexMap = null;
    }), f9 && process.on("exit", () => {
      this._reindexMap = null;
    });
  }
  search(t) {
    return new Map(this._search(t).flatMap(({ result: e }) => e.map((s) => [s.id, { space: s.doc.space, content: s.doc.content }])));
  }
  _search(t) {
    return typeof t == "object" ? this._indexer.search({
      ...t,
      enrich: !0
    }) : this._indexer.search(t, {
      enrich: !0
    });
  }
  refreshDocIndex(t, e) {
    const s = e.getMap("blocks");
    s.forEach((i, r) => {
      this._refreshIndex(t, r, "add", s.get(r));
    });
  }
  _handleDocIndexing(t, e) {
    if (!e)
      return;
    const s = e.getMap("blocks");
    this.refreshDocIndex(t, e), s.observeDeep((i) => {
      const r = i.flatMap((o) => {
        var a;
        return (((a = o.path) == null ? void 0 : a.length) | 0) > 0 ? [[o.path[0], "update"]] : Array.from(o.changes.keys.entries()).map(([c, { action: l }]) => [c, l]);
      });
      r.length && r.forEach(([o, a]) => {
        this._refreshIndex(t, o, a, s.get(o));
      });
    });
  }
  _refreshIndex(t, e, s, i) {
    var r, o;
    switch (s) {
      case "add":
      case "update": {
        if (i) {
          const a = this._toContent(i.get("prop:title") || i.get("prop:text"));
          a && ((r = this._reindexMap) == null || r.set(e, {
            content: a,
            space: t,
            tags: [t]
          }));
        }
        break;
      }
      case "delete": {
        (o = this._reindexMap) == null || o.delete(e), this._indexer.remove(e);
        break;
      }
    }
  }
  _toContent(t) {
    if (t) {
      if (typeof t == "string")
        return t;
      if (t instanceof pe)
        return t.toJSON();
    }
  }
  _getDoc(t) {
    try {
      return this._doc.spaces.get(t);
    } catch {
      return;
    }
  }
}
const B9 = (n) => class extends n {
  search(t) {
    return this.indexer.search.search(t);
  }
  constructor(t) {
    super(t);
    const e = new u9(this.doc, { slots: this.slots });
    this.indexer = {
      search: new F9(this.doc),
      backlink: new d9(e)
    };
  }
}, dd = Symbol.for("react.test.json");
function V9(n) {
  return !(typeof n != "object" || n === null);
}
const j9 = [
  "sys:id",
  "sys:version",
  "sys:flavour",
  "sys:children",
  "prop:xywh",
  "prop:cells",
  "prop:elements"
];
function A2(n, t) {
  if (!V9(n))
    throw new Error("Failed to parse doc record! Invalid data.");
  const e = n[t];
  if (!e)
    throw new Error(`Failed to parse doc record! Node not found! id: ${t}.`);
  const s = e["sys:flavour"], i = e["sys:children"], r = Object.fromEntries(Object.entries(e).filter(([o]) => !j9.includes(o)));
  return "prop:text" in r && r["prop:text"] instanceof Array && (r["prop:text"] = Lp(r["prop:text"])), "prop:title" in r && r["prop:title"] instanceof Array && (r["prop:title"] = Lp(r["prop:title"])), "prop:columns" in r && r["prop:columns"] instanceof Array && (r["prop:columns"] = `Array [${r["prop:columns"].length}]`), "prop:views" in r && r["prop:views"] instanceof Array && (r["prop:views"] = `Array [${r["prop:views"].length}]`), {
    $$typeof: dd,
    type: s,
    props: r,
    children: (i == null ? void 0 : i.map((o) => A2(n, o))) ?? []
  };
}
function I2(n) {
  const t = {};
  return n.share.forEach((e, s) => {
    e instanceof ne ? t[s] = D2(e) : t[s] = e.toJSON();
  }), t;
}
function O2(n) {
  return n instanceof Tn ? I2(n) : n instanceof ne ? D2(n) : n instanceof pe ? G9(n) : n instanceof de ? n.toArray().map((t) => O2(t)) : n instanceof se ? n.toJSON() : n;
}
function D2(n) {
  const t = {};
  return n.forEach((e, s) => {
    t[s] = O2(e);
  }), t;
}
function G9(n) {
  return n.toDelta();
}
function Lp(n) {
  if (n.length)
    return n.length === 1 && !n[0].attributes ? n[0].insert : {
      // The `Symbol.for('react.fragment')` will render as `<React.Fragment>`
      // so we use a empty string to render it as `<>`.
      // But it will empty children ad `< />`
      // so we return `undefined` directly if not delta text.
      $$typeof: dd,
      // Symbol.for('react.element'),
      type: "",
      // Symbol.for('react.fragment'),
      props: {},
      children: n == null ? void 0 : n.map(({ insert: t, attributes: e }) => ({
        $$typeof: dd,
        type: "text",
        props: {
          // Not place at `children` to avoid the trailing whitespace be trim by formatter.
          insert: t,
          ...e
        }
      }))
    };
}
const H9 = (n) => class extends n {
  /** @internal Only for testing */
  exportJSX(t, e = ((s) => (s = this.meta.docMetas.at(0)) == null ? void 0 : s.id)()) {
    B(e);
    const i = this.doc.spaces.get(e);
    B(i);
    const r = I2(i);
    if (!r)
      throw new Error(`Doc ${e} doesn't exist`);
    const o = r.blocks;
    if (!t) {
      const a = Object.keys(o).at(0);
      if (!a)
        return null;
      t = a;
    }
    return o[t] ? A2(o, t) : null;
  }
};
class z9 {
}
class W9 {
  constructor(t, e, s) {
    this._onLoadSlot = new lt(), this._initSubDoc = () => {
      let i = this.rootDoc.spaces.get(this.id);
      return i ? (this._loaded = !1, this.rootDoc.on("subdocs", this._onSubdocEvent)) : (i = new Tn({
        guid: this.id
      }), this.rootDoc.spaces.set(this.id, i), this._loaded = !0, this._onLoadSlot.emit()), i;
    }, this._onSubdocEvent = ({ loaded: i }) => {
      Array.from(i).find((o) => o.guid === this._ySpaceDoc.guid) && (this.rootDoc.off("subdocs", this._onSubdocEvent), this._loaded = !0, this._onLoadSlot.emit());
    }, this.id = t, this.rootDoc = e, this.awarenessStore = s, this._ySpaceDoc = this._initSubDoc(), this._yBlocks = this._ySpaceDoc.getMap("blocks");
  }
  get yBlocks() {
    return this._yBlocks;
  }
  get loaded() {
    return this._loaded;
  }
  get spaceDoc() {
    return this._ySpaceDoc;
  }
  load() {
    return this._ySpaceDoc.load(), this;
  }
  remove() {
    this.destroy(), this.rootDoc.spaces.delete(this.id);
  }
  destroy() {
    this._ySpaceDoc.destroy(), this._onLoadSlot.dispose(), this._loaded = !1;
  }
  clear() {
    this._yBlocks.clear();
  }
  /**
   * If `shouldTransact` is `false`, the transaction will not be push to the history stack.
   */
  transact(t, e = !0) {
    this._ySpaceDoc.transact(t, e ? this.rootDoc.clientID : null);
  }
}
class K9 {
  constructor(t, e) {
    this._yBlocks = t, this._schema = e;
  }
  get root() {
    let t = null;
    return this._yBlocks.forEach((e) => {
      const s = e.get("sys:flavour"), i = this._schema.flavourSchemaMap.get(s);
      i && i.model.role === "root" && (t = e.get("sys:id"));
    }), t;
  }
  getParent(t) {
    const e = this.root;
    if (!e || e === t)
      return null;
    const s = (i) => {
      const r = this._yBlocks.get(i);
      if (!r)
        return null;
      const o = r.get("sys:children");
      for (const a of o.toArray()) {
        if (a === t)
          return i;
        const c = s(a);
        if (c != null)
          return c;
      }
      return null;
    };
    return s(e);
  }
  addBlock(t, e, s = {}, i, r) {
    var v, b, g, y;
    const o = this._schema.flavourSchemaMap.get(e);
    B(o, `Could not find schema for flavour ${e}`);
    const a = i ? (v = this._yBlocks.get(i)) == null ? void 0 : v.get("sys:flavour") : void 0;
    this._schema.validate(e, a);
    const c = new ne();
    this._yBlocks.set(t, c);
    const l = o.version, h = (b = s.children) == null ? void 0 : b.map((S) => typeof S == "string" ? S : S.id);
    c.set("sys:id", t), c.set("sys:flavour", e), c.set("sys:version", l), c.set("sys:children", de.from(h ?? []));
    const u = {
      ...((y = (g = o.model).props) == null ? void 0 : y.call(g, Kc)) ?? {},
      ...s
    };
    delete u.id, delete u.flavour, delete u.children, Object.entries(u).forEach(([S, w]) => {
      w !== void 0 && c.set(`prop:${S}`, _n(w));
    });
    const f = i ?? (o.model.role === "root" ? null : this.root);
    if (!f)
      return;
    const p = this._yBlocks.get(f);
    if (!p)
      return;
    const m = p.get("sys:children"), _ = r ?? m.length;
    m.insert(_, [t]);
  }
  deleteBlock(t, e = {
    deleteChildren: !0
  }) {
    const { bringChildrenTo: s, deleteChildren: i } = e;
    if (s && i) {
      console.error("Cannot bring children to another block and delete them at the same time");
      return;
    }
    const r = this._yBlocks.get(t);
    if (!r)
      return;
    const o = r.get("sys:children"), a = this.getParent(t);
    if (!a)
      return;
    const l = this._yBlocks.get(a).get("sys:children"), h = l.toArray().indexOf(t);
    h > -1 && l.delete(h, 1), (() => {
      if (s) {
        (() => {
          B(s);
          const f = this._yBlocks.get(s);
          if (!f)
            return;
          const p = f.get("sys:flavour");
          if (o.forEach((v) => {
            const b = this._yBlocks.get(v);
            b && this._schema.validate(b.get("sys:flavour"), p);
          }), s === a) {
            l.insert(h, o.toArray());
            return;
          }
          const m = this._yBlocks.get(s);
          if (!m)
            return;
          m.get("sys:children").push(o.toArray());
        })();
        return;
      }
      if (i) {
        const u = (f) => {
          this._yBlocks.get(f).get("sys:children").forEach((_) => u(_)), this._yBlocks.delete(f);
        };
        o.forEach((f) => u(f));
      }
    })(), this._yBlocks.delete(t);
  }
  updateBlockChildren(t, e) {
    const s = this._yBlocks.get(t);
    if (!s)
      return;
    const i = de.from(e);
    s.set("sys:children", i);
  }
  moveBlocks(t, e, s = null, i = !0) {
    const r = /* @__PURE__ */ new Map(), o = this._yBlocks.get(e);
    if (!o)
      return;
    const a = o.get("sys:flavour");
    t.forEach((l) => {
      const h = this.getParent(l);
      if (!h)
        return;
      const d = this._yBlocks.get(l);
      if (!d)
        return;
      this._schema.validate(d.get("sys:flavour"), a);
      const u = r.get(h);
      if (!u) {
        r.set(h, [l]);
        return;
      }
      const f = u[u.length - 1];
      if (this.getNext(f) !== l)
        throw new Error("The blocks to move are not contiguous under their parent");
      u.push(l);
    });
    let c = 0;
    Array.from(r.entries()).forEach(([l, h], d) => {
      const u = this._yBlocks.get(e);
      if (!u)
        return;
      const f = u.get("sys:children"), p = this._yBlocks.get(l);
      if (!p)
        return;
      const m = p.get("sys:children"), _ = m.toArray().findIndex((b) => b === h[0]);
      m.delete(_, h.length), (() => {
        if (!(d === 0)) {
          c++;
          return;
        }
        if (!s) {
          c = f.length;
          return;
        }
        const g = f.toArray().findIndex((y) => y === s);
        if (g === -1)
          throw new Error("Target sibling not found");
        c = i ? g : g + 1;
      })(), f.insert(c, h);
    });
  }
  _getSiblings(t, e) {
    const s = this.getParent(t);
    if (!s)
      return null;
    const i = this._yBlocks.get(s);
    if (!i)
      return null;
    const o = i.get("sys:children").toArray().indexOf(t);
    return o === -1 ? null : e(o, i);
  }
  getNext(t) {
    return this._getSiblings(t, (e, s) => s.get("sys:children").toArray().at(e + 1) ?? null);
  }
  getPrev(t) {
    return this._getSiblings(t, (e, s) => s.get("sys:children").toArray().at(e - 1) ?? null);
  }
}
function Y9(n, t, e, s) {
  var r, o;
  const i = ((o = (r = n.model).props) == null ? void 0 : o.call(r, Kc)) ?? {};
  Object.entries(s).forEach(([a, c]) => {
    i3.has(a) || c !== void 0 && (t[a] = c);
  }), Object.entries(i).forEach(([a, c]) => {
    (!e.has(`prop:${a}`) || e.get(`prop:${a}`) === void 0) && (t[a] = _n(c));
  });
}
class Z9 {
  constructor({ schema: t, blockCollection: e, crud: s, selector: i }) {
    this._blocks = /* @__PURE__ */ new Map(), this._blockCollection = e, this._crud = s, this._schema = t, this._selector = i, this._yBlocks.forEach((r, o) => {
      this._blocks.has(o) || this._onBlockAdded(o);
    }), this._disposeBlockUpdated = this._blockCollection.slots.yBlockUpdated.on(({ type: r, id: o }) => {
      switch (r) {
        case "add": {
          this._onBlockAdded(o);
          return;
        }
        case "delete": {
          this._onBlockRemoved(o);
          return;
        }
      }
    });
  }
  dispose() {
    this._disposeBlockUpdated.dispose();
  }
  get blockCollection() {
    return this._blockCollection;
  }
  get readonly() {
    return this._blockCollection.readonly;
  }
  get schema() {
    return this._schema;
  }
  get ready() {
    return this._blockCollection.ready;
  }
  get history() {
    return this._blockCollection.history;
  }
  get collection() {
    return this._blockCollection.collection;
  }
  get meta() {
    return this._blockCollection.meta;
  }
  get blob() {
    return this._blockCollection.blob;
  }
  get isEmpty() {
    return this._blocks.size === 0;
  }
  get canUndo() {
    return this._blockCollection.canUndo;
  }
  get canRedo() {
    return this._blockCollection.canRedo;
  }
  get undo() {
    return this._blockCollection.undo.bind(this._blockCollection);
  }
  get redo() {
    return this._blockCollection.redo.bind(this._blockCollection);
  }
  get root() {
    var e;
    const t = this._crud.root;
    return t ? ((e = this.getBlock(t)) == null ? void 0 : e.model) ?? null : null;
  }
  get id() {
    return this._blockCollection.id;
  }
  get Text() {
    return this._blockCollection.Text;
  }
  get spaceDoc() {
    return this._blockCollection.spaceDoc;
  }
  get rootDoc() {
    return this._blockCollection.rootDoc;
  }
  get slots() {
    return this._blockCollection.slots;
  }
  get awarenessStore() {
    return this._blockCollection.awarenessStore;
  }
  get loaded() {
    return this._blockCollection.loaded;
  }
  get transact() {
    return this._blockCollection.transact.bind(this._blockCollection);
  }
  get resetHistory() {
    return this._blockCollection.resetHistory.bind(this._blockCollection);
  }
  get captureSync() {
    return this._blockCollection.captureSync.bind(this._blockCollection);
  }
  get withoutTransact() {
    return this._blockCollection.withoutTransact.bind(this._blockCollection);
  }
  get generateBlockId() {
    return this._blockCollection.generateBlockId.bind(this._blockCollection);
  }
  get clear() {
    return this._blockCollection.clear.bind(this._blockCollection);
  }
  getSchemaByFlavour(t) {
    return this._schema.flavourSchemaMap.get(t);
  }
  load(t) {
    return this._blockCollection.load(t), this;
  }
  hasBlock(t) {
    return this._blocks.has(t);
  }
  /**
   * @deprecated
   * Use `hasBlock` instead.
   */
  hasBlockById(t) {
    return this.hasBlock(t);
  }
  getBlock(t) {
    return this._blocks.get(t);
  }
  /**
   * @deprecated
   * Use `getBlock` instead.
   */
  getBlockById(t) {
    var e;
    return ((e = this.getBlock(t)) == null ? void 0 : e.model) ?? null;
  }
  /**
   * @deprecated
   * Use `getBlocksByFlavour` instead.
   */
  getBlockByFlavour(t) {
    return this.getBlocksByFlavour(t).map((e) => e.model);
  }
  getBlocksByFlavour(t) {
    const e = typeof t == "string" ? [t] : t;
    return Array.from(this._blocks.values()).filter(({ flavour: s }) => e.includes(s));
  }
  getParent(t) {
    const e = typeof t == "string" ? t : t.id, s = this._crud.getParent(e);
    if (!s)
      return null;
    const i = this._blocks.get(s);
    return i ? i.model : null;
  }
  getPrev(t) {
    return this._getSiblings(t, (e, s) => e.children[s - 1] ?? null);
  }
  getPrevs(t) {
    return this._getSiblings(t, (e, s) => e.children.slice(0, s)) ?? [];
  }
  getNext(t) {
    return this._getSiblings(t, (e, s) => e.children[s + 1] ?? null);
  }
  getNexts(t) {
    return this._getSiblings(t, (e, s) => e.children.slice(s + 1)) ?? [];
  }
  getBlocks() {
    return Array.from(this._blocks.values()).map((t) => t.model);
  }
  get blocks() {
    return this._blocks;
  }
  get _yBlocks() {
    return this._blockCollection.yBlocks;
  }
  _getSiblings(t, e) {
    var o;
    const s = this.getParent(t);
    if (!s)
      return null;
    const i = typeof t == "string" ? (o = this.getBlock(t)) == null ? void 0 : o.model : t;
    if (!i)
      return null;
    const r = s.children.indexOf(i);
    return r === -1 ? null : e(s, r);
  }
  _onBlockAdded(t) {
    if (this._blocks.has(t))
      return;
    const e = this._yBlocks.get(t);
    if (!e) {
      console.warn(`Could not find block with id ${t}`);
      return;
    }
    const s = {
      onChange: (o, a) => {
        a && o.model.propsUpdated.emit({ key: a }), this._blockCollection.slots.blockUpdated.emit({
          type: "update",
          id: t,
          flavour: o.flavour,
          props: { key: a }
        });
      }
    }, i = new f2(this._schema, e, this, s);
    this._selector(i, this) && (this._blocks.set(t, i), i.model.created.emit(), i.model.role === "root" && this._blockCollection.slots.rootAdded.emit(t), this.slots.blockUpdated.emit({
      type: "add",
      id: t,
      flavour: i.model.flavour,
      model: i.model
    }));
  }
  _onBlockRemoved(t) {
    var s;
    const e = this.getBlock(t);
    e && (e.model.role === "root" && this._blockCollection.slots.rootDeleted.emit(t), this.slots.blockUpdated.emit({
      type: "delete",
      id: t,
      flavour: e.model.flavour,
      parent: ((s = this.getParent(e.model)) == null ? void 0 : s.id) ?? "",
      model: e.model
    }), e.model.dispose(), this._blocks.delete(t), e.model.deleted.emit());
  }
  addBlocks(t, e, s) {
    const i = [];
    return t.forEach((r) => {
      const o = this.addBlock(r.flavour, r.blockProps ?? {}, e, s);
      i.push(o), typeof s == "number" && s++;
    }), i;
  }
  addBlock(t, e = {}, s, i) {
    if (this.readonly)
      throw new Error("cannot modify data in readonly mode");
    const r = e.id ?? this._blockCollection.generateBlockId();
    return this.transact(() => {
      this._crud.addBlock(r, t, { ...e }, typeof s == "string" ? s : s == null ? void 0 : s.id, i);
    }), r;
  }
  moveBlocks(t, e, s = null, i = !0) {
    if (this.readonly) {
      console.error("Cannot modify data in read-only mode");
      return;
    }
    this.transact(() => {
      this._crud.moveBlocks(t.map((r) => r.id), e.id, (s == null ? void 0 : s.id) ?? null, i);
    });
  }
  updateBlock(t, e) {
    var r;
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    const s = typeof e == "function";
    if (!s) {
      const o = this.getParent(t);
      this.schema.validate(t.flavour, o == null ? void 0 : o.flavour, (r = e.children) == null ? void 0 : r.map((a) => a.flavour));
    }
    const i = this._yBlocks.get(t.id);
    B(i), this.transact(() => {
      if (s) {
        e();
        return;
      }
      e.children && this._crud.updateBlockChildren(t.id, e.children.map((a) => a.id));
      const o = this.schema.flavourSchemaMap.get(t.flavour);
      B(o), Y9(o, t, i, e);
    });
  }
  addSiblingBlocks(t, e, s = "after") {
    if (!e.length)
      return [];
    const i = this.getParent(t);
    B(i);
    const r = i.children.findIndex(({ id: c }) => c === t.id) ?? 0, o = s === "before" ? r : r + 1;
    if (e.length <= 1) {
      B(e[0].flavour);
      const { flavour: c, ...l } = e[0];
      return [this.addBlock(c, l, i.id, o)];
    }
    const a = [];
    return e.forEach((c) => {
      const { flavour: l, ...h } = c;
      B(l), a.push({ flavour: l, blockProps: h });
    }), this.addBlocks(a, i.id, o);
  }
  deleteBlock(t, e = {
    deleteChildren: !0
  }) {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    const s = e && e.bringChildrenTo ? {
      ...e,
      bringChildrenTo: e.bringChildrenTo.id
    } : e;
    this.transact(() => {
      this._crud.deleteBlock(t.id, s);
    });
  }
}
const P2 = () => !0;
class q9 extends W9 {
  constructor({ id: t, collection: e, doc: s, awarenessStore: i, idGenerator: r = du }) {
    super(t, s, i), this._ready = !1, this._shouldTransact = !0, this._docMap = /* @__PURE__ */ new Map(), this.slots = {
      /** This is always triggered after `doc.load` is called. */
      ready: new lt(),
      historyUpdated: new lt(),
      /**
       * This fires when the root block is added via API call or has just been initialized from existing ydoc.
       * useful for internal block UI components to start subscribing following up events.
       * Note that at this moment, the whole block tree may not be fully initialized yet.
       */
      rootAdded: new lt(),
      rootDeleted: new lt(),
      yBlockUpdated: new lt(),
      blockUpdated: new lt()
    }, this._historyObserver = () => {
      this.slots.historyUpdated.emit();
    }, this._handleYEvents = (o) => {
      o.forEach((a) => this._handleYEvent(a));
    }, this._collection = e, this._idGenerator = r, this._docCRUD = new K9(this._yBlocks, e.schema);
  }
  getDoc(t = P2) {
    if (this._docMap.has(t))
      return this._docMap.get(t);
    const e = new Z9({
      blockCollection: this,
      crud: this._docCRUD,
      schema: this.collection.schema,
      selector: t
    });
    return this._docMap.set(t, e), e;
  }
  clearSelector(t) {
    this._docMap.delete(t);
  }
  get readonly() {
    return this.awarenessStore.isReadonly(this);
  }
  get ready() {
    return this._ready;
  }
  get history() {
    return this._history;
  }
  get crud() {
    return this._docCRUD;
  }
  get collection() {
    return this._collection;
  }
  get schema() {
    return this.collection.schema;
  }
  get meta() {
    return this.collection.meta.getDocMeta(this.id);
  }
  get blob() {
    return this.collection.blob;
  }
  get isEmpty() {
    return this._yBlocks.size === 0;
  }
  get canUndo() {
    return this.readonly ? !1 : this._history.canUndo();
  }
  get canRedo() {
    return this.readonly ? !1 : this._history.canRedo();
  }
  get Text() {
    return vr;
  }
  withoutTransact(t) {
    this._shouldTransact = !1, t(), this._shouldTransact = !0;
  }
  transact(t, e = this._shouldTransact) {
    super.transact(t, e);
  }
  undo() {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    this._history.undo();
  }
  redo() {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    this._history.redo();
  }
  /** Capture current operations to undo stack synchronously. */
  captureSync() {
    this._history.stopCapturing();
  }
  resetHistory() {
    this._history.clear();
  }
  generateBlockId() {
    return this._idGenerator();
  }
  load(t) {
    var e;
    return this.ready ? this : (super.load(), (((e = this.collection.meta.docs) == null ? void 0 : e.length) ?? 0) <= 1 && this._handleVersion(), this._initYBlocks(), this._yBlocks.forEach((s, i) => {
      this._handleYBlockAdd(i);
    }), t == null || t(), this._ready = !0, this.slots.ready.emit(), this);
  }
  dispose() {
    this.slots.historyUpdated.dispose(), this.slots.rootAdded.dispose(), this.slots.rootDeleted.dispose(), this.slots.blockUpdated.dispose(), this.ready && (this._yBlocks.unobserveDeep(this._handleYEvents), this._yBlocks.clear());
  }
  _initYBlocks() {
    const { _yBlocks: t } = this;
    t.observeDeep(this._handleYEvents), this._history = new ku([t], {
      trackedOrigins: /* @__PURE__ */ new Set([this._ySpaceDoc.clientID])
    }), this._history.on("stack-cleared", this._historyObserver), this._history.on("stack-item-added", this._historyObserver), this._history.on("stack-item-popped", this._historyObserver), this._history.on("stack-item-updated", this._historyObserver);
  }
  _handleYBlockAdd(t) {
    this.slots.yBlockUpdated.emit({ type: "add", id: t });
  }
  _handleYBlockDelete(t) {
    this.slots.yBlockUpdated.emit({ type: "delete", id: t });
  }
  _handleYEvent(t) {
    t.target === this._yBlocks && t.keys.forEach((e, s) => {
      if (e.action === "add") {
        this._handleYBlockAdd(s);
        return;
      }
      if (e.action === "delete") {
        this._handleYBlockDelete(s);
        return;
      }
    });
  }
  _handleVersion() {
    this.collection.meta.hasVersion ? this.awarenessStore.getFlag("enable_legacy_validation") && this.collection.meta.validateVersion(this.collection) : this.collection.meta.writeVersion(this.collection);
  }
}
class X9 {
  constructor(t) {
    this.id = "meta", this._prevDocs = /* @__PURE__ */ new Set(), this.docMetaAdded = new lt(), this.docMetaRemoved = new lt(), this.docMetaUpdated = new lt(), this.commonFieldsUpdated = new lt(), this._handleDocCollectionMetaEvents = (e) => {
      e.forEach((s) => {
        const i = (r) => s.target === this._yMap && s.changes.keys.has(r);
        (s.target === this.yDocs || s.target.parent === this.yDocs || i("pages")) && this._handleDocMetaEvent(), (i("name") || i("avatar")) && this._handleCommonFieldsEvent();
      });
    }, this.doc = t, this._yMap = t.getMap(this.id), this._proxy = t.getMapProxy(this.id), this._yMap.observeDeep(this._handleDocCollectionMetaEvents);
  }
  get yDocs() {
    return this._yMap.get("pages");
  }
  get docs() {
    return this._proxy.pages;
  }
  get name() {
    return this._proxy.name;
  }
  get avatar() {
    return this._proxy.avatar;
  }
  get blockVersions() {
    return this._proxy.blockVersions;
  }
  get workspaceVersion() {
    return this._proxy.workspaceVersion;
  }
  get pageVersion() {
    return this._proxy.pageVersion;
  }
  setName(t) {
    this.doc.transact(() => {
      this._proxy.name = t;
    }, this.doc.clientID);
  }
  setAvatar(t) {
    this.doc.transact(() => {
      this._proxy.avatar = t;
    }, this.doc.clientID);
  }
  get docMetas() {
    return this._proxy.pages ? [...this._proxy.pages] : [];
  }
  getDocMeta(t) {
    return this.docMetas.find((e) => e.id === t);
  }
  addDocMeta(t, e) {
    this.doc.transact(() => {
      this.docs || (this._proxy.pages = []);
      const s = this.docs;
      e === void 0 ? s.push(t) : s.splice(e, 0, t);
    }, this.doc.clientID);
  }
  /**
   * @internal Use {@link DocCollection.setDocMeta} instead
   */
  setDocMeta(t, e) {
    const i = (this.docs ?? []).findIndex((r) => t === r.id);
    this.doc.transact(() => {
      if (this.docs || (this._proxy.pages = []), i === -1)
        return;
      B(this.docs);
      const r = this.docs[i];
      Object.entries(e).forEach(([o, a]) => {
        r[o] = a;
      });
    }, this.doc.clientID);
  }
  removeDocMeta(t) {
    B(this.docs);
    const s = this.docMetas.findIndex((i) => t === i.id);
    s !== -1 && this.doc.transact(() => {
      B(this.docs), this.docs.splice(s, 1);
    }, this.doc.clientID);
  }
  get hasVersion() {
    return !this.blockVersions || !this.pageVersion || !this.workspaceVersion ? !1 : Object.keys(this.blockVersions).length > 0;
  }
  /**
   * @internal Only for doc initialization
   */
  writeVersion(t) {
    const { blockVersions: e, pageVersion: s, workspaceVersion: i } = this._proxy;
    if (i ? console.error("Workspace version is already set") : this._proxy.workspaceVersion = lh, s ? console.error("Doc version is already set") : this._proxy.pageVersion = hh, e)
      console.error("Block versions is already set");
    else {
      const r = {};
      t.schema.flavourSchemaMap.forEach((o, a) => {
        r[a] = o.version;
      }), this._proxy.blockVersions = r;
    }
  }
  updateVersion(t) {
    this._proxy.workspaceVersion = lh, this._proxy.pageVersion = hh;
    const e = {};
    t.schema.flavourSchemaMap.forEach((s, i) => {
      e[i] = s.version;
    }), this._proxy.blockVersions = e;
  }
  /**
   * @deprecated Only used for legacy doc version validation
   */
  validateVersion(t) {
    const e = this._proxy.workspaceVersion;
    if (!e)
      throw new Error("Invalid workspace data, workspace version is missing. Please make sure the data is valid.");
    if (e < lh)
      throw new Error(`Workspace version ${e} is outdated. Please upgrade the editor.`);
    const s = this._proxy.pageVersion;
    if (!s)
      throw new Error("Invalid workspace data, page version is missing. Please make sure the data is valid.");
    if (s < hh)
      throw new Error(`Doc version ${s} is outdated. Please upgrade the editor.`);
    const i = { ...this._proxy.blockVersions };
    if (!i)
      throw new Error("Invalid workspace data, versions data is missing. Please make sure the data is valid");
    const r = Object.keys(i);
    if (r.length === 0)
      throw new Error("Invalid workspace data, missing versions field. Please make sure the data is valid.");
    r.forEach((o) => {
      var l;
      const a = i[o], c = (l = t.schema.flavourSchemaMap.get(o)) == null ? void 0 : l.version;
      if (c) {
        if (a > c)
          throw new Error(`Editor doesn't support ${o}@${a}. Please upgrade the editor.`);
        if (a < c)
          throw new Error(`In workspace data, the block flavour ${o}@${a} is outdated. Please downgrade the editor or try data migration.`);
      } else
        throw new Error(`Editor missing ${o} flavour. Please make sure this block flavour is registered.`);
    });
  }
  _handleDocMetaEvent() {
    const { docMetas: t, _prevDocs: e } = this;
    t.forEach((s) => {
      e.has(s.id) || this.docMetaAdded.emit(s.id);
    }), e.forEach((s) => {
      t.every((r) => r.id !== s) && this.docMetaRemoved.emit(s);
    }), e.clear(), t.forEach((s) => e.add(s.id)), this.docMetaUpdated.emit();
  }
  _handleCommonFieldsEvent() {
    this.commonFieldsUpdated.emit();
  }
  get properties() {
    const t = this._proxy.properties;
    return t || {
      tags: {
        options: []
      }
    };
  }
  setProperties(t) {
    this._proxy.properties = t, this.docMetaUpdated.emit();
  }
}
class J9 {
  constructor(t, e) {
    this.awareness = t, this.sources = e;
  }
  connect() {
    this.sources.forEach((t) => t.connect(this.awareness));
  }
  disconnect() {
    this.sources.forEach((t) => t.disconnect());
  }
}
const gh = 3e4;
let Q9 = class extends B1 {
  /**
   * @param {Y.Doc} doc
   */
  constructor(t) {
    super(), this.doc = t, this.clientID = t.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = /** @type {any} */
    setInterval(() => {
      const e = Ka();
      this.getLocalState() !== null && gh / 2 <= e - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const s = [];
      this.meta.forEach((i, r) => {
        r !== this.clientID && gh <= e - i.lastUpdated && this.states.has(r) && s.push(r);
      }), s.length > 0 && t8(this, s, "timeout");
    }, Hs(gh / 10)), t.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(t) {
    const e = this.clientID, s = this.meta.get(e), i = s === void 0 ? 0 : s.clock + 1, r = this.states.get(e);
    t === null ? this.states.delete(e) : this.states.set(e, t), this.meta.set(e, {
      clock: i,
      lastUpdated: Ka()
    });
    const o = [], a = [], c = [], l = [];
    t === null ? l.push(e) : r == null ? t != null && o.push(e) : (a.push(e), Aa(r, t) || c.push(e)), (o.length > 0 || c.length > 0 || l.length > 0) && this.emit("change", [{ added: o, updated: c, removed: l }, "local"]), this.emit("update", [{ added: o, updated: a, removed: l }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(t, e) {
    const s = this.getLocalState();
    s !== null && this.setLocalState({
      ...s,
      [t]: e
    });
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
const t8 = (n, t, e) => {
  const s = [];
  for (let i = 0; i < t.length; i++) {
    const r = t[i];
    if (n.states.has(r)) {
      if (n.states.delete(r), r === n.clientID) {
        const o = (
          /** @type {MetaClientState} */
          n.meta.get(r)
        );
        n.meta.set(r, {
          clock: o.clock + 1,
          lastUpdated: Ka()
        });
      }
      s.push(r);
    }
  }
  s.length > 0 && (n.emit("change", [{ added: [], updated: [], removed: s }, e]), n.emit("update", [{ added: [], updated: [], removed: s }, e]));
};
var $s;
(function(n) {
  n[n.Stopped = 0] = "Stopped", n[n.Syncing = 1] = "Syncing", n[n.Synced = 2] = "Synced";
})($s || ($s = {}));
var ke;
(function(n) {
  n[n.Stopped = 0] = "Stopped", n[n.Retrying = 1] = "Retrying", n[n.LoadingRootDoc = 2] = "LoadingRootDoc", n[n.LoadingSubDoc = 3] = "LoadingSubDoc", n[n.Loaded = 4.5] = "Loaded", n[n.Syncing = 5] = "Syncing", n[n.Synced = 6] = "Synced";
})(ke || (ke = {}));
class e8 {
  constructor(t = []) {
    this._resolveUpdate = null, this._waitForUpdate = null, this._queue = t;
  }
  get length() {
    return this._queue.length;
  }
  async next(t, e = (s) => s.shift()) {
    const s = e(this._queue);
    return s || (this._waitForUpdate || (this._waitForUpdate = new Promise((i) => {
      this._resolveUpdate = i;
    })), await Promise.race([
      this._waitForUpdate,
      new Promise((i, r) => {
        t != null && t.aborted && r(t == null ? void 0 : t.reason), t == null || t.addEventListener("abort", () => {
          r(t.reason);
        });
      })
    ]), this.next(t, e));
  }
  push(...t) {
    if (this._queue.push(...t), this._resolveUpdate) {
      const e = this._resolveUpdate;
      this._resolveUpdate = null, this._waitForUpdate = null, e();
    }
  }
  remove(t) {
    const e = this._queue.findIndex(t);
    e !== -1 && this._queue.splice(e, 1);
  }
  find(t) {
    return this._queue.find(t);
  }
  clear() {
    this._queue = [];
  }
}
class mh extends e8 {
  constructor(t = [], e = new Vu()) {
    super(t), this.priorityTarget = e;
  }
  next(t) {
    return super.next(t, (e) => {
      if (this.priorityTarget.priorityRule !== null) {
        const s = e.findIndex((i) => {
          var r, o;
          return (o = (r = this.priorityTarget).priorityRule) == null ? void 0 : o.call(r, i.id);
        });
        if (s !== -1)
          return e.splice(s, 1)[0];
      }
      return e.shift();
    });
  }
}
class Vu {
  constructor() {
    this.priorityRule = null;
  }
}
function Li(n) {
  if (n != null && n.aborted)
    throw new Error(n.reason);
  return !0;
}
const Jr = "manually-stop";
class Up {
  get name() {
    return this.source.name;
  }
  constructor(t, e, s = new Vu(), i) {
    this.rootDoc = t, this.source = e, this.priorityTarget = s, this.logger = i, this._status = {
      step: ke.LoadingRootDoc,
      totalDocs: 1,
      loadedDocs: 0,
      pendingPullUpdates: 0,
      pendingPushUpdates: 0
    }, this.onStatusChange = new lt(), this.abort = new AbortController(), this.state = {
      connectedDocs: /* @__PURE__ */ new Map(),
      pushUpdatesQueue: new mh([], this.priorityTarget),
      pushingUpdate: !1,
      pullUpdatesQueue: new mh([], this.priorityTarget),
      subdocLoading: !1,
      subdocsLoadQueue: new mh([], this.priorityTarget)
    }, this.handleYDocUpdates = (r, o, a) => {
      if (o === this.name)
        return;
      const c = this.state.pushUpdatesQueue.find(({ id: l }) => l === a.guid);
      c ? c.data.push(r) : this.state.pushUpdatesQueue.push({
        id: a.guid,
        data: [r]
      }), this.updateSyncStatus();
    }, this.handleSubdocsUpdate = ({ added: r, removed: o }) => {
      for (const a of r)
        this.state.subdocsLoadQueue.push({ id: a.guid, doc: a });
      for (const a of o)
        this.disconnectDoc(a), this.state.subdocsLoadQueue.remove((c) => c.doc === a);
      this.updateSyncStatus();
    }, this.handleStorageUpdates = (r, o) => {
      this.state.pullUpdatesQueue.push({
        id: r,
        data: o
      }), this.updateSyncStatus();
    }, this.logger.debug(`doc-peer:${this.name} start`), this.syncRetryLoop(this.abort.signal).catch((r) => {
      console.error(r);
    });
  }
  set status(t) {
    zh(t, this._status) || (this.logger.debug(`doc-peer:${this.name} status change`, t), this._status = t, this.onStatusChange.emit(t));
  }
  get status() {
    return this._status;
  }
  /**
   * stop sync
   *
   * DocPeer is one-time use, this peer should be discarded after call stop().
   */
  stop() {
    this.logger.debug(`doc-peer:${this.name} stop`), this.abort.abort(Jr);
  }
  /**
   * auto retry after 5 seconds if sync failed
   */
  async syncRetryLoop(t) {
    for (; t.aborted === !1; ) {
      try {
        await this.sync(t);
      } catch (e) {
        if (e === Jr || t.aborted)
          return;
        this.logger.error(`doc-peer:${this.name} sync error`, e);
      }
      try {
        this.logger.error(`doc-peer:${this.name} retry after 5 seconds`), this.status = {
          step: ke.Retrying,
          totalDocs: 1,
          loadedDocs: 0,
          pendingPullUpdates: 0,
          pendingPushUpdates: 0
        }, await Promise.race([
          new Promise((e) => {
            setTimeout(e, 5 * 1e3);
          }),
          new Promise((e, s) => {
            t.aborted && s(t.reason), t.addEventListener("abort", () => {
              s(t.reason);
            });
          })
        ]);
      } catch (e) {
        if (e === Jr || t.aborted)
          return;
        throw e;
      }
    }
  }
  initState() {
    this.state.connectedDocs.clear(), this.state.pushUpdatesQueue.clear(), this.state.pullUpdatesQueue.clear(), this.state.subdocsLoadQueue.clear(), this.state.pushingUpdate = !1, this.state.subdocLoading = !1;
  }
  /**
   * main synchronization logic
   */
  async sync(t) {
    this.initState();
    const e = new AbortController();
    t.addEventListener("abort", (i) => {
      e.abort(i);
    });
    let s = null;
    try {
      this.updateSyncStatus(), s = await this.source.subscribe(this.handleStorageUpdates, (i) => {
        e.abort("subscribe disconnect:" + i);
      }), Li(e.signal), await this.connectDoc(this.rootDoc, e.signal), this.state.subdocsLoadQueue.push(...Array.from(this.rootDoc.getSubdocs()).map((i) => ({
        id: i.guid,
        doc: i
      }))), this.updateSyncStatus(), this.rootDoc.on("subdocs", this.handleSubdocsUpdate), await Promise.all([
        // load subdocs
        (async () => {
          for (; Li(e.signal); ) {
            const i = await this.state.subdocsLoadQueue.next(e.signal);
            this.state.subdocLoading = !0, this.updateSyncStatus(), await this.connectDoc(i.doc, e.signal), this.state.subdocLoading = !1, this.updateSyncStatus();
          }
        })(),
        // pull updates
        (async () => {
          for (; Li(e.signal); ) {
            const { id: i, data: r } = await this.state.pullUpdatesQueue.next(e.signal);
            if (!(r.byteLength === 0 || r.byteLength === 2 && r[0] === 0 && r[1] === 0)) {
              const o = this.state.connectedDocs.get(i);
              o && uo(o, r, this.name);
            }
            this.updateSyncStatus();
          }
        })(),
        // push updates
        (async () => {
          for (; Li(e.signal); ) {
            const { id: i, data: r } = await this.state.pushUpdatesQueue.next(e.signal);
            this.state.pushingUpdate = !0, this.updateSyncStatus();
            const o = Eu(r);
            o.byteLength === 0 || o.byteLength === 2 && o[0] === 0 && o[1] === 0 || await this.source.push(i, o), this.state.pushingUpdate = !1, this.updateSyncStatus();
          }
        })()
      ]);
    } finally {
      s == null || s();
      for (const i of this.state.connectedDocs.values())
        this.disconnectDoc(i);
      this.rootDoc.off("subdocs", this.handleSubdocsUpdate);
    }
  }
  async connectDoc(t, e) {
    const { data: s, state: i } = await this.source.pull(t.guid, bu(t)) ?? {};
    Li(e), s && s.length > 0 && uo(t, s, "load"), this.state.pushUpdatesQueue.push({
      id: t.guid,
      data: [Yo(t, i)]
    }), this.state.connectedDocs.set(t.guid, t), t.on("update", this.handleYDocUpdates), t.emit("sync", [!0, t]), this.updateSyncStatus();
  }
  disconnectDoc(t) {
    t.off("update", this.handleYDocUpdates), this.state.connectedDocs.delete(t.guid), this.updateSyncStatus();
  }
  updateSyncStatus() {
    let t;
    this.state.connectedDocs.size === 0 ? t = ke.LoadingRootDoc : this.state.subdocsLoadQueue.length || this.state.subdocLoading ? t = ke.LoadingSubDoc : this.state.pullUpdatesQueue.length || this.state.pushUpdatesQueue.length || this.state.pushingUpdate ? t = ke.Syncing : t = ke.Synced, this.status = {
      step: t,
      totalDocs: this.state.connectedDocs.size + this.state.subdocsLoadQueue.length,
      loadedDocs: this.state.connectedDocs.size,
      pendingPullUpdates: this.state.pullUpdatesQueue.length + (this.state.subdocLoading ? 1 : 0),
      pendingPushUpdates: this.state.pushUpdatesQueue.length + (this.state.pushingUpdate ? 1 : 0)
    };
  }
  async waitForSynced(t) {
    if (!(this.status.step >= ke.Synced))
      return Promise.race([
        new Promise((e) => {
          this.onStatusChange.on((s) => {
            s.step >= ke.Synced && e();
          });
        }),
        new Promise((e, s) => {
          t != null && t.aborted && s(t == null ? void 0 : t.reason), t == null || t.addEventListener("abort", () => {
            s(t.reason);
          });
        })
      ]);
  }
  async waitForLoaded(t) {
    if (!(this.status.step > ke.Loaded))
      return Promise.race([
        new Promise((e) => {
          this.onStatusChange.on((s) => {
            s.step > ke.Loaded && e();
          });
        }),
        new Promise((e, s) => {
          t != null && t.aborted && s(t == null ? void 0 : t.reason), t == null || t.addEventListener("abort", () => {
            s(t.reason);
          });
        })
      ]);
  }
}
class s8 {
  get rootDocId() {
    return this.rootDoc.guid;
  }
  setStatus(t) {
    this.logger.debug(`syne-engine:${this.rootDocId} status change`, t), this._status = t, this.onStatusChange.emit(t);
  }
  get status() {
    return this._status;
  }
  constructor(t, e, s, i) {
    this.rootDoc = t, this.main = e, this.shadow = s, this.logger = i, this.onStatusChange = new lt(), this.priorityTarget = new Vu(), this._abort = new AbortController(), this._status = {
      step: $s.Stopped,
      main: null,
      shadow: s.map(() => null),
      retrying: !1
    }, this.logger.debug(`syne-engine:${this.rootDocId} status init`, this.status);
  }
  start() {
    this.status.step !== $s.Stopped && this.forceStop(), this._abort = new AbortController(), this.sync(this._abort.signal).catch((t) => {
      this.logger.error(`syne-engine:${this.rootDocId}`, t);
    });
  }
  canGracefulStop() {
    return !!this.status.main && this.status.main.pendingPushUpdates === 0;
  }
  async waitForGracefulStop(t) {
    await Promise.race([
      new Promise((e, s) => {
        t != null && t.aborted && s(t == null ? void 0 : t.reason), t == null || t.addEventListener("abort", () => {
          s(t.reason);
        });
      }),
      new Promise((e) => {
        this.onStatusChange.on(() => {
          this.canGracefulStop() && e();
        });
      })
    ]), Li(t), this.forceStop();
  }
  forceStop() {
    this._abort.abort(Jr), this.setStatus({
      step: $s.Stopped,
      main: null,
      shadow: this.shadow.map(() => null),
      retrying: !1
    });
  }
  // main sync process, should never return until abort
  async sync(t) {
    var i;
    const e = {
      mainPeer: null,
      shadowPeers: this.shadow.map(() => null)
    }, s = [];
    try {
      e.mainPeer = new Up(this.rootDoc, this.main, this.priorityTarget, this.logger), s.push(e.mainPeer.onStatusChange.on(() => {
        t.aborted || this.updateSyncingState(e.mainPeer, e.shadowPeers);
      }).dispose), this.updateSyncingState(e.mainPeer, e.shadowPeers), await e.mainPeer.waitForLoaded(t), e.shadowPeers = this.shadow.map((r) => {
        const o = new Up(this.rootDoc, r, this.priorityTarget, this.logger);
        return s.push(o.onStatusChange.on(() => {
          t.aborted || this.updateSyncingState(e.mainPeer, e.shadowPeers);
        }).dispose), o;
      }), this.updateSyncingState(e.mainPeer, e.shadowPeers), await new Promise((r, o) => {
        t.aborted && o(t.reason), t.addEventListener("abort", () => {
          o(t.reason);
        });
      });
    } catch (r) {
      if (r === Jr || t.aborted)
        return;
      throw r;
    } finally {
      (i = e.mainPeer) == null || i.stop();
      for (const r of e.shadowPeers)
        r == null || r.stop();
      for (const r of s)
        r();
    }
  }
  updateSyncingState(t, e) {
    let s = $s.Synced;
    const i = [t, ...e];
    for (const r of i)
      if (!r || r.status.step !== ke.Synced) {
        s = $s.Syncing;
        break;
      }
    this.setStatus({
      step: s,
      main: (t == null ? void 0 : t.status) ?? null,
      shadow: e.map((r) => (r == null ? void 0 : r.status) ?? null),
      retrying: i.some((r) => (r == null ? void 0 : r.status.step) === ke.Retrying)
    });
  }
  async waitForSynced(t) {
    if (this.status.step !== $s.Synced)
      return Promise.race([
        new Promise((e) => {
          this.onStatusChange.on((s) => {
            s.step === $s.Synced && e();
          });
        }),
        new Promise((e, s) => {
          t != null && t.aborted && s(t == null ? void 0 : t.reason), t == null || t.addEventListener("abort", () => {
            s(t.reason);
          });
        })
      ]);
  }
  async waitForLoadedRootDoc(t) {
    function e(s) {
      return ![s.main, ...s.shadow].some((i) => !i || i.step <= ke.LoadingRootDoc);
    }
    if (!e(this.status))
      return Promise.race([
        new Promise((s) => {
          this.onStatusChange.on((i) => {
            e(i) && s();
          });
        }),
        new Promise((s, i) => {
          t != null && t.aborted && i(t == null ? void 0 : t.reason), t == null || t.addEventListener("abort", () => {
            i(t.reason);
          });
        })
      ]);
  }
  setPriorityRule(t) {
    this.priorityTarget.priorityRule = t;
  }
}
const ud = (n, t) => t.some((e) => n instanceof e);
let Fp, Bp;
function n8() {
  return Fp || (Fp = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function i8() {
  return Bp || (Bp = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const fd = /* @__PURE__ */ new WeakMap(), _h = /* @__PURE__ */ new WeakMap(), qc = /* @__PURE__ */ new WeakMap();
function r8(n) {
  const t = new Promise((e, s) => {
    const i = () => {
      n.removeEventListener("success", r), n.removeEventListener("error", o);
    }, r = () => {
      e(hc(n.result)), i();
    }, o = () => {
      s(n.error), i();
    };
    n.addEventListener("success", r), n.addEventListener("error", o);
  });
  return qc.set(t, n), t;
}
function o8(n) {
  if (fd.has(n))
    return;
  const t = new Promise((e, s) => {
    const i = () => {
      n.removeEventListener("complete", r), n.removeEventListener("error", o), n.removeEventListener("abort", o);
    }, r = () => {
      e(), i();
    }, o = () => {
      s(n.error || new DOMException("AbortError", "AbortError")), i();
    };
    n.addEventListener("complete", r), n.addEventListener("error", o), n.addEventListener("abort", o);
  });
  fd.set(n, t);
}
let pd = {
  get(n, t, e) {
    if (n instanceof IDBTransaction) {
      if (t === "done")
        return fd.get(n);
      if (t === "store")
        return e.objectStoreNames[1] ? void 0 : e.objectStore(e.objectStoreNames[0]);
    }
    return hc(n[t]);
  },
  set(n, t, e) {
    return n[t] = e, !0;
  },
  has(n, t) {
    return n instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in n;
  }
};
function M2(n) {
  pd = n(pd);
}
function a8(n) {
  return i8().includes(n) ? function(...t) {
    return n.apply(gd(this), t), hc(this.request);
  } : function(...t) {
    return hc(n.apply(gd(this), t));
  };
}
function c8(n) {
  return typeof n == "function" ? a8(n) : (n instanceof IDBTransaction && o8(n), ud(n, n8()) ? new Proxy(n, pd) : n);
}
function hc(n) {
  if (n instanceof IDBRequest)
    return r8(n);
  if (_h.has(n))
    return _h.get(n);
  const t = c8(n);
  return t !== n && (_h.set(n, t), qc.set(t, n)), t;
}
const gd = (n) => qc.get(n), l8 = ["get", "getKey", "getAll", "getAllKeys", "count"], h8 = ["put", "add", "delete", "clear"], yh = /* @__PURE__ */ new Map();
function Vp(n, t) {
  if (!(n instanceof IDBDatabase && !(t in n) && typeof t == "string"))
    return;
  if (yh.get(t))
    return yh.get(t);
  const e = t.replace(/FromIndex$/, ""), s = t !== e, i = h8.includes(e);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(e in (s ? IDBIndex : IDBObjectStore).prototype) || !(i || l8.includes(e))
  )
    return;
  const r = async function(o, ...a) {
    const c = this.transaction(o, i ? "readwrite" : "readonly");
    let l = c.store;
    return s && (l = l.index(a.shift())), (await Promise.all([
      l[e](...a),
      i && c.done
    ]))[0];
  };
  return yh.set(t, r), r;
}
M2((n) => ({
  ...n,
  get: (t, e, s) => Vp(t, e) || n.get(t, e, s),
  has: (t, e) => !!Vp(t, e) || n.has(t, e)
}));
const d8 = ["continue", "continuePrimaryKey", "advance"], jp = {}, md = /* @__PURE__ */ new WeakMap(), R2 = /* @__PURE__ */ new WeakMap(), u8 = {
  get(n, t) {
    if (!d8.includes(t))
      return n[t];
    let e = jp[t];
    return e || (e = jp[t] = function(...s) {
      md.set(this, R2.get(this)[t](...s));
    }), e;
  }
};
async function* f8(...n) {
  let t = this;
  if (t instanceof IDBCursor || (t = await t.openCursor(...n)), !t)
    return;
  t = t;
  const e = new Proxy(t, u8);
  for (R2.set(e, t), qc.set(e, gd(t)); t; )
    yield e, t = await (md.get(e) || t.continue()), md.delete(e);
}
function Gp(n, t) {
  return t === Symbol.asyncIterator && ud(n, [IDBIndex, IDBObjectStore, IDBCursor]) || t === "iterate" && ud(n, [IDBIndex, IDBObjectStore]);
}
M2((n) => ({
  ...n,
  get(t, e, s) {
    return Gp(t, e) ? f8 : n.get(t, e, s);
  },
  has(t, e) {
    return Gp(t, e) || n.has(t, e);
  }
}));
class p8 {
  constructor() {
    this.name = "noop";
  }
  pull(t, e) {
    return null;
  }
  push(t, e) {
  }
  subscribe(t, e) {
    return () => {
    };
  }
}
var _d = { exports: {} };
(function(n, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isPlainObject = t.clone = t.recursive = t.merge = t.main = void 0, n.exports = t = e, t.default = e;
  function e() {
    for (var l = [], h = 0; h < arguments.length; h++)
      l[h] = arguments[h];
    return s.apply(void 0, l);
  }
  t.main = e, e.clone = r, e.isPlainObject = o, e.recursive = i;
  function s() {
    for (var l = [], h = 0; h < arguments.length; h++)
      l[h] = arguments[h];
    return c(l[0] === !0, !1, l);
  }
  t.merge = s;
  function i() {
    for (var l = [], h = 0; h < arguments.length; h++)
      l[h] = arguments[h];
    return c(l[0] === !0, !0, l);
  }
  t.recursive = i;
  function r(l) {
    if (Array.isArray(l)) {
      for (var h = [], d = 0; d < l.length; ++d)
        h.push(r(l[d]));
      return h;
    } else if (o(l)) {
      var h = {};
      for (var d in l)
        h[d] = r(l[d]);
      return h;
    } else
      return l;
  }
  t.clone = r;
  function o(l) {
    return l && typeof l == "object" && !Array.isArray(l);
  }
  t.isPlainObject = o;
  function a(l, h) {
    if (!o(l))
      return h;
    for (var d in h)
      d === "__proto__" || d === "constructor" || d === "prototype" || (l[d] = o(l[d]) && o(h[d]) ? a(l[d], h[d]) : h[d]);
    return l;
  }
  function c(l, h, d) {
    var u;
    (l || !o(u = d.shift())) && (u = {});
    for (var f = 0; f < d.length; ++f) {
      var p = d[f];
      if (o(p)) {
        for (var m in p)
          if (!(m === "__proto__" || m === "constructor" || m === "prototype")) {
            var _ = l ? r(p[m]) : p[m];
            u[m] = h ? a(u[m], _) : _;
          }
      }
    }
    return u;
  }
})(_d, _d.exports);
var $2 = _d.exports;
const g8 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let m8 = (n = 21) => {
  let t = "", e = crypto.getRandomValues(new Uint8Array(n));
  for (; n--; )
    t += g8[e[n] & 63];
  return t;
};
function _8() {
  let n = 0;
  return () => (n++).toString();
}
function y8(n) {
  let t = 0;
  return () => `${n}:${t++}`;
}
const v8 = () => du(), Hp = () => m8(10);
class b8 {
  constructor(t, e, s) {
    this.slots = {
      update: new lt()
    }, this._onAwarenessChange = (i) => {
      const { added: r, removed: o, updated: a } = i, c = this.awareness.getStates();
      r.forEach((l) => {
        this.slots.update.emit({
          id: l,
          type: "add",
          state: c.get(l)
        });
      }), a.forEach((l) => {
        this.slots.update.emit({
          id: l,
          type: "update",
          state: c.get(l)
        });
      }), o.forEach((l) => {
        this.slots.update.emit({
          id: l,
          type: "remove"
        });
      });
    }, this.store = t, this.awareness = e, this.awareness.on("change", this._onAwarenessChange), this.awareness.setLocalStateField("selectionV2", {}), this._initFlags(s);
  }
  _initFlags(t) {
    var i;
    const e = (i = this.awareness.getLocalState()) == null ? void 0 : i.flags, s = e ? $2.merge(!0, t, e) : { ...t };
    this.awareness.setLocalStateField("flags", s);
  }
  setFlag(t, e) {
    var i;
    const s = ((i = this.awareness.getLocalState()) == null ? void 0 : i.flags) ?? {};
    this.awareness.setLocalStateField("flags", { ...s, [t]: e });
  }
  getFlag(t) {
    var s;
    return (((s = this.awareness.getLocalState()) == null ? void 0 : s.flags) ?? {})[t];
  }
  setReadonly(t, e) {
    const s = this.getFlag("readonly") ?? {};
    this.setFlag("readonly", {
      ...s,
      [t.id]: e
    });
  }
  isReadonly(t) {
    const e = this.getFlag("readonly");
    return e && typeof e == "object" ? !!e[t.id] : !1;
  }
  setLocalSelection(t, e) {
    var i;
    const s = ((i = this.awareness.getLocalState()) == null ? void 0 : i.selectionV2) ?? {};
    this.awareness.setLocalStateField("selectionV2", {
      ...s,
      [t.id]: e
    });
  }
  getLocalSelection(t) {
    var e;
    return (((e = this.awareness.getLocalState()) == null ? void 0 : e.selectionV2) ?? {})[t.id] ?? [];
  }
  getStates() {
    return this.awareness.getStates();
  }
  destroy() {
    this.awareness && (this.awareness.off("change", this._onAwarenessChange), this.slots.update.dispose());
  }
}
class w8 extends Tn {
  constructor() {
    super(...arguments), this._spaces = this.getMap("spaces");
  }
  get spaces() {
    return this._spaces;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    const t = super.toJSON();
    delete t.spaces;
    const e = {};
    return this.spaces.forEach((s, i) => {
      e[i] = s.toJSON();
    }), {
      ...t,
      spaces: e
    };
  }
  getMapProxy(t) {
    const e = super.getMap(t);
    return si(e);
  }
  getArrayProxy(t) {
    const e = super.getArray(t);
    return si(e);
  }
  transact(t, e) {
    return super.transact(t, e);
  }
}
var Vi;
(function(n) {
  n.NanoID = "nanoID", n.UUIDv4 = "uuidV4", n.AutoIncrementByClientId = "autoIncrementByClientId", n.AutoIncrement = "autoIncrement";
})(Vi || (Vi = {}));
const S8 = {
  enable_synced_doc_block: !1,
  enable_pie_menu: !1,
  enable_database_statistics: !1,
  enable_legacy_validation: !0,
  enable_expand_database_block: !1,
  readonly: {}
};
class C8 {
  constructor({ id: t, idGenerator: e, defaultFlags: s, awarenessSources: i = [], docSources: r = {
    main: new p8()
  }, logger: o = new Xy() } = {
    id: Hp()
  }) {
    if (this.spaces = /* @__PURE__ */ new Map(), this.id = t || "", this.doc = new w8({ guid: t }), this.awarenessStore = new b8(this, new Q9(this.doc), $2.merge(!0, S8, s)), this.awarenessSync = new J9(this.awarenessStore.awareness, i), this.docSync = new s8(this.doc, r.main, r.shadow ?? [], o), typeof e == "function")
      this.idGenerator = e;
    else
      switch (e) {
        case Vi.AutoIncrement: {
          this.idGenerator = _8();
          break;
        }
        case Vi.AutoIncrementByClientId: {
          this.idGenerator = y8(this.doc.clientID);
          break;
        }
        case Vi.UUIDv4: {
          this.idGenerator = v8;
          break;
        }
        case Vi.NanoID:
        default: {
          this.idGenerator = Hp;
          break;
        }
      }
  }
  addSpace(t) {
    this.spaces.set(t.id, t);
  }
  removeSpace(t) {
    this.spaces.delete(t.id);
  }
}
var k8 = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
}, Vo;
let yd = (Vo = class extends z9 {
  constructor(t) {
    super(), this.slots = {
      docAdded: new lt(),
      docUpdated: new lt(),
      docRemoved: new lt()
    }, this._schema = t.schema, this._store = new C8(t), this.meta = new X9(this.doc), this._bindDocMetaEvents();
  }
  get id() {
    return this._store.id;
  }
  get isEmpty() {
    if (this.doc.store.clients.size === 0)
      return !0;
    let t = !1;
    return this.doc.store.clients.size === 1 && Array.from(this.doc.store.clients.values())[0].length <= 2 && (t = !0), t;
  }
  get store() {
    return this._store;
  }
  get awarenessStore() {
    return this._store.awarenessStore;
  }
  get docs() {
    return this._store.spaces;
  }
  get doc() {
    return this._store.doc;
  }
  get idGenerator() {
    return this._store.idGenerator;
  }
  get schema() {
    return this._schema;
  }
  get docSync() {
    return this.store.docSync;
  }
  get awarenessSync() {
    return this.store.awarenessSync;
  }
  _hasDoc(t) {
    return this.docs.has(t);
  }
  getDoc(t, e = P2) {
    const s = this.getBlockCollection(t);
    return (s == null ? void 0 : s.getDoc(e)) ?? null;
  }
  getBlockCollection(t) {
    return this.docs.get(t) ?? null;
  }
  _bindDocMetaEvents() {
    this.meta.docMetaAdded.on((t) => {
      const e = new q9({
        id: t,
        collection: this,
        doc: this.doc,
        awarenessStore: this.awarenessStore,
        idGenerator: this._store.idGenerator
      });
      this._store.addSpace(e), this.slots.docAdded.emit(e.id);
    }), this.meta.docMetaUpdated.on(() => this.slots.docUpdated.emit()), this.meta.docMetaRemoved.on((t) => {
      const e = this.getBlockCollection(t);
      e && (this._store.removeSpace(e), e.remove(), this.slots.docRemoved.emit(t));
    });
  }
  /**
   * By default, only an empty doc will be created.
   * If the `init` parameter is passed, a `surface`, `note`, and `paragraph` block
   * will be created in the doc simultaneously.
   */
  createDoc(t = {}) {
    const { id: e = this.idGenerator(), selector: s } = t;
    if (this._hasDoc(e))
      throw new Error("dac already exists");
    return this.meta.addDocMeta({
      id: e,
      title: "",
      createDate: Date.now(),
      tags: []
    }), this.getDoc(e, s);
  }
  /** Update doc meta state. Note that this intentionally does not mutate doc state. */
  setDocMeta(t, e) {
    this.meta.setDocMeta(t, e);
  }
  removeDoc(t) {
    const e = this.meta.getDocMeta(t);
    B(e);
    const s = this.getBlockCollection(t);
    s && (s.dispose(), this.meta.removeDocMeta(t), this._store.removeSpace(s));
  }
  /**
   * Start the data sync process
   */
  start() {
    this.docSync.start(), this.awarenessSync.connect();
  }
  /**
   * Verify that all data has been successfully saved to the primary storage.
   * Return true if the data transfer is complete and it is secure to terminate the synchronization operation.
   */
  canGracefulStop() {
    this.docSync.canGracefulStop();
  }
  /**
   * Wait for all data has been successfully saved to the primary storage.
   */
  waitForGracefulStop(t) {
    return this.docSync.waitForGracefulStop(t);
  }
  /**
   * Terminate the data sync process forcefully, which may cause data loss.
   * It is advised to invoke `canGracefulStop` before calling this method.
   */
  forceStop() {
    this.docSync.forceStop(), this.awarenessSync.disconnect();
  }
  waitForSynced() {
    return this.docSync.waitForSynced();
  }
}, Vo.Y = t3, Vo);
yd = k8([
  l9,
  B9,
  H9
], yd);
class x8 {
  constructor(t) {
    this._assetsMap = /* @__PURE__ */ new Map(), this._blob = t.blob;
  }
  getAssets() {
    return this._assetsMap;
  }
  isEmpty() {
    return this._assetsMap.size === 0;
  }
  cleanup() {
    this._assetsMap.clear();
  }
  async readFromBlob(t) {
    const e = await this._blob.get(t);
    B(e, `Blob ${t} not found in blob manager`), this._assetsMap.set(t, e);
  }
  async writeToBlob(t) {
    const e = this._assetsMap.get(t);
    B(e), await this._blob.get(t) === null && await this._blob.set(e, t);
  }
}
function vd(n) {
  return n instanceof ks ? {
    [Xr]: !0,
    value: n.getValue()
  } : n instanceof vr ? {
    [Vg]: !0,
    delta: n.yText.toDelta()
  } : Array.isArray(n) ? n.map(vd) : jg(n) ? Object.fromEntries(Object.entries(n).map(([t, e]) => [t, vd(e)])) : n;
}
function bd(n) {
  return Array.isArray(n) ? n.map(bd) : n instanceof Object ? Reflect.has(n, Xr) ? new ks(Reflect.get(n, "value")) : Reflect.has(n, Vg) ? new vr(Reflect.get(n, "delta")) : Object.fromEntries(Object.entries(n).map(([t, e]) => [t, bd(e)])) : n;
}
class E8 {
  constructor() {
    this._internal = Kc;
  }
  _propsFromSnapshot(t) {
    return Object.fromEntries(Object.entries(t).map(([e, s]) => [e, bd(s)]));
  }
  _propsToSnapshot(t) {
    return Object.fromEntries(t.keys.map((e) => {
      const s = t[e];
      return [e, vd(s)];
    }));
  }
  fromSnapshot({ json: t }) {
    const { flavour: e, id: s, version: i, props: r } = t, o = this._propsFromSnapshot(r);
    return {
      id: s,
      flavour: e,
      version: i ?? -1,
      props: o
    };
  }
  toSnapshot({ model: t }) {
    const { id: e, flavour: s, version: i } = t, r = this._propsToSnapshot(t);
    return {
      id: e,
      flavour: s,
      version: i,
      props: r
    };
  }
}
class ju {
  static fromModels(t, e) {
    const s = t.collection.meta, { pageVersion: i, workspaceVersion: r } = s;
    return B(i), B(r), new ju({
      content: e,
      workspaceId: t.collection.id,
      pageId: t.id,
      pageVersion: i,
      workspaceVersion: r
    });
  }
  constructor(t) {
    this.data = t;
  }
  get content() {
    return this.data.content;
  }
  get pageVersion() {
    return this.data.pageVersion;
  }
  get workspaceVersion() {
    return this.data.workspaceVersion;
  }
  get workspaceId() {
    return this.data.workspaceId;
  }
  get docId() {
    return this.data.pageId;
  }
}
const Do = U.object({
  type: U.literal("block"),
  id: U.string(),
  flavour: U.string(),
  version: U.number().optional(),
  props: U.record(U.unknown()),
  children: U.lazy(() => Do.array())
}), zp = U.object({
  type: U.literal("slice"),
  content: Do.array(),
  pageVersion: U.number(),
  workspaceVersion: U.number(),
  workspaceId: U.string(),
  pageId: U.string()
}), Wp = U.object({
  id: U.string(),
  type: U.literal("info"),
  pageVersion: U.number(),
  workspaceVersion: U.number(),
  properties: U.record(U.any())
}), T8 = U.object({
  id: U.string(),
  title: U.string(),
  createDate: U.number(),
  tags: U.array(U.string())
}), Kp = U.object({
  type: U.literal("page"),
  meta: T8,
  blocks: Do
});
class Gu {
  constructor({ collection: t, middlewares: e = [] }) {
    this._adapterConfigs = /* @__PURE__ */ new Map(), this._slots = {
      beforeImport: new lt(),
      afterImport: new lt(),
      beforeExport: new lt(),
      afterExport: new lt()
    }, this.blockToSnapshot = async (s) => {
      const i = await this._blockToSnapshot(s);
      return Do.parse(i), i;
    }, this.snapshotToModelData = async (s) => {
      const { children: i, flavour: r, props: o, id: a } = s, c = this._getSchema(r), l = {
        id: a,
        flavour: r,
        props: o
      };
      return await this._getTransformer(c).fromSnapshot({
        json: l,
        assets: this._assetsManager,
        children: i
      });
    }, this.walk = (s, i) => {
      const r = (o) => {
        i(o), o.children && o.children.forEach(r);
      };
      r(s.blocks);
    }, this.snapshotToBlock = async (s, i, r, o) => (Do.parse(s), await this._snapshotToBlock(s, i, r, o)), this.docToSnapshot = async (s) => {
      this._slots.beforeExport.emit({
        type: "page",
        page: s
      });
      const i = s.root, r = this._exportDocMeta(s);
      B(i, "Root block not found in doc");
      const o = await this.blockToSnapshot(i), a = {
        type: "page",
        meta: r,
        blocks: o
      };
      return this._slots.afterExport.emit({
        type: "page",
        page: s,
        snapshot: a
      }), Kp.parse(a), a;
    }, this.snapshotToDoc = async (s) => {
      this._slots.beforeImport.emit({
        type: "page",
        snapshot: s
      }), Kp.parse(s);
      const { meta: i, blocks: r } = s, o = this._collection.createDoc({ id: i.id });
      return o.load(), this._importDocMeta(o, i), await this.snapshotToBlock(r, o), this._slots.afterImport.emit({
        type: "page",
        snapshot: s,
        page: o
      }), o;
    }, this.collectionInfoToSnapshot = () => {
      this._slots.beforeExport.emit({
        type: "info"
      });
      const s = this._getCollectionMeta(), i = {
        type: "info",
        id: this._collection.id,
        ...s
      };
      return this._slots.afterExport.emit({
        type: "info",
        snapshot: i
      }), Wp.parse(i), i;
    }, this.snapshotToCollectionInfo = (s) => {
      var l, h;
      this._slots.beforeImport.emit({
        type: "info",
        snapshot: s
      }), Wp.parse(s);
      const { properties: i } = s, r = this._collection.meta.properties, o = ((l = i.tags) == null ? void 0 : l.options) ?? [], a = ((h = r.tags) == null ? void 0 : h.options) ?? [], c = /* @__PURE__ */ new Set([...o, ...a]);
      this._collection.meta.setProperties({
        tags: {
          options: Array.from(c)
        }
      }), this._slots.afterImport.emit({
        type: "info",
        snapshot: s
      });
    }, this.sliceToSnapshot = async (s) => {
      this._slots.beforeExport.emit({
        type: "slice",
        slice: s
      });
      const { content: i, pageVersion: r, workspaceVersion: o, pageId: a, workspaceId: c } = s.data, l = [];
      for (const d of i)
        l.push(await this.blockToSnapshot(d));
      const h = {
        type: "slice",
        workspaceId: c,
        pageId: a,
        pageVersion: r,
        workspaceVersion: o,
        content: l
      };
      return this._slots.afterExport.emit({
        type: "slice",
        slice: s,
        snapshot: h
      }), zp.parse(h), h;
    }, this.snapshotToSlice = async (s, i, r, o) => {
      this._slots.beforeImport.emit({
        type: "slice",
        snapshot: s
      }), zp.parse(s);
      const { content: a, pageVersion: c, workspaceVersion: l, workspaceId: h, pageId: d } = s, u = [];
      for (const [p, m] of a.entries())
        u.push(await this._snapshotToBlock(m, i, r, (o ?? 0) + p));
      const f = new ju({
        content: u,
        pageVersion: c,
        workspaceVersion: l,
        workspaceId: h,
        pageId: d
      });
      return this._slots.afterImport.emit({
        type: "slice",
        snapshot: s,
        slice: f
      }), f;
    }, this._collection = t, this._assetsManager = new x8({ blob: t.blob }), e.forEach((s) => {
      s({
        slots: this._slots,
        assetsManager: this._assetsManager,
        collection: this._collection,
        adapterConfigs: this._adapterConfigs
      });
    });
  }
  get assetsManager() {
    return this._assetsManager;
  }
  get assets() {
    return this._assetsManager.getAssets();
  }
  get adapterConfigs() {
    return this._adapterConfigs;
  }
  reset() {
    this._assetsManager.cleanup();
  }
  _getSchema(t) {
    const e = this._collection.schema.flavourSchemaMap.get(t);
    return B(e, `Flavour schema not found for ${t}`), e;
  }
  _getTransformer(t) {
    var e;
    return ((e = t.transformer) == null ? void 0 : e.call(t)) ?? new E8();
  }
  _getCollectionMeta() {
    const { meta: t } = this._collection, { pageVersion: e, workspaceVersion: s, properties: i, docs: r } = t;
    return B(e), B(s), B(i), B(r), {
      pageVersion: e,
      workspaceVersion: s,
      properties: JSON.parse(JSON.stringify(i)),
      pages: JSON.parse(JSON.stringify(r))
    };
  }
  _exportDocMeta(t) {
    const e = t.meta;
    return B(e), {
      id: e.id,
      title: e.title,
      createDate: e.createDate,
      tags: [...e.tags]
    };
  }
  _importDocMeta(t, e) {
    var r;
    const s = t.meta;
    B(s);
    const i = (r = this._collection.meta.properties.tags) == null ? void 0 : r.options;
    B(i), e.tags.forEach((o) => {
      if (!i.some((c) => c.id === o))
        throw new Error(`Tag ${o} is not in collection options`);
      s.tags.push(o);
    });
  }
  async _blockToSnapshot(t) {
    this._slots.beforeExport.emit({
      type: "block",
      model: t
    });
    const e = this._getSchema(t.flavour), i = await this._getTransformer(e).toSnapshot({
      model: t,
      assets: this._assetsManager
    }), r = await Promise.all(t.children.map((a) => this._blockToSnapshot(a))), o = {
      type: "block",
      ...i,
      children: r
    };
    return this._slots.afterExport.emit({
      type: "block",
      model: t,
      snapshot: o
    }), o;
  }
  async _snapshotToBlock(t, e, s, i) {
    this._slots.beforeImport.emit({
      type: "block",
      snapshot: t,
      parent: s,
      index: i
    });
    const { children: r, flavour: o, props: a, id: c } = t, l = this._getSchema(o), h = {
      id: c,
      flavour: o,
      props: a
    }, u = await this._getTransformer(l).fromSnapshot({
      json: h,
      assets: this._assetsManager,
      children: r
    });
    e.addBlock(u.flavour, { ...u.props, id: u.id }, s, i);
    for (const [p, m] of r.entries())
      await this._snapshotToBlock(m, e, c, p);
    const f = e.getBlockById(c);
    return B(f), this._slots.afterImport.emit({
      type: "block",
      snapshot: t,
      model: f,
      parent: s,
      index: i
    }), f;
  }
}
function A8(n) {
  return n instanceof Nu;
}
function I8() {
  if (process.env.NODE_ENV !== "development" || typeof window > "u")
    return;
  const n = {
    style: "color: #eee; background: #3F6FDB; margin-right: 5px; padding: 2px; border-radius: 4px"
  }, t = {
    style: "color: #eee; background: #DB6D56; margin-right: 5px; padding: 2px; border-radius: 4px"
  }, e = {
    header(s, i = { expand: !1 }) {
      return !A8(s) || i.expand ? null : s.text ? [
        "div",
        {},
        ["span", n, s.constructor.name],
        ["span", t, s.flavour],
        s.text.toString()
      ] : [
        "div",
        {},
        ["span", n, s.constructor.name],
        ["span", t, s.flavour]
      ];
    },
    hasBody() {
      return !0;
    },
    body(s) {
      return ["object", { object: s, config: { expand: !0 } }];
    }
  };
  window.devtoolsFormatters ? window.devtoolsFormatters.push(e) : window.devtoolsFormatters = [e];
}
I8();
const N2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : (
  // @ts-ignore
  typeof global < "u" ? (
    // @ts-ignore
    global
  ) : {}
), L2 = "__ $BLOCKSUITE_STORE$ __";
N2[L2] === !0 && console.error("@blocksuite/store was already imported. This breaks constructor checks and will lead to issues!");
N2[L2] = !0;
const _i = (n) => sr((t, e) => {
  n.onerror = (s) => e(new Error(s.target.error)), n.onsuccess = (s) => t(s.target.result);
}), O8 = (n, t) => sr((e, s) => {
  const i = indexedDB.open(n);
  i.onupgradeneeded = (r) => t(r.target.result), i.onerror = (r) => s(zs(r.target.error)), i.onsuccess = (r) => {
    const o = r.target.result;
    o.onversionchange = () => {
      o.close();
    }, e(o);
  };
}), D8 = (n) => _i(indexedDB.deleteDatabase(n)), P8 = (n, t) => t.forEach(
  (e) => (
    // @ts-ignore
    n.createObjectStore.apply(n, e)
  )
), zr = (n, t, e = "readwrite") => {
  const s = n.transaction(t, e);
  return t.map((i) => B8(s, i));
}, U2 = (n, t) => _i(n.count(t)), M8 = (n, t) => _i(n.get(t)), F2 = (n, t) => _i(n.delete(t)), R8 = (n, t, e) => _i(n.put(t, e)), wd = (n, t) => _i(n.add(t)), $8 = (n, t, e) => _i(n.getAll(t, e)), N8 = (n, t, e) => {
  let s = null;
  return F8(n, t, (i) => (s = i, !1), e).then(() => s);
}, L8 = (n, t = null) => N8(n, t, "prev"), U8 = (n, t) => sr((e, s) => {
  n.onerror = s, n.onsuccess = async (i) => {
    const r = i.target.result;
    if (r === null || await t(r) === !1)
      return e();
    r.continue();
  };
}), F8 = (n, t, e, s = "next") => U8(n.openKeyCursor(t, s), (i) => e(i.key)), B8 = (n, t) => n.objectStore(t), V8 = (n, t) => IDBKeyRange.upperBound(n, t), j8 = (n, t) => IDBKeyRange.lowerBound(n, t), vh = "custom", B2 = "updates", V2 = 500, j2 = (n, t = () => {
}, e = () => {
}) => {
  const [s] = zr(
    /** @type {IDBDatabase} */
    n.db,
    [B2]
  );
  return $8(s, j8(n._dbref, !1)).then((i) => {
    n._destroyed || (t(s), kt(n.doc, () => {
      i.forEach((r) => uo(n.doc, r));
    }, n, !1), e(s));
  }).then(() => L8(s).then((i) => {
    n._dbref = i + 1;
  })).then(() => U2(s).then((i) => {
    n._dbsize = i;
  })).then(() => s);
}, G8 = (n, t = !0) => j2(n).then((e) => {
  (t || n._dbsize >= V2) && wd(e, Yo(n.doc)).then(() => F2(e, V8(n._dbref, !0))).then(() => U2(e).then((s) => {
    n._dbsize = s;
  }));
});
class H8 extends B1 {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(t, e) {
    super(), this.doc = e, this.name = t, this._dbref = 0, this._dbsize = 0, this._destroyed = !1, this.db = null, this.synced = !1, this._db = O8(
      t,
      (s) => P8(s, [
        ["updates", { autoIncrement: !0 }],
        ["custom"]
      ])
    ), this.whenSynced = sr((s) => this.on("synced", () => s(this))), this._db.then((s) => {
      this.db = s, j2(this, (o) => wd(o, Yo(e)), () => {
        if (this._destroyed)
          return this;
        this.synced = !0, this.emit("synced", [this]);
      });
    }), this._storeTimeout = 1e3, this._storeTimeoutId = null, this._storeUpdate = (s, i) => {
      if (this.db && i !== this) {
        const [r] = zr(
          /** @type {IDBDatabase} */
          this.db,
          [B2]
        );
        wd(r, s), ++this._dbsize >= V2 && (this._storeTimeoutId !== null && clearTimeout(this._storeTimeoutId), this._storeTimeoutId = setTimeout(() => {
          G8(this, !1), this._storeTimeoutId = null;
        }, this._storeTimeout));
      }
    }, e.on("update", this._storeUpdate), this.destroy = this.destroy.bind(this), e.on("destroy", this.destroy);
  }
  destroy() {
    return this._storeTimeoutId && clearTimeout(this._storeTimeoutId), this.doc.off("update", this._storeUpdate), this.doc.off("destroy", this.destroy), this._destroyed = !0, this._db.then((t) => {
      t.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      D8(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(t) {
    return this._db.then((e) => {
      const [s] = zr(e, [vh], "readonly");
      return M8(s, t);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(t, e) {
    return this._db.then((s) => {
      const [i] = zr(s, [vh]);
      return R8(i, e, t);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(t) {
    return this._db.then((e) => {
      const [s] = zr(e, [vh]);
      return F2(s, t);
    });
  }
}
var z8 = Object.defineProperty, W8 = (n, t) => {
  for (var e in t)
    z8(n, e, { get: t[e], enumerable: !0 });
}, G2 = "@liveblocks/core", qi = "1.12.0", K8 = "esm", ga = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}, Y8 = "https://liveblocks.io/docs/errors/cross-linked", Z8 = "https://liveblocks.io/docs/errors/dupes", Yp = " ";
function Zp(n) {
  if (process.env.NODE_ENV === "production")
    console.error(n);
  else
    throw new Error(n);
}
function Hu(n, t, e) {
  const s = Symbol.for(n), i = e ? `${t || "dev"} (${e})` : t || "dev";
  if (!ga[s])
    ga[s] = i;
  else if (ga[s] !== i) {
    const r = [
      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${Z8 + Yp}`,
      "",
      "Conflicts:",
      `- ${n} ${ga[s]} (already loaded)`,
      `- ${n} ${i} (trying to load this now)`
    ].join(`
`);
    Zp(r);
  }
  t && qi && t !== qi && Zp(
    [
      `Cross-linked versions of Liveblocks found, which will cause issues! See ${Y8 + Yp}`,
      "",
      "Conflicts:",
      `- ${G2} is at ${qi}`,
      `- ${n} is at ${t}`,
      "",
      "Always upgrade all Liveblocks packages to the same version number."
    ].join(`
`)
  );
}
function ys(n, t) {
  throw new Error(t);
}
function q8(n, t) {
  if (process.env.NODE_ENV !== "production" && !n) {
    const e = new Error(t);
    throw e.name = "Assertion failure", e;
  }
}
function nt(n, t = "Expected value to be non-nullable") {
  return q8(n != null, t), n;
}
function X8() {
  let n;
  const t = new Promise((e) => {
    n = e;
  });
  if (!n)
    throw new Error("Should never happen");
  return [t, n];
}
function It() {
  const n = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
  let e = null;
  function s() {
    e = [];
  }
  function i() {
    if (e !== null) {
      for (const u of e)
        l(u);
      e = null;
    }
  }
  function r(u) {
    return t.add(u), () => t.delete(u);
  }
  function o(u) {
    return n.add(u), () => n.delete(u);
  }
  async function a(u) {
    let f;
    return new Promise((p) => {
      f = r((m) => {
        (u === void 0 || u(m)) && p(m);
      });
    }).finally(() => f == null ? void 0 : f());
  }
  function c(u) {
    e !== null ? e.push(u) : l(u);
  }
  function l(u) {
    n.forEach((f) => f(u)), n.clear(), t.forEach((f) => f(u));
  }
  function h() {
    n.clear(), t.clear();
  }
  function d() {
    return n.size + t.size;
  }
  return {
    // Private/internal control over event emission
    notify: c,
    subscribe: r,
    subscribeOnce: o,
    clear: h,
    count: d,
    waitUntil: a,
    pause: s,
    unpause: i,
    // Publicly exposable subscription API
    observable: {
      subscribe: r,
      subscribeOnce: o,
      waitUntil: a
    }
  };
}
var J8 = {};
W8(J8, {
  error: () => zu,
  errorWithTitle: () => Wu,
  warn: () => hs,
  warnWithTitle: () => K2
});
var H2 = "background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;", Q8 = "font-weight:600";
function z2(n) {
  return typeof window > "u" || process.env.NODE_ENV === "test" ? console[n] : (
    /* istanbul ignore next */
    (t, ...e) => console[n]("%cLiveblocks", H2, t, ...e)
  );
}
var hs = z2("warn"), zu = z2("error");
function W2(n) {
  return typeof window > "u" || process.env.NODE_ENV === "test" ? console[n] : (
    /* istanbul ignore next */
    (t, e, ...s) => console[n](
      `%cLiveblocks%c ${t}`,
      H2,
      Q8,
      e,
      ...s
    )
  );
}
var K2 = W2("warn"), Wu = W2("error");
function t7(n, t) {
  if (n === t)
    return [0, 0];
  const e = n.split("."), s = t.split("."), i = Math.min(e.length, s.length);
  let r = 0;
  for (; r < i && e[r] === s[r]; r++)
    ;
  const o = e.length - r, a = s.length - r;
  return [o, a];
}
function e7(n, t) {
  const e = n.split(".");
  if (t < 1 || t > e.length + 1)
    throw new Error("Invalid number of levels");
  const s = [];
  t > e.length && s.push("*");
  for (let i = e.length - t + 1; i < e.length; i++) {
    const r = e.slice(0, i);
    r.length > 0 && s.push(r.join(".") + ".*");
  }
  return s.push(n), s;
}
var s7 = class {
  constructor(n) {
    this.curr = n;
  }
  get current() {
    return this.curr;
  }
  /**
   * Call a callback function that allows patching of the context, by
   * calling `context.patch()`. Patching is only allowed for the duration
   * of this window.
   */
  allowPatching(n) {
    const t = this;
    let e = !0;
    const s = {
      ...this.curr,
      patch(i) {
        if (e) {
          t.curr = Object.assign({}, t.curr, i);
          for (const r of Object.entries(i)) {
            const [o, a] = r;
            o !== "patch" && (this[o] = a);
          }
        } else
          throw new Error("Can no longer patch stale context");
      }
    };
    n(s), e = !1;
  }
}, n7 = 1, i7 = class {
  /**
   * Returns the initial state, which is defined by the first call made to
   * .addState().
   */
  get initialState() {
    const n = this.states.values()[Symbol.iterator]().next();
    if (n.done)
      throw new Error("No states defined yet");
    return n.value;
  }
  get currentState() {
    if (this.currentStateOrNull === null)
      throw this.runningState === 0 ? new Error("Not started yet") : new Error("Already stopped");
    return this.currentStateOrNull;
  }
  /**
   * Starts the machine by entering the initial state.
   */
  start() {
    if (this.runningState !== 0)
      throw new Error("State machine has already started");
    return this.runningState = 1, this.currentStateOrNull = this.initialState, this.enter(null), this;
  }
  /**
   * Stops the state machine. Stopping the state machine will call exit
   * handlers for the current state, but not enter a new state.
   */
  stop() {
    if (this.runningState !== 1)
      throw new Error("Cannot stop a state machine that hasn't started yet");
    this.exit(null), this.runningState = 2, this.currentStateOrNull = null;
  }
  constructor(n) {
    this.id = n7++, this.runningState = 0, this.currentStateOrNull = null, this.states = /* @__PURE__ */ new Set(), this.enterFns = /* @__PURE__ */ new Map(), this.cleanupStack = [], this.knownEventTypes = /* @__PURE__ */ new Set(), this.allowedTransitions = /* @__PURE__ */ new Map(), this.currentContext = new s7(n), this.eventHub = {
      didReceiveEvent: It(),
      willTransition: It(),
      didIgnoreEvent: It(),
      willExitState: It(),
      didEnterState: It()
    }, this.events = {
      didReceiveEvent: this.eventHub.didReceiveEvent.observable,
      willTransition: this.eventHub.willTransition.observable,
      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,
      willExitState: this.eventHub.willExitState.observable,
      didEnterState: this.eventHub.didEnterState.observable
    };
  }
  get context() {
    return this.currentContext.current;
  }
  /**
   * Define an explicit finite state in the state machine.
   */
  addState(n) {
    if (this.runningState !== 0)
      throw new Error("Already started");
    return this.states.add(n), this;
  }
  onEnter(n, t) {
    if (this.runningState !== 0)
      throw new Error("Already started");
    if (this.enterFns.has(n))
      throw new Error(
        // TODO We _currently_ don't support multiple .onEnters() for the same
        // state, but this is not a fundamental limitation. Just not
        // implemented yet. If we wanted to, we could make this an array.
        `enter/exit function for ${n} already exists`
      );
    return this.enterFns.set(n, t), this;
  }
  onEnterAsync(n, t, e, s) {
    return this.onEnter(n, () => {
      const i = new AbortController(), r = i.signal;
      let o = !1;
      return t(this.currentContext.current, r).then(
        // On OK
        (a) => {
          r.aborted || (o = !0, this.transition({ type: "ASYNC_OK", data: a }, e));
        },
        // On Error
        (a) => {
          r.aborted || (o = !0, this.transition({ type: "ASYNC_ERROR", reason: a }, s));
        }
      ), () => {
        o || i.abort();
      };
    });
  }
  getStatesMatching(n) {
    const t = [];
    if (n === "*")
      for (const e of this.states)
        t.push(e);
    else if (n.endsWith(".*")) {
      const e = n.slice(0, -1);
      for (const s of this.states)
        s.startsWith(e) && t.push(s);
    } else {
      const e = n;
      this.states.has(e) && t.push(e);
    }
    if (t.length === 0)
      throw new Error(`No states match ${JSON.stringify(n)}`);
    return t;
  }
  /**
   * Define all allowed outgoing transitions for a state.
   *
   * The targets for each event can be defined as a function which returns the
   * next state to transition to. These functions can look at the `event` or
   * `context` params to conditionally decide which next state to transition
   * to.
   *
   * If you set it to `null`, then the transition will be explicitly forbidden
   * and throw an error. If you don't define a target for a transition, then
   * such events will get ignored.
   */
  addTransitions(n, t) {
    if (this.runningState !== 0)
      throw new Error("Already started");
    for (const e of this.getStatesMatching(n)) {
      let s = this.allowedTransitions.get(e);
      s === void 0 && (s = /* @__PURE__ */ new Map(), this.allowedTransitions.set(e, s));
      for (const [i, r] of Object.entries(t)) {
        if (s.has(i))
          throw new Error(
            `Trying to set transition "${i}" on "${e}" (via "${n}"), but a transition already exists there.`
          );
        const o = r;
        if (this.knownEventTypes.add(i), o !== void 0) {
          const a = typeof o == "function" ? o : () => o;
          s.set(i, a);
        }
      }
    }
    return this;
  }
  /**
   * Like `.addTransition()`, but takes an (anonymous) transition whenever the
   * timer fires.
   *
   * @param stateOrPattern The state name, or state group pattern name.
   * @param after          Number of milliseconds after which to take the
   *                       transition. If in the mean time, another transition
   *                       is taken, the timer will get cancelled.
   * @param target     The target state to go to.
   */
  addTimedTransition(n, t, e) {
    return this.onEnter(n, () => {
      const s = typeof t == "function" ? t(this.currentContext.current) : t, i = setTimeout(() => {
        this.transition({ type: "TIMER" }, e);
      }, s);
      return () => {
        clearTimeout(i);
      };
    });
  }
  getTargetFn(n) {
    var t;
    return (t = this.allowedTransitions.get(this.currentState)) == null ? void 0 : t.get(n);
  }
  /**
   * Exits the current state, and executes any necessary cleanup functions.
   * Call this before changing the current state to the next state.
   *
   * @param levels Defines how many "levels" of nesting will be
   * exited. For example, if you transition from `foo.bar.qux` to
   * `foo.bar.baz`, then the level is 1. But if you transition from
   * `foo.bar.qux` to `bla.bla`, then the level is 3.
   * If `null`, it will exit all levels.
   */
  exit(n) {
    this.eventHub.willExitState.notify(this.currentState), this.currentContext.allowPatching((t) => {
      var e;
      n = n ?? this.cleanupStack.length;
      for (let s = 0; s < n; s++)
        (e = this.cleanupStack.pop()) == null || e(t);
    });
  }
  /**
   * Enters the current state, and executes any necessary onEnter handlers.
   * Call this directly _after_ setting the current state to the next state.
   */
  enter(n) {
    const t = e7(
      this.currentState,
      n ?? this.currentState.split(".").length + 1
    );
    this.currentContext.allowPatching((e) => {
      for (const s of t) {
        const i = this.enterFns.get(s), r = i == null ? void 0 : i(e);
        typeof r == "function" ? this.cleanupStack.push(r) : this.cleanupStack.push(null);
      }
    }), this.eventHub.didEnterState.notify(this.currentState);
  }
  /**
   * Sends an event to the machine, which may cause an internal state
   * transition to happen. When that happens, will trigger side effects.
   */
  send(n) {
    if (!this.knownEventTypes.has(n.type))
      throw new Error(`Invalid event ${JSON.stringify(n.type)}`);
    if (this.runningState === 2)
      return;
    const t = this.getTargetFn(n.type);
    if (t !== void 0)
      return this.transition(n, t);
    this.eventHub.didIgnoreEvent.notify(n);
  }
  transition(n, t) {
    this.eventHub.didReceiveEvent.notify(n);
    const e = this.currentState, i = (typeof t == "function" ? t : () => t)(n, this.currentContext.current);
    let r, o;
    if (i === null) {
      this.eventHub.didIgnoreEvent.notify(n);
      return;
    }
    if (typeof i == "string" ? r = i : (r = i.target, o = Array.isArray(i.effect) ? i.effect : [i.effect]), !this.states.has(r))
      throw new Error(`Invalid next state name: ${JSON.stringify(r)}`);
    this.eventHub.willTransition.notify({ from: e, to: r });
    const [a, c] = t7(this.currentState, r);
    if (a > 0 && this.exit(a), this.currentStateOrNull = r, o !== void 0) {
      const l = o;
      this.currentContext.allowPatching((h) => {
        for (const d of l)
          typeof d == "function" ? d(h, n) : h.patch(d);
      });
    }
    c > 0 && this.enter(c);
  }
};
function Y2(n) {
  return n !== null && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]";
}
function Z2(n) {
  return Object.entries(n);
}
function Ku(n) {
  try {
    return JSON.parse(n);
  } catch {
    return;
  }
}
function Po(n) {
  return JSON.parse(JSON.stringify(n));
}
function r7(n) {
  try {
    const t = n.replace(/-/g, "+").replace(/_/g, "/");
    return decodeURIComponent(
      atob(t).split("").map(function(s) {
        return "%" + ("00" + s.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
  } catch {
    return atob(n);
  }
}
function Sd(n) {
  return n.filter(
    (t) => t != null
  );
}
function Xc(n) {
  const t = { ...n };
  return Object.keys(n).forEach((e) => {
    const s = e;
    t[s] === void 0 && delete t[s];
  }), t;
}
async function qp(n, t, e) {
  let s;
  const i = new Promise((r, o) => {
    s = setTimeout(() => {
      o(new Error(e));
    }, t);
  });
  return Promise.race([n, i]).finally(() => clearTimeout(s));
}
function Xp(n) {
  return n === 4999 || n >= 4e3 && n < 4100;
}
function o7(n) {
  return n >= 4100 && n < 4200;
}
function Jp(n) {
  return n === 1013 || n >= 4200 && n < 4300;
}
function a7(n) {
  return n === "initial" || n === "disconnected";
}
function q2(n) {
  switch (n) {
    case "connecting":
      return "connecting";
    case "connected":
      return "open";
    case "reconnecting":
      return "unavailable";
    case "disconnected":
      return "failed";
    case "initial":
      return "closed";
    default:
      return "closed";
  }
}
function X2(n) {
  const t = n.currentState;
  switch (t) {
    case "@ok.connected":
    case "@ok.awaiting-pong":
      return "connected";
    case "@idle.initial":
      return "initial";
    case "@auth.busy":
    case "@auth.backoff":
    case "@connecting.busy":
    case "@connecting.backoff":
    case "@idle.zombie":
      return n.context.successCount > 0 ? "reconnecting" : "connecting";
    case "@idle.failed":
      return "disconnected";
    default:
      return ys(t, "Unknown state");
  }
}
var J2 = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4], ma = J2[0] - 1, c7 = [2e3, 3e4, 6e4, 3e5], l7 = 3e4, h7 = 2e3, d7 = 1e4, u7 = 1e4, qn = class extends Error {
  constructor(n) {
    super(n);
  }
}, f7 = class extends Error {
  /** @internal */
  constructor(n, t) {
    super(n), this.code = t;
  }
};
function Q2(n, t) {
  return t.find((e) => e > n) ?? t[t.length - 1];
}
function Oi(n) {
  n.patch({
    backoffDelay: Q2(n.backoffDelay, J2)
  });
}
function Qp(n) {
  n.patch({
    backoffDelay: Q2(n.backoffDelay, c7)
  });
}
function t0(n) {
  n.patch({ successCount: 0 });
}
function Ui(n, t) {
  const e = n === 2 ? zu : n === 1 ? hs : (
    /* black hole */
    () => {
    }
  );
  return () => {
    e(t);
  };
}
function e0(n) {
  const t = "Connection to Liveblocks websocket server";
  return (e) => {
    n instanceof Error ? hs(`${t} could not be established. ${String(n)}`) : hs(
      tm(n) ? `${t} closed prematurely (code: ${n.code}). Retrying in ${e.backoffDelay}ms.` : `${t} could not be established.`
    );
  };
}
function bh(n) {
  const t = [`code: ${n.code}`];
  return n.reason && t.push(`reason: ${n.reason}`), (e) => {
    hs(
      `Connection to Liveblocks websocket server closed (${t.join(", ")}). Retrying in ${e.backoffDelay}ms.`
    );
  };
}
var p7 = Ui(
  1,
  "Connection to WebSocket closed permanently. Won't retry."
);
function tm(n) {
  return !(n instanceof Error) && n.type === "close";
}
function g7(n) {
  const t = (/* @__PURE__ */ new Date()).getTime();
  function e(...i) {
    hs(
      `${(((/* @__PURE__ */ new Date()).getTime() - t) / 1e3).toFixed(2)} [FSM #${n.id}]`,
      ...i
    );
  }
  const s = [
    n.events.didReceiveEvent.subscribe((i) => e(`Event ${i.type}`)),
    n.events.willTransition.subscribe(
      ({ from: i, to: r }) => e("Transitioning", i, "", r)
    ),
    n.events.didIgnoreEvent.subscribe(
      (i) => e("Ignored event", i.type, i, "(current state won't handle it)")
    )
    // machine.events.willExitState.subscribe((s) => log("Exiting state", s)),
    // machine.events.didEnterState.subscribe((s) => log("Entering state", s)),
  ];
  return () => {
    for (const i of s)
      i();
  };
}
function m7(n) {
  const t = It(), e = It(), s = It();
  let i = null;
  const r = n.events.didEnterState.subscribe(() => {
    const o = X2(n);
    o !== i && t.notify(o), i === "connected" && o !== "connected" ? s.notify() : i !== "connected" && o === "connected" && e.notify(), i = o;
  });
  return {
    statusDidChange: t.observable,
    didConnect: e.observable,
    didDisconnect: s.observable,
    unsubscribe: r
  };
}
var _a = (n) => (t) => t.patch(n);
function _7(n, t) {
  const e = It();
  e.pause();
  const s = It();
  function i(b, g) {
    return () => {
      const y = new f7(b, g);
      s.notify(y);
    };
  }
  const r = {
    successCount: 0,
    authValue: null,
    socket: null,
    backoffDelay: ma
  }, o = new i7(r).addState("@idle.initial").addState("@idle.failed").addState("@idle.zombie").addState("@auth.busy").addState("@auth.backoff").addState("@connecting.busy").addState("@connecting.backoff").addState("@ok.connected").addState("@ok.awaiting-pong");
  o.addTransitions("*", {
    RECONNECT: {
      target: "@auth.backoff",
      effect: [Oi, t0]
    },
    DISCONNECT: "@idle.initial"
  }), o.onEnter("@idle.*", t0).addTransitions("@idle.*", {
    CONNECT: (b, g) => (
      // If we still have a known authValue, try to reconnect to the socket directly,
      // otherwise, try to obtain a new authValue
      g.authValue !== null ? "@connecting.busy" : "@auth.busy"
    )
  }), o.addTransitions("@auth.backoff", {
    NAVIGATOR_ONLINE: {
      target: "@auth.busy",
      effect: _a({ backoffDelay: ma })
    }
  }).addTimedTransition(
    "@auth.backoff",
    (b) => b.backoffDelay,
    "@auth.busy"
  ).onEnterAsync(
    "@auth.busy",
    () => qp(
      n.authenticate(),
      d7,
      "Timed out during auth"
    ),
    // On successful authentication
    (b) => ({
      target: "@connecting.busy",
      effect: _a({
        authValue: b.data
      })
    }),
    // Auth failed
    (b) => b.reason instanceof qn ? {
      target: "@idle.failed",
      effect: [
        Ui(2, b.reason.message),
        i(b.reason.message, -1)
      ]
    } : {
      target: "@auth.backoff",
      effect: [
        Oi,
        Ui(
          2,
          `Authentication failed: ${b.reason instanceof Error ? b.reason.message : String(b.reason)}`
        )
      ]
    }
  );
  const a = (b) => o.send({ type: "EXPLICIT_SOCKET_ERROR", event: b }), c = (b) => o.send({ type: "EXPLICIT_SOCKET_CLOSE", event: b }), l = (b) => b.data === "pong" ? o.send({ type: "PONG" }) : e.notify(b);
  function h(b) {
    b && (b.removeEventListener("error", a), b.removeEventListener("close", c), b.removeEventListener("message", l), b.close());
  }
  o.addTransitions("@connecting.backoff", {
    NAVIGATOR_ONLINE: {
      target: "@connecting.busy",
      effect: _a({ backoffDelay: ma })
    }
  }).addTimedTransition(
    "@connecting.backoff",
    (b) => b.backoffDelay,
    "@connecting.busy"
  ).onEnterAsync(
    "@connecting.busy",
    //
    // Use the "createSocket" delegate function (provided to the
    // ManagedSocket) to create the actual WebSocket connection instance.
    // Then, set up all the necessary event listeners, and wait for the
    // "open" event to occur.
    //
    // When the "open" event happens, we're ready to transition to the
    // OK state. This is done by resolving the Promise.
    //
    async (b, g) => {
      let y = null, S = null;
      const w = new Promise(
        (k, C) => {
          if (b.authValue === null)
            throw new Error("No auth authValue");
          const A = n.createSocket(b.authValue);
          S = A;
          function E(F) {
            y = F, A.removeEventListener("message", l), C(F);
          }
          const [I, P] = X8();
          t.waitForActorId || P();
          function M(F) {
            const V = Ku(F.data);
            (V == null ? void 0 : V.type) === 104 && P();
          }
          A.addEventListener("message", l), t.waitForActorId && A.addEventListener("message", M), A.addEventListener("error", E), A.addEventListener("close", E), A.addEventListener("open", () => {
            A.addEventListener("error", a), A.addEventListener("close", c);
            const F = () => {
              A.removeEventListener("error", E), A.removeEventListener("close", E), A.removeEventListener("message", M);
            };
            I.then(() => {
              k([A, F]);
            });
          });
        }
      );
      return qp(
        w,
        u7,
        "Timed out during websocket connection"
      ).then(
        //
        // Part 3:
        // By now, our "open" event has fired, and the promise has been
        // resolved. Two possible scenarios:
        //
        // 1. The happy path. Most likely.
        // 2. Uh-oh. A premature close/error event has been observed. Let's
        //    reject the promise after all.
        //
        // Any close/error event that will get scheduled after this point
        // onwards, will be caught in the OK state, and dealt with
        // accordingly.
        //
        ([k, C]) => {
          if (C(), g.aborted)
            throw new Error("Aborted");
          if (y)
            throw y;
          return k;
        }
      ).catch((k) => {
        throw h(S), k;
      });
    },
    // Only transition to OK state after a successfully opened WebSocket connection
    (b) => ({
      target: "@ok.connected",
      effect: _a({
        socket: b.data,
        backoffDelay: ma
      })
    }),
    // If the WebSocket connection cannot be established
    (b) => {
      const g = b.reason;
      if (g instanceof qn)
        return {
          target: "@idle.failed",
          effect: [
            Ui(2, g.message),
            i(g.message, -1)
          ]
        };
      if (tm(g)) {
        if (g.code === 4109)
          return "@auth.busy";
        if (Jp(g.code))
          return {
            target: "@connecting.backoff",
            effect: [
              Qp,
              e0(g)
            ]
          };
        if (Xp(g.code))
          return {
            target: "@idle.failed",
            effect: [
              Ui(2, g.reason),
              i(g.reason, g.code)
            ]
          };
      }
      return {
        target: "@auth.backoff",
        effect: [Oi, e0(g)]
      };
    }
  );
  const d = {
    target: "@ok.awaiting-pong",
    effect: (b) => {
      var g;
      (g = b.socket) == null || g.send("ping");
    }
  }, u = () => {
    const b = typeof document < "u" ? document : void 0;
    return (b == null ? void 0 : b.visibilityState) === "hidden" && n.canZombie() ? "@idle.zombie" : d;
  };
  if (o.addTimedTransition("@ok.connected", l7, u).addTransitions("@ok.connected", {
    NAVIGATOR_OFFLINE: u,
    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.
    WINDOW_GOT_FOCUS: d
  }), o.addTransitions("@idle.zombie", {
    WINDOW_GOT_FOCUS: "@connecting.backoff"
    // When in zombie state, the client will try to wake up automatically when the window regains focus
  }), o.onEnter("@ok.*", (b) => {
    b.patch({ successCount: b.successCount + 1 });
    const g = setTimeout(
      // On the next tick, start delivering all messages that have already
      // been received, and continue synchronous delivery of all future
      // incoming messages.
      e.unpause,
      0
    );
    return (y) => {
      h(y.socket), y.patch({ socket: null }), clearTimeout(g), e.pause();
    };
  }).addTransitions("@ok.awaiting-pong", { PONG: "@ok.connected" }).addTimedTransition("@ok.awaiting-pong", h7, {
    target: "@connecting.busy",
    // Log implicit connection loss and drop the current open socket
    effect: Ui(
      1,
      "Received no pong from server, assume implicit connection loss."
    )
  }).addTransitions("@ok.*", {
    // When a socket receives an error, this can cause the closing of the
    // socket, or not. So always check to see if the socket is still OPEN or
    // not. When still OPEN, don't transition.
    EXPLICIT_SOCKET_ERROR: (b, g) => {
      var y;
      return ((y = g.socket) == null ? void 0 : y.readyState) === 1 ? null : {
        target: "@connecting.backoff",
        effect: Oi
      };
    },
    EXPLICIT_SOCKET_CLOSE: (b) => Xp(b.event.code) ? {
      target: "@idle.failed",
      effect: [
        p7,
        i(b.event.reason, b.event.code)
      ]
    } : o7(b.event.code) ? b.event.code === 4109 ? "@auth.busy" : {
      target: "@auth.backoff",
      effect: [Oi, bh(b.event)]
    } : Jp(b.event.code) ? {
      target: "@connecting.backoff",
      effect: [Qp, bh(b.event)]
    } : {
      target: "@connecting.backoff",
      effect: [Oi, bh(b.event)]
    }
  }), typeof document < "u") {
    const b = typeof document < "u" ? document : void 0, g = typeof window < "u" ? window : void 0, y = g ?? b;
    o.onEnter("*", (S) => {
      function w() {
        o.send({ type: "NAVIGATOR_OFFLINE" });
      }
      function k() {
        o.send({ type: "NAVIGATOR_ONLINE" });
      }
      function C() {
        (b == null ? void 0 : b.visibilityState) === "visible" && o.send({ type: "WINDOW_GOT_FOCUS" });
      }
      return g == null || g.addEventListener("online", k), g == null || g.addEventListener("offline", w), y == null || y.addEventListener("visibilitychange", C), () => {
        y == null || y.removeEventListener("visibilitychange", C), g == null || g.removeEventListener("online", k), g == null || g.removeEventListener("offline", w), h(S.socket);
      };
    });
  }
  const f = [], { statusDidChange: p, didConnect: m, didDisconnect: _, unsubscribe: v } = m7(o);
  return f.push(v), t.enableDebugLogging && f.push(g7(o)), o.start(), {
    machine: o,
    cleanups: f,
    // Observable events that will be emitted by this machine
    events: {
      statusDidChange: p,
      didConnect: m,
      didDisconnect: _,
      onMessage: e.observable,
      onLiveblocksError: s.observable
    }
  };
}
var y7 = class {
  constructor(n, t = !1, e = !0) {
    const { machine: s, events: i, cleanups: r } = _7(
      n,
      { waitForActorId: e, enableDebugLogging: t }
    );
    this.machine = s, this.events = i, this.cleanups = r;
  }
  getLegacyStatus() {
    return q2(this.getStatus());
  }
  getStatus() {
    try {
      return X2(this.machine);
    } catch {
      return "initial";
    }
  }
  /**
   * Returns the current auth authValue.
   */
  get authValue() {
    return this.machine.context.authValue;
  }
  /**
   * Call this method to try to connect to a WebSocket. This only has an effect
   * if the machine is idle at the moment, otherwise this is a no-op.
   */
  connect() {
    this.machine.send({ type: "CONNECT" });
  }
  /**
   * If idle, will try to connect. Otherwise, it will attempt to reconnect to
   * the socket, potentially obtaining a new authValue first, if needed.
   */
  reconnect() {
    this.machine.send({ type: "RECONNECT" });
  }
  /**
   * Call this method to disconnect from the current WebSocket. Is going to be
   * a no-op if there is no active connection.
   */
  disconnect() {
    this.machine.send({ type: "DISCONNECT" });
  }
  /**
   * Call this to stop the machine and run necessary cleanup functions. After
   * calling destroy(), you can no longer use this instance. Call this before
   * letting the instance get garbage collected.
   */
  destroy() {
    this.machine.stop();
    let n;
    for (; n = this.cleanups.pop(); )
      n();
  }
  /**
   * Safely send a message to the current WebSocket connection. Will emit a log
   * message if this is somehow impossible.
   */
  send(n) {
    var e;
    const t = (e = this.machine.context) == null ? void 0 : e.socket;
    t === null ? hs("Cannot send: not connected yet", n) : t.readyState !== 1 ? hs("Cannot send: WebSocket no longer open", n) : t.send(n);
  }
  /**
   * NOTE: Used by the E2E app only, to simulate explicit events.
   * Not ideal to keep exposed :(
   */
  _privateSendMachineEvent(n) {
    this.machine.send(n);
  }
};
function Cd(n) {
  return n.includes(
    "room:write"
    /* Write */
  );
}
function em(n) {
  return n.includes(
    "comments:write"
    /* CommentsWrite */
  ) || n.includes(
    "room:write"
    /* Write */
  );
}
function v7(n) {
  return Y2(n) && (n.k === "acc" || n.k === "id" || n.k === "sec-legacy");
}
function s0(n) {
  const t = n.split(".");
  if (t.length !== 3)
    throw new Error("Authentication error: invalid JWT token");
  const e = Ku(r7(t[1]));
  if (!(e && v7(e)))
    throw new Error(
      "Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
    );
  return {
    raw: n,
    parsed: e
  };
}
function b7(n) {
  const t = w7(n), e = /* @__PURE__ */ new Set(), s = [], i = [], r = /* @__PURE__ */ new Map();
  function o() {
    e.clear(), s.length = 0, i.length = 0, r.clear();
  }
  function a(d, u) {
    return d === "comments:read" ? u.includes(
      "comments:read"
      /* CommentsRead */
    ) || u.includes(
      "comments:write"
      /* CommentsWrite */
    ) || u.includes(
      "room:read"
      /* Read */
    ) || u.includes(
      "room:write"
      /* Write */
    ) : d === "room:read" ? u.includes(
      "room:read"
      /* Read */
    ) || u.includes(
      "room:write"
      /* Write */
    ) : !1;
  }
  function c(d) {
    const u = Math.ceil(Date.now() / 1e3);
    for (let f = s.length - 1; f >= 0; f--) {
      const p = s[f];
      if (i[f] <= u) {
        s.splice(f, 1), i.splice(f, 1);
        continue;
      }
      if (p.parsed.k === "id")
        return p;
      if (p.parsed.k === "acc") {
        if (!d.roomId && Object.entries(p.parsed.perms).length === 0)
          return p;
        for (const [_, v] of Object.entries(p.parsed.perms))
          if (d.roomId) {
            if (_.includes("*") && d.roomId.startsWith(_.replace("*", "")) || d.roomId === _ && a(d.requestedScope, v))
              return p;
          } else if (_.includes("*") && a(d.requestedScope, v))
            return p;
      }
    }
  }
  async function l(d) {
    var f;
    const u = ((f = n.polyfills) == null ? void 0 : f.fetch) ?? (typeof window > "u" ? void 0 : window.fetch);
    if (t.type === "private") {
      if (u === void 0)
        throw new qn(
          "To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill."
        );
      const p = await S7(u, t.url, {
        room: d.roomId
      }), m = s0(p.token);
      if (e.has(m.raw))
        throw new qn(
          "The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported."
        );
      return m;
    }
    if (t.type === "custom") {
      const p = await t.callback(d.roomId);
      if (p && typeof p == "object") {
        if (typeof p.token == "string")
          return s0(p.token);
        if (typeof p.error == "string") {
          const m = `Authentication failed: ${"reason" in p && typeof p.reason == "string" ? p.reason : "Forbidden"}`;
          throw p.error === "forbidden" ? new qn(m) : new Error(m);
        }
      }
      throw new Error(
        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: "..." }'
      );
    }
    throw new Error(
      "Unexpected authentication type. Must be private or custom."
    );
  }
  async function h(d) {
    if (t.type === "public")
      return { type: "public", publicApiKey: t.publicApiKey };
    const u = c(d);
    if (u !== void 0)
      return { type: "secret", token: u };
    let f;
    d.roomId ? (f = r.get(d.roomId), f === void 0 && (f = l(d), r.set(d.roomId, f))) : (f = r.get("liveblocks-user-token"), f === void 0 && (f = l(d), r.set("liveblocks-user-token", f)));
    try {
      const p = await f, _ = Math.floor(Date.now() / 1e3) + (p.parsed.exp - p.parsed.iat) - 30;
      return e.add(p.raw), p.parsed.k !== "sec-legacy" && (s.push(p), i.push(_)), { type: "secret", token: p };
    } finally {
      d.roomId ? r.delete(d.roomId) : r.delete("liveblocks-user-token");
    }
  }
  return {
    reset: o,
    getAuthValue: h
  };
}
function w7(n) {
  const { publicApiKey: t, authEndpoint: e } = n;
  if (e !== void 0 && t !== void 0)
    throw new Error(
      "You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  if (typeof t == "string") {
    if (t.startsWith("sk_"))
      throw new Error(
        "Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    if (!t.startsWith("pk_"))
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    return {
      type: "public",
      publicApiKey: t
    };
  }
  if (typeof e == "string")
    return {
      type: "private",
      url: e
    };
  if (typeof e == "function")
    return {
      type: "custom",
      callback: e
    };
  throw e !== void 0 ? new Error(
    "The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
  ) : new Error(
    "Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
async function S7(n, t, e) {
  const s = await n(t, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(e)
  });
  if (!s.ok) {
    const o = `${(await s.text()).trim() || "reason not provided in auth response"} (${s.status} returned by POST ${t})`;
    throw s.status === 401 || s.status === 403 ? new qn(`Unauthorized: ${o}`) : new Error(`Failed to authenticate: ${o}`);
  }
  let i;
  try {
    i = await s.json();
  } catch (o) {
    throw new Error(
      `Expected a JSON response when doing a POST request on "${t}". ${String(
        o
      )}`
    );
  }
  if (!Y2(i) || typeof i.token != "string")
    throw new Error(
      `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${t}", but got ${JSON.stringify(
        i
      )}`
    );
  const { token: r } = i;
  return { token: r };
}
var C7 = "https://api.liveblocks.io", Sn = Symbol(), sm = !1;
function k7(n) {
  sm = n;
}
function ds(n, t) {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const e = {
    ...n,
    source: "liveblocks-devtools-client"
  };
  (t != null && t.force || sm) && window.postMessage(e, "*");
}
var nm = It();
process.env.NODE_ENV !== "production" && typeof window < "u" && window.addEventListener("message", (n) => {
  var t;
  n.source === window && ((t = n.data) == null ? void 0 : t.source) === "liveblocks-devtools-panel" && nm.notify(n.data);
});
var im = nm.observable, rm = qi, n0 = !1;
function x7(n) {
  process.env.NODE_ENV === "production" || typeof window > "u" || n0 || (n0 = !0, im.subscribe((t) => {
    switch (t.msg) {
      case "connect": {
        k7(!0);
        for (const e of n())
          ds({
            msg: "room::available",
            roomId: e,
            clientVersion: rm
          });
        break;
      }
    }
  }), ds({ msg: "wake-up-devtools" }, { force: !0 }));
}
var kd = /* @__PURE__ */ new Map();
function Yu(n) {
  const t = kd.get(n) ?? [];
  kd.delete(n);
  for (const e of t)
    e();
}
function E7(n) {
  Yu(n.id), $7(n), kd.set(n.id, [
    // When the connection status changes
    n.events.status.subscribe(() => P7(n)),
    // When storage initializes, send the update
    n.events.storageDidLoad.subscribeOnce(() => i0(n)),
    // Any time storage updates, send the new storage root
    n.events.storage.subscribe(() => i0(n)),
    // Any time "me" or "others" updates, send the new values accordingly
    n.events.self.subscribe(() => M7(n)),
    n.events.others.subscribe(() => R7(n)),
    // Any time ydoc is updated, forward the update
    n.events.ydoc.subscribe((t) => T7(n, t)),
    // Any time a custom room event is received, forward it
    n.events.customEvent.subscribe(
      (t) => D7(n, t)
    )
  ]);
}
function T7(n, t) {
  ds({
    msg: "room::sync::ydoc",
    roomId: n.id,
    update: t
  });
}
var A7 = Date.now(), I7 = 0;
function O7() {
  return `event-${A7}-${I7++}`;
}
function D7(n, t) {
  ds({
    msg: "room::events::custom-event",
    roomId: n.id,
    event: {
      type: "CustomEvent",
      id: O7(),
      key: "Event",
      connectionId: t.connectionId,
      payload: t.event
    }
  });
}
function P7(n) {
  ds({
    msg: "room::sync::partial",
    roomId: n.id,
    status: n.getStatus()
  });
}
function i0(n) {
  const t = n.getStorageSnapshot();
  t && ds({
    msg: "room::sync::partial",
    roomId: n.id,
    storage: t.toTreeNode("root").payload
  });
}
function M7(n) {
  const t = n[Sn].getSelf_forDevTools();
  t && ds({
    msg: "room::sync::partial",
    roomId: n.id,
    me: t
  });
}
function R7(n) {
  const t = n[Sn].getOthers_forDevTools();
  t && ds({
    msg: "room::sync::partial",
    roomId: n.id,
    others: t
  });
}
function $7(n) {
  const t = n.getStorageSnapshot(), e = n[Sn].getSelf_forDevTools(), s = n[Sn].getOthers_forDevTools();
  n.fetchYDoc(""), ds({
    msg: "room::sync::full",
    roomId: n.id,
    status: n.getStatus(),
    storage: (t == null ? void 0 : t.toTreeNode("root").payload) ?? null,
    me: e,
    others: s
  });
}
var xd = /* @__PURE__ */ new Map();
function om(n) {
  const t = xd.get(n);
  xd.delete(n), t && t();
}
function N7(n, t) {
  process.env.NODE_ENV === "production" || typeof window > "u" || (ds({ msg: "room::available", roomId: n, clientVersion: rm }), om(n), xd.set(
    n,
    // Returns the unsubscribe callback, that we store in the
    // roomChannelListeners registry
    im.subscribe((e) => {
      switch (e.msg) {
        case "room::subscribe": {
          e.roomId === n && E7(t);
          break;
        }
        case "room::unsubscribe": {
          e.roomId === n && Yu(n);
          break;
        }
      }
    })
  ));
}
function L7(n) {
  process.env.NODE_ENV === "production" || typeof window > "u" || (Yu(n), om(n), ds({
    msg: "room::unavailable",
    roomId: n
  }));
}
function Ed(n, ...t) {
  if (typeof n != "object" || n === null || Array.isArray(n))
    return JSON.stringify(n, ...t);
  const e = Object.keys(n).sort().reduce(
    (s, i) => (s[i] = n[i], s),
    {}
  );
  return JSON.stringify(e, ...t);
}
var U7 = 50, F7 = 100, wh = () => {
}, B7 = class {
  constructor(n) {
    this.resolve = wh, this.reject = wh, this.promise = new Promise(wh), this.args = n;
  }
}, Zu = class {
  constructor(n, t) {
    this.queue = [], this.error = !1, this.callback = n, this.size = (t == null ? void 0 : t.size) ?? U7, this.delay = (t == null ? void 0 : t.delay) ?? F7;
  }
  clearDelayTimeout() {
    this.delayTimeoutId !== void 0 && (clearTimeout(this.delayTimeoutId), this.delayTimeoutId = void 0);
  }
  schedule() {
    this.queue.length === this.size ? this.flush() : this.queue.length === 1 && (this.clearDelayTimeout(), this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay));
  }
  async flush() {
    if (this.queue.length === 0)
      return;
    const n = this.queue.splice(0), t = n.map((e) => e.args);
    try {
      const e = await this.callback(t);
      this.error = !1, n.forEach((s, i) => {
        const r = e == null ? void 0 : e[i];
        Array.isArray(e) ? n.length !== e.length ? s.reject(
          new Error(
            `Callback must return an array of the same length as the number of provided items. Expected ${n.length}, but got ${e.length}.`
          )
        ) : r instanceof Error ? s.reject(r) : s.resolve(r) : s.reject(new Error("Callback must return an array."));
      });
    } catch (e) {
      this.error = !0, n.forEach((s) => {
        s.reject(e);
      });
    }
  }
  get(...n) {
    const t = this.queue.find(
      (s) => Ed(s.args) === Ed(n)
    );
    if (t)
      return t.promise;
    const e = new B7(n);
    return e.promise = new Promise((s, i) => {
      e.resolve = s, e.reject = i;
    }), this.queue.push(e), this.schedule(), e.promise;
  }
  clear() {
    this.queue = [], this.error = !1, this.clearDelayTimeout();
  }
};
function r0(n, t) {
  const e = new Zu(n, t), s = /* @__PURE__ */ new Map(), i = It();
  function r(l) {
    return Ed(l);
  }
  function o(l, h) {
    h ? s.set(l, h) : s.delete(l), i.notify(h);
  }
  async function a(...l) {
    const h = r(l);
    if (!s.has(h))
      try {
        o(h, { isLoading: !0 });
        const d = await e.get(...l);
        o(h, { isLoading: !1, data: d });
      } catch (d) {
        o(h, {
          isLoading: !1,
          error: d
        });
      }
  }
  function c(...l) {
    const h = r(l);
    return s.get(h);
  }
  return {
    ...i,
    get: a,
    getState: c
  };
}
function am(n) {
  let t = n;
  const e = /* @__PURE__ */ new Set();
  function s() {
    return t;
  }
  function i(o) {
    const a = o(t);
    if (t !== a) {
      t = a;
      for (const c of e)
        c(t);
    }
  }
  function r(o) {
    return e.add(o), o(t), () => {
      e.delete(o);
    };
  }
  return {
    get: s,
    set: i,
    subscribe: r
  };
}
var o0 = /* @__PURE__ */ new Set();
function V7(n, t = n) {
  process.env.NODE_ENV !== "production" && (o0.has(t) || (o0.add(t), Wu("Deprecation warning", n)));
}
function j7(n, t, e = t) {
  process.env.NODE_ENV !== "production" && n && V7(t, e);
}
function Td(n) {
  const t = n.editedAt ? new Date(n.editedAt) : void 0, e = new Date(n.createdAt), s = n.reactions.map((i) => ({
    ...i,
    createdAt: new Date(i.createdAt)
  }));
  if (n.body)
    return {
      ...n,
      reactions: s,
      createdAt: e,
      editedAt: t
    };
  {
    const i = new Date(n.deletedAt);
    return {
      ...n,
      reactions: s,
      createdAt: e,
      editedAt: t,
      deletedAt: i
    };
  }
}
function Ua(n) {
  const t = n.updatedAt ? new Date(n.updatedAt) : void 0, e = new Date(n.createdAt), s = n.comments.map(
    (i) => Td(i)
  );
  return {
    ...n,
    createdAt: e,
    updatedAt: t,
    comments: s
  };
}
function G7(n) {
  return {
    ...n,
    createdAt: new Date(n.createdAt)
  };
}
function Ad(n) {
  const t = new Date(n.notifiedAt), e = n.readAt ? new Date(n.readAt) : null;
  if ("activities" in n) {
    const s = n.activities.map((i) => ({
      ...i,
      createdAt: new Date(i.createdAt)
    }));
    return {
      ...n,
      notifiedAt: t,
      readAt: e,
      activities: s
    };
  }
  return {
    ...n,
    notifiedAt: t,
    readAt: e
  };
}
function cm(n) {
  const t = new Date(n.deletedAt);
  return {
    ...n,
    deletedAt: t
  };
}
function lm(n) {
  const t = new Date(n.deletedAt);
  return {
    ...n,
    deletedAt: t
  };
}
function H7(n) {
  const t = new URLSearchParams();
  for (const [e, s] of Object.entries(n))
    s != null && t.set(e, s.toString());
  return t;
}
function hm(n, t, e) {
  const s = new URL(t, n);
  return e !== void 0 && (s.search = (e instanceof URLSearchParams ? e : H7(e)).toString()), s.toString();
}
var z7 = 50;
function W7({
  baseUrl: n,
  authManager: t,
  currentUserIdStore: e,
  fetcher: s
}) {
  async function i(d, u, f) {
    const p = await t.getAuthValue({
      requestedScope: "comments:read"
    });
    if (p.type === "secret" && p.token.parsed.k === "acc") {
      const b = p.token.parsed.uid;
      e.set(() => b);
    }
    const m = hm(n, `/v2/c${d}`, f), _ = await s(m.toString(), {
      ...u,
      headers: {
        ...u == null ? void 0 : u.headers,
        Authorization: `Bearer ${Pd(p)}`
      }
    });
    if (!_.ok && _.status >= 400 && _.status < 600) {
      let b;
      try {
        const g = await _.json();
        b = new dc(
          g.message,
          _.status,
          g
        );
      } catch {
        b = new dc(
          _.statusText,
          _.status
        );
      }
      throw b;
    }
    let v;
    try {
      v = await _.json();
    } catch {
      v = {};
    }
    return v;
  }
  async function r(d) {
    var f;
    const u = await i("/inbox-notifications", void 0, {
      limit: d == null ? void 0 : d.limit,
      since: (f = d == null ? void 0 : d.since) == null ? void 0 : f.toISOString()
    });
    return {
      threads: u.threads.map((p) => Ua(p)),
      inboxNotifications: u.inboxNotifications.map(
        (p) => Ad(p)
      ),
      deletedThreads: u.deletedThreads.map(
        (p) => cm(p)
      ),
      deletedInboxNotifications: u.deletedInboxNotifications.map(
        (p) => lm(p)
      ),
      meta: {
        requestedAt: new Date(u.meta.requestedAt)
      }
    };
  }
  async function o() {
    const { count: d } = await i("/inbox-notifications/count");
    return d;
  }
  async function a() {
    await i("/inbox-notifications/read", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ inboxNotificationIds: "all" })
    });
  }
  async function c(d) {
    await i("/inbox-notifications/read", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ inboxNotificationIds: d })
    });
  }
  const l = new Zu(
    async (d) => {
      const u = d.flat();
      return await c(u), u;
    },
    { delay: z7 }
  );
  async function h(d) {
    await l.get(d);
  }
  return {
    getInboxNotifications: r,
    getUnreadInboxNotificationsCount: o,
    markAllInboxNotificationsAsRead: a,
    markInboxNotificationAsRead: h
  };
}
var is = 32, Cn = 126, K7 = Cn - is + 1, qu = Xu(0), Jc = Xu(1), Y7 = qu + Xu(-1);
function Xu(n) {
  const t = is + (n < 0 ? K7 + n : n);
  if (t < is || t > Cn)
    throw new Error(`Invalid n value: ${n}`);
  return String.fromCharCode(t);
}
function Ds(n, t) {
  return n !== void 0 && t !== void 0 ? X7(n, t) : n !== void 0 ? q7(n) : t !== void 0 ? Z7(t) : Jc;
}
function Z7(n) {
  const t = n.length - 1;
  for (let e = 0; e <= t; e++) {
    const s = n.charCodeAt(e);
    if (!(s <= is))
      return e === t ? s === is + 1 ? n.substring(0, e) + Y7 : n.substring(0, e) + String.fromCharCode(s - 1) : n.substring(0, e + 1);
  }
  return Jc;
}
function q7(n) {
  for (let t = 0; t <= n.length - 1; t++) {
    const e = n.charCodeAt(t);
    if (!(e >= Cn))
      return n.substring(0, t) + String.fromCharCode(e + 1);
  }
  return n + Jc;
}
function X7(n, t) {
  if (n < t)
    return Id(n, t);
  if (n > t)
    return Id(t, n);
  throw new Error("Cannot compute value between two equal positions");
}
function Id(n, t) {
  let e = 0;
  const s = n.length, i = t.length;
  for (; ; ) {
    const r = e < s ? n.charCodeAt(e) : is, o = e < i ? t.charCodeAt(e) : Cn;
    if (r === o) {
      e++;
      continue;
    }
    if (o - r === 1) {
      const a = e + 1;
      let c = n.substring(0, a);
      c.length < a && (c += qu.repeat(a - c.length));
      const l = n.substring(a);
      return c + Id(l, "");
    } else
      return J7(n, e) + String.fromCharCode(o + r >> 1);
  }
}
function J7(n, t) {
  return t < n.length ? n.substring(0, t) : n + qu.repeat(t - n.length);
}
var Q7 = is + 1;
function tb(n) {
  if (n === "")
    return !1;
  const t = n.length - 1, e = n.charCodeAt(t);
  if (e < Q7 || e > Cn)
    return !1;
  for (let s = 0; s < t; s++) {
    const i = n.charCodeAt(s);
    if (i < is || i > Cn)
      return !1;
  }
  return !0;
}
function eb(n) {
  const t = [];
  for (let e = 0; e < n.length; e++) {
    const s = n.charCodeAt(e);
    t.push(s < is ? is : s > Cn ? Cn : s);
  }
  for (; t.length > 0 && t[t.length - 1] === is; )
    t.length--;
  return t.length > 0 ? String.fromCharCode(...t) : (
    // Edge case: the str was a 0-only string, which is invalid. Default back to .1
    Jc
  );
}
function Mo(n) {
  return tb(n) ? n : eb(n);
}
function sb(n) {
  return n.type === 5 && n.id === "ACK";
}
function a0(n, t, e = Mo(t)) {
  return Object.freeze({ type: "HasParent", node: n, key: t, pos: e });
}
var c0 = Object.freeze({ type: "NoParent" });
function nb(n, t = Mo(n)) {
  return Object.freeze({ type: "Orphaned", oldKey: n, oldPos: t });
}
var Qc = class {
  constructor() {
    this._parent = c0;
  }
  /** @internal */
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return ys(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _parentPos() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.pos;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldPos;
      default:
        return ys(this.parent, "Unknown state");
    }
  }
  /** @internal */
  get _pool() {
    return this.__pool;
  }
  get roomId() {
    return this.__pool ? this.__pool.roomId : null;
  }
  /** @internal */
  get _id() {
    return this.__id;
  }
  /** @internal */
  get parent() {
    return this._parent;
  }
  /** @internal */
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return ys(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _apply(n, t) {
    switch (n.type) {
      case 5:
        return this.parent.type === "HasParent" ? this.parent.node._detachChild(this) : { modified: !1 };
    }
    return { modified: !1 };
  }
  /** @internal */
  _setParentLink(n, t) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== n)
          throw new Error("Cannot set parent: node already has a parent");
        this._parent = a0(n, t);
        return;
      case "Orphaned":
      case "NoParent": {
        this._parent = a0(n, t);
        return;
      }
      default:
        return ys(this.parent, "Unknown state");
    }
  }
  /** @internal */
  _attach(n, t) {
    if (this.__id || this.__pool)
      throw new Error("Cannot attach node: already attached");
    t.addNode(n, this), this.__id = n, this.__pool = t;
  }
  /** @internal */
  _detach() {
    switch (this.__pool && this.__id && this.__pool.deleteNode(this.__id), this.parent.type) {
      case "HasParent": {
        this._parent = nb(this.parent.key, this.parent.pos);
        break;
      }
      case "NoParent": {
        this._parent = c0;
        break;
      }
      case "Orphaned":
        break;
      default:
        ys(this.parent, "Unknown state");
    }
    this.__pool = void 0;
  }
  /**
   * @internal
   *
   * Clear the Immutable cache, so that the next call to `.toImmutable()` will
   * recompute the equivalent Immutable value again.  Call this after every
   * mutation to the Live node.
   */
  invalidate() {
    (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) && (this._cachedImmutable = void 0, this._cachedTreeNode = void 0, this.parent.type === "HasParent" && this.parent.node.invalidate());
  }
  /**
   * @internal
   *
   * Return an snapshot of this Live tree for use in DevTools.
   */
  toTreeNode(n) {
    return (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== n) && (this._cachedTreeNodeKey = n, this._cachedTreeNode = this._toTreeNode(n)), this._cachedTreeNode;
  }
  /**
   * Return an immutable snapshot of this Live node and its children.
   */
  toImmutable() {
    return this._cachedImmutable === void 0 && (this._cachedImmutable = this._toImmutable()), this._cachedImmutable;
  }
};
function ib(n) {
  return n.type === 0 && !rb(n);
}
function rb(n) {
  return n.parentId !== void 0 && n.parentKey !== void 0;
}
function tl(n = 7) {
  const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-", e = t.length;
  return Array.from(
    { length: n },
    () => t.charAt(Math.floor(Math.random() * e))
  ).join("");
}
var yi = class dm extends Qc {
  constructor(t) {
    super(), this._data = t;
  }
  get data() {
    return this._data;
  }
  /** @internal */
  static _deserialize([t, e], s, i) {
    const r = new dm(e.data);
    return r._attach(t, i), r;
  }
  /** @internal */
  _toOps(t, e, s) {
    if (this._id === void 0)
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    return [
      {
        type: 8,
        opId: s == null ? void 0 : s.generateOpId(),
        id: this._id,
        parentId: t,
        parentKey: e,
        data: this.data
      }
    ];
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent")
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    return {
      type: 3,
      parentId: nt(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data
    };
  }
  /** @internal */
  _attachChild(t) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _detachChild(t) {
    throw new Error("Method not implemented.");
  }
  /** @internal */
  _apply(t, e) {
    return super._apply(t, e);
  }
  /** @internal */
  _toTreeNode(t) {
    return {
      type: "Json",
      id: this._id ?? tl(),
      key: t,
      payload: this._data
    };
  }
  /** @internal */
  _toImmutable() {
    return this._data;
  }
  clone() {
    return Po(this.data);
  }
};
function ob(n, t) {
  const e = n._parentPos, s = t._parentPos;
  return e === s ? 0 : e < s ? -1 : 1;
}
var br = class Od extends Qc {
  constructor(t = []) {
    super(), this._items = [], this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet(), this._unacknowledgedSets = /* @__PURE__ */ new Map();
    let e;
    for (const s of t) {
      const i = Ds(e), r = Xi(s);
      r._setParentLink(this, i), this._items.push(r), e = i;
    }
  }
  /** @internal */
  static _deserialize([t], e, s) {
    const i = new Od();
    i._attach(t, s);
    const r = e.get(t);
    if (r === void 0)
      return i;
    for (const [o, a] of r) {
      const c = pm([o, a], e, s);
      c._setParentLink(i, a.parentKey), i._insertAndSort(c);
    }
    return i;
  }
  /**
   * @internal
   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'
   * so we mutate _unacknowledgedSets to avoid potential flickering
   * https://github.com/liveblocks/liveblocks/pull/1177
   *
   * This is quite unintuitive and should disappear as soon as
   * we introduce an explicit LiveList.Set operation
   */
  _toOps(t, e, s) {
    if (this._id === void 0)
      throw new Error("Cannot serialize item is not attached");
    const i = [], r = {
      id: this._id,
      opId: s == null ? void 0 : s.generateOpId(),
      type: 2,
      parentId: t,
      parentKey: e
    };
    i.push(r);
    for (const o of this._items) {
      const a = o._getParentKeyOrThrow(), c = va(
        o._toOps(this._id, a, s),
        void 0
      ), l = c[0].opId;
      l !== void 0 && this._unacknowledgedSets.set(a, l), i.push(...c);
    }
    return i;
  }
  /**
   * @internal
   *
   * Adds a new item into the sorted list, in the correct position.
   */
  _insertAndSort(t) {
    this._items.push(t), this._sortItems();
  }
  /** @internal */
  _sortItems() {
    this._items.sort(ob), this.invalidate();
  }
  /** @internal */
  _indexOfPosition(t) {
    return this._items.findIndex(
      (e) => e._getParentKeyOrThrow() === t
    );
  }
  /** @internal */
  _attach(t, e) {
    super._attach(t, e);
    for (const s of this._items)
      s._attach(e.generateId(), e);
  }
  /** @internal */
  _detach() {
    super._detach();
    for (const t of this._items)
      t._detach();
  }
  /** @internal */
  _applySetRemote(t) {
    if (this._pool === void 0)
      throw new Error("Can't attach child if managed pool is not present");
    const { id: e, parentKey: s } = t, i = Kr(t);
    i._attach(e, this._pool), i._setParentLink(this, s);
    const r = t.deletedId, o = this._indexOfPosition(s);
    if (o !== -1) {
      const a = this._items[o];
      if (a._id === r)
        return a._detach(), this._items[o] = i, {
          modified: Mt(this, [
            Di(o, i)
          ]),
          reverse: []
        };
      {
        this._implicitlyDeletedItems.add(a), this._items[o] = i;
        const c = [
          Di(o, i)
        ], l = this._detachItemAssociatedToSetOperation(
          t.deletedId
        );
        return l && c.push(l), {
          modified: Mt(this, c),
          reverse: []
        };
      }
    } else {
      const a = [], c = this._detachItemAssociatedToSetOperation(
        t.deletedId
      );
      return c && a.push(c), this._insertAndSort(i), a.push(gs(this._indexOfPosition(s), i)), {
        reverse: [],
        modified: Mt(this, a)
      };
    }
  }
  /** @internal */
  _applySetAck(t) {
    if (this._pool === void 0)
      throw new Error("Can't attach child if managed pool is not present");
    const e = [], s = this._detachItemAssociatedToSetOperation(t.deletedId);
    s && e.push(s);
    const i = this._unacknowledgedSets.get(t.parentKey);
    if (i !== void 0) {
      if (i !== t.opId)
        return e.length === 0 ? { modified: !1 } : { modified: Mt(this, e), reverse: [] };
      this._unacknowledgedSets.delete(t.parentKey);
    }
    const r = this._indexOfPosition(t.parentKey), o = this._items.find((a) => a._id === t.id);
    if (o !== void 0) {
      if (o._parentKey === t.parentKey)
        return {
          modified: e.length > 0 ? Mt(this, e) : !1,
          reverse: []
        };
      r !== -1 && (this._implicitlyDeletedItems.add(
        this._items[r]
      ), this._items.splice(r, 1), e.push(ya(r)));
      const a = this._items.indexOf(o);
      o._setParentLink(this, t.parentKey), this._sortItems();
      const c = this._items.indexOf(o);
      return c !== a && e.push(Nn(a, c, o)), {
        modified: e.length > 0 ? Mt(this, e) : !1,
        reverse: []
      };
    } else {
      const a = this._pool.getNode(t.id);
      if (a && this._implicitlyDeletedItems.has(a)) {
        a._setParentLink(this, t.parentKey), this._implicitlyDeletedItems.delete(a), this._insertAndSort(a);
        const c = this._items.indexOf(a);
        return {
          modified: Mt(this, [
            // If there is an item at this position, update is a set, else it's an insert
            r === -1 ? gs(c, a) : Di(c, a),
            ...e
          ]),
          reverse: []
        };
      } else {
        r !== -1 && this._items.splice(r, 1);
        const { newItem: c, newIndex: l } = this._createAttachItemAndSort(
          t,
          t.parentKey
        );
        return {
          modified: Mt(this, [
            // If there is an item at this position, update is a set, else it's an insert
            r === -1 ? gs(l, c) : Di(l, c),
            ...e
          ]),
          reverse: []
        };
      }
    }
  }
  /**
   * Returns the update delta of the deletion or null
   * @internal
   */
  _detachItemAssociatedToSetOperation(t) {
    if (t === void 0 || this._pool === void 0)
      return null;
    const e = this._pool.getNode(t);
    if (e === void 0)
      return null;
    const s = this._detachChild(e);
    return s.modified === !1 ? null : s.modified.updates[0];
  }
  /** @internal */
  _applyRemoteInsert(t) {
    if (this._pool === void 0)
      throw new Error("Can't attach child if managed pool is not present");
    const e = Mo(t.parentKey), s = this._indexOfPosition(e);
    s !== -1 && this._shiftItemPosition(s, e);
    const { newItem: i, newIndex: r } = this._createAttachItemAndSort(t, e);
    return {
      modified: Mt(this, [gs(r, i)]),
      reverse: []
    };
  }
  /** @internal */
  _applyInsertAck(t) {
    const e = this._items.find((r) => r._id === t.id), s = Mo(t.parentKey), i = this._indexOfPosition(s);
    if (e) {
      if (e._parentKey === s)
        return {
          modified: !1
        };
      {
        const r = this._items.indexOf(e);
        i !== -1 && this._shiftItemPosition(i, s), e._setParentLink(this, s), this._sortItems();
        const o = this._indexOfPosition(s);
        return o === r ? { modified: !1 } : {
          modified: Mt(this, [
            Nn(r, o, e)
          ]),
          reverse: []
        };
      }
    } else {
      const r = nt(this._pool).getNode(t.id);
      if (r && this._implicitlyDeletedItems.has(r)) {
        r._setParentLink(this, s), this._implicitlyDeletedItems.delete(r), this._insertAndSort(r);
        const o = this._indexOfPosition(s);
        return {
          modified: Mt(this, [gs(o, r)]),
          reverse: []
        };
      } else {
        i !== -1 && this._shiftItemPosition(i, s);
        const { newItem: o, newIndex: a } = this._createAttachItemAndSort(t, s);
        return {
          modified: Mt(this, [gs(a, o)]),
          reverse: []
        };
      }
    }
  }
  /** @internal */
  _applyInsertUndoRedo(t) {
    var c, l, h;
    const { id: e, parentKey: s } = t, i = Kr(t);
    if (((c = this._pool) == null ? void 0 : c.getNode(e)) !== void 0)
      return { modified: !1 };
    i._attach(e, nt(this._pool)), i._setParentLink(this, s);
    const r = this._indexOfPosition(s);
    let o = s;
    if (r !== -1) {
      const d = (l = this._items[r]) == null ? void 0 : l._parentPos, u = (h = this._items[r + 1]) == null ? void 0 : h._parentPos;
      o = Ds(d, u), i._setParentLink(this, o);
    }
    this._insertAndSort(i);
    const a = this._indexOfPosition(o);
    return {
      modified: Mt(this, [gs(a, i)]),
      reverse: [{ type: 5, id: e }]
    };
  }
  /** @internal */
  _applySetUndoRedo(t) {
    var a;
    const { id: e, parentKey: s } = t, i = Kr(t);
    if (((a = this._pool) == null ? void 0 : a.getNode(e)) !== void 0)
      return { modified: !1 };
    this._unacknowledgedSets.set(s, nt(t.opId));
    const r = this._indexOfPosition(s);
    i._attach(e, nt(this._pool)), i._setParentLink(this, s);
    const o = s;
    if (r !== -1) {
      const c = this._items[r];
      c._detach(), this._items[r] = i;
      const l = va(
        c._toOps(nt(this._id), s, this._pool),
        t.id
      ), h = [Di(r, i)], d = this._detachItemAssociatedToSetOperation(
        t.deletedId
      );
      return d && h.push(d), {
        modified: Mt(this, h),
        reverse: l
      };
    } else {
      this._insertAndSort(i), this._detachItemAssociatedToSetOperation(t.deletedId);
      const c = this._indexOfPosition(o);
      return {
        reverse: [{ type: 5, id: e }],
        modified: Mt(this, [gs(c, i)])
      };
    }
  }
  /** @internal */
  _attachChild(t, e) {
    if (this._pool === void 0)
      throw new Error("Can't attach child if managed pool is not present");
    let s;
    return t.intent === "set" ? e === 1 ? s = this._applySetRemote(t) : e === 2 ? s = this._applySetAck(t) : s = this._applySetUndoRedo(t) : e === 1 ? s = this._applyRemoteInsert(t) : e === 2 ? s = this._applyInsertAck(t) : s = this._applyInsertUndoRedo(t), s.modified !== !1 && this.invalidate(), s;
  }
  /** @internal */
  _detachChild(t) {
    if (t) {
      const e = nt(t._parentKey), s = t._toOps(nt(this._id), e, this._pool), i = this._items.indexOf(t);
      return i === -1 ? {
        modified: !1
      } : (this._items.splice(i, 1), this.invalidate(), t._detach(), {
        modified: Mt(this, [ya(i)]),
        reverse: s
      });
    }
    return { modified: !1 };
  }
  /** @internal */
  _applySetChildKeyRemote(t, e) {
    var r;
    if (this._implicitlyDeletedItems.has(e)) {
      this._implicitlyDeletedItems.delete(e), e._setParentLink(this, t), this._insertAndSort(e);
      const o = this._items.indexOf(e);
      return {
        modified: Mt(this, [gs(o, e)]),
        reverse: []
      };
    }
    const s = e._parentKey;
    if (t === s)
      return {
        modified: !1
      };
    const i = this._indexOfPosition(t);
    if (i === -1) {
      const o = this._items.indexOf(e);
      e._setParentLink(this, t), this._sortItems();
      const a = this._items.indexOf(e);
      return a === o ? {
        modified: !1
      } : {
        modified: Mt(this, [Nn(o, a, e)]),
        reverse: []
      };
    } else {
      this._items[i]._setParentLink(
        this,
        Ds(t, (r = this._items[i + 1]) == null ? void 0 : r._parentPos)
      );
      const o = this._items.indexOf(e);
      e._setParentLink(this, t), this._sortItems();
      const a = this._items.indexOf(e);
      return a === o ? {
        modified: !1
      } : {
        modified: Mt(this, [Nn(o, a, e)]),
        reverse: []
      };
    }
  }
  /** @internal */
  _applySetChildKeyAck(t, e) {
    var i, r;
    const s = nt(e._parentKey);
    if (this._implicitlyDeletedItems.has(e)) {
      const o = this._indexOfPosition(t);
      return this._implicitlyDeletedItems.delete(e), o !== -1 && this._items[o]._setParentLink(
        this,
        Ds(t, (i = this._items[o + 1]) == null ? void 0 : i._parentPos)
      ), e._setParentLink(this, t), this._insertAndSort(e), {
        modified: !1
      };
    } else {
      if (t === s)
        return {
          modified: !1
        };
      const o = this._items.indexOf(e), a = this._indexOfPosition(t);
      a !== -1 && this._items[a]._setParentLink(
        this,
        Ds(t, (r = this._items[a + 1]) == null ? void 0 : r._parentPos)
      ), e._setParentLink(this, t), this._sortItems();
      const c = this._items.indexOf(e);
      return o === c ? {
        modified: !1
      } : {
        modified: Mt(this, [
          Nn(o, c, e)
        ]),
        reverse: []
      };
    }
  }
  /** @internal */
  _applySetChildKeyUndoRedo(t, e) {
    var a;
    const s = nt(e._parentKey), i = this._items.indexOf(e), r = this._indexOfPosition(t);
    r !== -1 && this._items[r]._setParentLink(
      this,
      Ds(t, (a = this._items[r + 1]) == null ? void 0 : a._parentPos)
    ), e._setParentLink(this, t), this._sortItems();
    const o = this._items.indexOf(e);
    return i === o ? {
      modified: !1
    } : {
      modified: Mt(this, [Nn(i, o, e)]),
      reverse: [
        {
          type: 1,
          id: nt(e._id),
          parentKey: s
        }
      ]
    };
  }
  /** @internal */
  _setChildKey(t, e, s) {
    return s === 1 ? this._applySetChildKeyRemote(t, e) : s === 2 ? this._applySetChildKeyAck(t, e) : this._applySetChildKeyUndoRedo(t, e);
  }
  /** @internal */
  _apply(t, e) {
    return super._apply(t, e);
  }
  /** @internal */
  _serialize() {
    if (this.parent.type !== "HasParent")
      throw new Error("Cannot serialize LiveList if parent is missing");
    return {
      type: 1,
      parentId: nt(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns the number of elements.
   */
  get length() {
    return this._items.length;
  }
  /**
   * Adds one element to the end of the LiveList.
   * @param element The element to add to the end of the LiveList.
   */
  push(t) {
    var e;
    return (e = this._pool) == null || e.assertStorageIsWritable(), this.insert(t, this.length);
  }
  /**
   * Inserts one element at a specified index.
   * @param element The element to insert.
   * @param index The index at which you want to insert the element.
   */
  insert(t, e) {
    var a;
    if ((a = this._pool) == null || a.assertStorageIsWritable(), e < 0 || e > this._items.length)
      throw new Error(
        `Cannot insert list item at index "${e}". index should be between 0 and ${this._items.length}`
      );
    const s = this._items[e - 1] ? this._items[e - 1]._parentPos : void 0, i = this._items[e] ? this._items[e]._parentPos : void 0, r = Ds(s, i), o = Xi(t);
    if (o._setParentLink(this, r), this._insertAndSort(o), this._pool && this._id) {
      const c = this._pool.generateId();
      o._attach(c, this._pool), this._pool.dispatch(
        o._toOps(this._id, r, this._pool),
        [{ type: 5, id: c }],
        /* @__PURE__ */ new Map([
          [this._id, Mt(this, [gs(e, o)])]
        ])
      );
    }
  }
  /**
   * Move one element from one index to another.
   * @param index The index of the element to move
   * @param targetIndex The index where the element should be after moving.
   */
  move(t, e) {
    var c;
    if ((c = this._pool) == null || c.assertStorageIsWritable(), e < 0)
      throw new Error("targetIndex cannot be less than 0");
    if (e >= this._items.length)
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    if (t < 0)
      throw new Error("index cannot be less than 0");
    if (t >= this._items.length)
      throw new Error("index cannot be greater or equal than the list length");
    let s = null, i = null;
    t < e ? (i = e === this._items.length - 1 ? void 0 : this._items[e + 1]._parentPos, s = this._items[e]._parentPos) : (i = this._items[e]._parentPos, s = e === 0 ? void 0 : this._items[e - 1]._parentPos);
    const r = Ds(s, i), o = this._items[t], a = o._getParentKeyOrThrow();
    if (o._setParentLink(this, r), this._sortItems(), this._pool && this._id) {
      const l = /* @__PURE__ */ new Map([
        [this._id, Mt(this, [Nn(t, e, o)])]
      ]);
      this._pool.dispatch(
        [
          {
            type: 1,
            id: nt(o._id),
            opId: this._pool.generateOpId(),
            parentKey: r
          }
        ],
        [
          {
            type: 1,
            id: nt(o._id),
            parentKey: a
          }
        ],
        l
      );
    }
  }
  /**
   * Deletes an element at the specified index
   * @param index The index of the element to delete
   */
  delete(t) {
    var s;
    if ((s = this._pool) == null || s.assertStorageIsWritable(), t < 0 || t >= this._items.length)
      throw new Error(
        `Cannot delete list item at index "${t}". index should be between 0 and ${this._items.length - 1}`
      );
    const e = this._items[t];
    if (e._detach(), this._items.splice(t, 1), this.invalidate(), this._pool) {
      const i = e._id;
      if (i) {
        const r = /* @__PURE__ */ new Map();
        r.set(
          nt(this._id),
          Mt(this, [ya(t)])
        ), this._pool.dispatch(
          [
            {
              id: i,
              opId: this._pool.generateOpId(),
              type: 5
              /* DELETE_CRDT */
            }
          ],
          e._toOps(nt(this._id), e._getParentKeyOrThrow()),
          r
        );
      }
    }
  }
  clear() {
    var t;
    if ((t = this._pool) == null || t.assertStorageIsWritable(), this._pool) {
      const e = [], s = [], i = [];
      for (const o of this._items) {
        o._detach();
        const a = o._id;
        a && (e.push({
          type: 5,
          id: a,
          opId: this._pool.generateOpId()
        }), s.push(
          ...o._toOps(nt(this._id), o._getParentKeyOrThrow())
        ), i.push(ya(0)));
      }
      this._items = [], this.invalidate();
      const r = /* @__PURE__ */ new Map();
      r.set(nt(this._id), Mt(this, i)), this._pool.dispatch(e, s, r);
    } else {
      for (const e of this._items)
        e._detach();
      this._items = [], this.invalidate();
    }
  }
  set(t, e) {
    var a;
    if ((a = this._pool) == null || a.assertStorageIsWritable(), t < 0 || t >= this._items.length)
      throw new Error(
        `Cannot set list item at index "${t}". index should be between 0 and ${this._items.length - 1}`
      );
    const s = this._items[t], i = s._getParentKeyOrThrow(), r = s._id;
    s._detach();
    const o = Xi(e);
    if (o._setParentLink(this, i), this._items[t] = o, this.invalidate(), this._pool && this._id) {
      const c = this._pool.generateId();
      o._attach(c, this._pool);
      const l = /* @__PURE__ */ new Map();
      l.set(this._id, Mt(this, [Di(t, o)]));
      const h = va(
        o._toOps(this._id, i, this._pool),
        r
      );
      this._unacknowledgedSets.set(i, nt(h[0].opId));
      const d = va(
        s._toOps(this._id, i, void 0),
        c
      );
      this._pool.dispatch(h, d, l);
    }
  }
  /**
   * Returns an Array of all the elements in the LiveList.
   */
  toArray() {
    return this._items.map(
      (t) => Xn(t)
      //                               ^^^^^^^^
      //                               FIXME! This isn't safe.
    );
  }
  /**
   * Tests whether all elements pass the test implemented by the provided function.
   * @param predicate Function to test for each element, taking two arguments (the element and its index).
   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.
   */
  every(t) {
    return this.toArray().every(t);
  }
  /**
   * Creates an array with all elements that pass the test implemented by the provided function.
   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.
   * @returns An array with the elements that pass the test.
   */
  filter(t) {
    return this.toArray().filter(t);
  }
  /**
   * Returns the first element that satisfies the provided testing function.
   * @param predicate Function to execute on each value.
   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.
   */
  find(t) {
    return this.toArray().find(t);
  }
  /**
   * Returns the index of the first element in the LiveList that satisfies the provided testing function.
   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.
   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.
   */
  findIndex(t) {
    return this.toArray().findIndex(t);
  }
  /**
   * Executes a provided function once for each element.
   * @param callbackfn Function to execute on each element.
   */
  forEach(t) {
    return this.toArray().forEach(t);
  }
  /**
   * Get the element at the specified index.
   * @param index The index on the element to get.
   * @returns The element at the specified index or undefined.
   */
  get(t) {
    if (!(t < 0 || t >= this._items.length))
      return Xn(this._items[t]);
  }
  /**
   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.
   * @param searchElement Element to locate.
   * @param fromIndex The index to start the search at.
   * @returns The first index of the element in the LiveList; -1 if not found.
   */
  indexOf(t, e) {
    return this.toArray().indexOf(t, e);
  }
  /**
   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.
   * @param searchElement Element to locate.
   * @param fromIndex The index at which to start searching backwards.
   * @returns
   */
  lastIndexOf(t, e) {
    return this.toArray().lastIndexOf(t, e);
  }
  /**
   * Creates an array populated with the results of calling a provided function on every element.
   * @param callback Function that is called for every element.
   * @returns An array with each element being the result of the callback function.
   */
  map(t) {
    return this._items.map(
      (e, s) => t(
        Xn(e),
        //                    ^^^^^^^^
        //                    FIXME! This isn't safe.
        s
      )
    );
  }
  /**
   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.
   * @param predicate Function to test for each element.
   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.
   */
  some(t) {
    return this.toArray().some(t);
  }
  [Symbol.iterator]() {
    return new ab(this._items);
  }
  /** @internal */
  _createAttachItemAndSort(t, e) {
    const s = Kr(t);
    s._attach(t.id, nt(this._pool)), s._setParentLink(this, e), this._insertAndSort(s);
    const i = this._indexOfPosition(e);
    return { newItem: s, newIndex: i };
  }
  /** @internal */
  _shiftItemPosition(t, e) {
    var i;
    const s = Ds(
      e,
      this._items.length > t + 1 ? (i = this._items[t + 1]) == null ? void 0 : i._parentPos : void 0
    );
    this._items[t]._setParentLink(this, s);
  }
  /** @internal */
  _toTreeNode(t) {
    return {
      type: "LiveList",
      id: this._id ?? tl(),
      key: t,
      payload: this._items.map(
        (e, s) => e.toTreeNode(s.toString())
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const t = this._items.map((e) => e.toImmutable());
    return process.env.NODE_ENV === "production" ? t : Object.freeze(t);
  }
  clone() {
    return new Od(this._items.map((t) => t.clone()));
  }
}, ab = class {
  constructor(n) {
    this._innerIterator = n[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const n = this._innerIterator.next();
    return n.done ? {
      done: !0,
      value: void 0
    } : { value: Xn(n.value) };
  }
};
function Mt(n, t) {
  return {
    node: n,
    type: "LiveList",
    updates: t
  };
}
function Di(n, t) {
  return {
    index: n,
    type: "set",
    item: t instanceof yi ? t.data : t
  };
}
function ya(n) {
  return {
    index: n,
    type: "delete"
  };
}
function gs(n, t) {
  return {
    index: n,
    type: "insert",
    item: t instanceof yi ? t.data : t
  };
}
function Nn(n, t, e) {
  return {
    index: t,
    type: "move",
    previousIndex: n,
    item: e instanceof yi ? e.data : e
  };
}
function va(n, t) {
  return n.map((e, s) => s === 0 ? {
    ...e,
    intent: "set",
    deletedId: t
  } : e);
}
var Bs = process.env.NODE_ENV === "production" ? (
  /* istanbul ignore next */
  (n) => n
) : Object.freeze, wr = class Dd extends Qc {
  constructor(t) {
    if (super(), this.unacknowledgedSet = /* @__PURE__ */ new Map(), t) {
      const e = [];
      for (const [s, i] of t) {
        const r = Xi(i);
        r._setParentLink(this, s), e.push([s, r]);
      }
      this._map = new Map(e);
    } else
      this._map = /* @__PURE__ */ new Map();
  }
  /**
   * @internal
   */
  _toOps(t, e, s) {
    if (this._id === void 0)
      throw new Error("Cannot serialize item is not attached");
    const i = [], r = {
      id: this._id,
      opId: s == null ? void 0 : s.generateOpId(),
      type: 7,
      parentId: t,
      parentKey: e
    };
    i.push(r);
    for (const [o, a] of this._map)
      i.push(...a._toOps(this._id, o, s));
    return i;
  }
  /**
   * @internal
   */
  static _deserialize([t, e], s, i) {
    const r = new Dd();
    r._attach(t, i);
    const o = s.get(t);
    if (o === void 0)
      return r;
    for (const [a, c] of o) {
      const l = pm([a, c], s, i);
      l._setParentLink(r, c.parentKey), r._map.set(c.parentKey, l), r.invalidate();
    }
    return r;
  }
  /**
   * @internal
   */
  _attach(t, e) {
    super._attach(t, e);
    for (const [s, i] of this._map)
      ae(i) && i._attach(e.generateId(), e);
  }
  /**
   * @internal
   */
  _attachChild(t, e) {
    if (this._pool === void 0)
      throw new Error("Can't attach child if managed pool is not present");
    const { id: s, parentKey: i, opId: r } = t, o = i, a = Kr(t);
    if (this._pool.getNode(s) !== void 0)
      return { modified: !1 };
    if (e === 2) {
      const h = this.unacknowledgedSet.get(o);
      if (h === r)
        return this.unacknowledgedSet.delete(o), { modified: !1 };
      if (h !== void 0)
        return { modified: !1 };
    } else
      e === 1 && this.unacknowledgedSet.delete(o);
    const c = this._map.get(o);
    let l;
    if (c) {
      const h = nt(this._id);
      l = c._toOps(h, o), c._detach();
    } else
      l = [{ type: 5, id: s }];
    return a._setParentLink(this, o), a._attach(s, this._pool), this._map.set(o, a), this.invalidate(), {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [o]: { type: "update" } }
      },
      reverse: l
    };
  }
  /**
   * @internal
   */
  _detach() {
    super._detach();
    for (const t of this._map.values())
      t._detach();
  }
  /**
   * @internal
   */
  _detachChild(t) {
    const e = nt(this._id), s = nt(t._parentKey), i = t._toOps(e, s, this._pool);
    for (const [o, a] of this._map)
      a === t && (this._map.delete(o), this.invalidate());
    return t._detach(), { modified: {
      node: this,
      type: "LiveMap",
      updates: { [s]: { type: "delete" } }
    }, reverse: i };
  }
  /**
   * @internal
   */
  _serialize() {
    if (this.parent.type !== "HasParent")
      throw new Error("Cannot serialize LiveMap if parent is missing");
    return {
      type: 2,
      parentId: nt(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  /**
   * Returns a specified element from the LiveMap.
   * @param key The key of the element to return.
   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.
   */
  get(t) {
    const e = this._map.get(t);
    if (e !== void 0)
      return Xn(e);
  }
  /**
   * Adds or updates an element with a specified key and a value.
   * @param key The key of the element to add. Should be a string.
   * @param value The value of the element to add. Should be serializable to JSON.
   */
  set(t, e) {
    var r;
    (r = this._pool) == null || r.assertStorageIsWritable();
    const s = this._map.get(t);
    s && s._detach();
    const i = Xi(e);
    if (i._setParentLink(this, t), this._map.set(t, i), this.invalidate(), this._pool && this._id) {
      const o = this._pool.generateId();
      i._attach(o, this._pool);
      const a = /* @__PURE__ */ new Map();
      a.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [t]: { type: "update" } }
      });
      const c = i._toOps(this._id, t, this._pool);
      this.unacknowledgedSet.set(t, nt(c[0].opId)), this._pool.dispatch(
        i._toOps(this._id, t, this._pool),
        s ? s._toOps(this._id, t) : [{ type: 5, id: o }],
        a
      );
    }
  }
  /**
   * Returns the number of elements in the LiveMap.
   */
  get size() {
    return this._map.size;
  }
  /**
   * Returns a boolean indicating whether an element with the specified key exists or not.
   * @param key The key of the element to test for presence.
   */
  has(t) {
    return this._map.has(t);
  }
  /**
   * Removes the specified element by key.
   * @param key The key of the element to remove.
   * @returns true if an element existed and has been removed, or false if the element does not exist.
   */
  delete(t) {
    var s;
    (s = this._pool) == null || s.assertStorageIsWritable();
    const e = this._map.get(t);
    if (e === void 0)
      return !1;
    if (e._detach(), this._map.delete(t), this.invalidate(), this._pool && e._id) {
      const i = nt(this._id), r = /* @__PURE__ */ new Map();
      r.set(i, {
        node: this,
        type: "LiveMap",
        updates: { [t]: { type: "delete" } }
      }), this._pool.dispatch(
        [
          {
            type: 5,
            id: e._id,
            opId: this._pool.generateOpId()
          }
        ],
        e._toOps(i, t),
        r
      );
    }
    return !0;
  }
  /**
   * Returns a new Iterator object that contains the [key, value] pairs for each element.
   */
  entries() {
    const t = this._map.entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const e = t.next();
        if (e.done)
          return {
            done: !0,
            value: void 0
          };
        const i = e.value[0], r = Xn(e.value[1]);
        return {
          value: [i, r]
        };
      }
    };
  }
  /**
   * Same function object as the initial value of the entries method.
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Returns a new Iterator object that contains the keys for each element.
   */
  keys() {
    return this._map.keys();
  }
  /**
   * Returns a new Iterator object that contains the values for each element.
   */
  values() {
    const t = this._map.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const e = t.next();
        return e.done ? {
          done: !0,
          value: void 0
        } : { value: Xn(e.value) };
      }
    };
  }
  /**
   * Executes a provided function once per each key/value pair in the Map object, in insertion order.
   * @param callback Function to execute for each entry in the map.
   */
  forEach(t) {
    for (const e of this)
      t(e[1], e[0], this);
  }
  /** @internal */
  _toTreeNode(t) {
    return {
      type: "LiveMap",
      id: this._id ?? tl(),
      key: t,
      payload: Array.from(this._map.entries()).map(
        ([e, s]) => s.toTreeNode(e)
      )
    };
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  _toImmutable() {
    const t = /* @__PURE__ */ new Map();
    for (const [e, s] of this._map)
      t.set(e, s.toImmutable());
    return Bs(t);
  }
  clone() {
    return new Dd(
      Array.from(this._map).map(([t, e]) => [t, e.clone()])
    );
  }
}, vi = class Wr extends Qc {
  constructor(t = {}) {
    super(), this._propToLastUpdate = /* @__PURE__ */ new Map();
    const e = Xc(t);
    for (const s of Object.keys(e)) {
      const i = e[s];
      ae(i) && i._setParentLink(this, s);
    }
    this._map = new Map(Object.entries(e));
  }
  /** @internal */
  static _buildRootAndParentToChildren(t) {
    const e = /* @__PURE__ */ new Map();
    let s = null;
    for (const [i, r] of t)
      if (ib(r))
        s = [i, r];
      else {
        const o = [i, r], a = e.get(r.parentId);
        a !== void 0 ? a.push(o) : e.set(r.parentId, [o]);
      }
    if (s === null)
      throw new Error("Root can't be null");
    return [s, e];
  }
  /** @internal */
  static _fromItems(t, e) {
    const [s, i] = Wr._buildRootAndParentToChildren(t);
    return Wr._deserialize(
      s,
      i,
      e
    );
  }
  /** @internal */
  _toOps(t, e, s) {
    if (this._id === void 0)
      throw new Error("Cannot serialize item is not attached");
    const i = s == null ? void 0 : s.generateOpId(), r = [], o = {
      type: 4,
      id: this._id,
      opId: i,
      parentId: t,
      parentKey: e,
      data: {}
    };
    r.push(o);
    for (const [a, c] of this._map)
      ae(c) ? r.push(...c._toOps(this._id, a, s)) : o.data[a] = c;
    return r;
  }
  /** @internal */
  static _deserialize([t, e], s, i) {
    const r = new Wr(e.data);
    return r._attach(t, i), this._deserializeChildren(r, s, i);
  }
  /** @internal */
  static _deserializeChildren(t, e, s) {
    const i = e.get(nt(t._id));
    if (i === void 0)
      return t;
    for (const [r, o] of i) {
      const a = cb([r, o], e, s);
      ji(a) && a._setParentLink(t, o.parentKey), t._map.set(o.parentKey, a), t.invalidate();
    }
    return t;
  }
  /** @internal */
  _attach(t, e) {
    super._attach(t, e);
    for (const [s, i] of this._map)
      ae(i) && i._attach(e.generateId(), e);
  }
  /** @internal */
  _attachChild(t, e) {
    if (this._pool === void 0)
      throw new Error("Can't attach child if managed pool is not present");
    const { id: s, opId: i, parentKey: r } = t, o = um(t);
    if (this._pool.getNode(s) !== void 0)
      return this._propToLastUpdate.get(r) === i && this._propToLastUpdate.delete(r), { modified: !1 };
    if (e === 0)
      this._propToLastUpdate.set(r, nt(i));
    else if (this._propToLastUpdate.get(r) !== void 0)
      return this._propToLastUpdate.get(r) === i ? (this._propToLastUpdate.delete(r), { modified: !1 }) : { modified: !1 };
    const a = nt(this._id), c = this._map.get(r);
    let l;
    return ae(c) ? (l = c._toOps(a, r), c._detach()) : c === void 0 ? l = [{ type: 6, id: a, key: r }] : l = [
      {
        type: 3,
        id: a,
        data: { [r]: c }
      }
    ], this._map.set(r, o), this.invalidate(), ji(o) && (o._setParentLink(this, r), o._attach(s, this._pool)), {
      reverse: l,
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [r]: { type: "update" } }
      }
    };
  }
  /** @internal */
  _detachChild(t) {
    if (t) {
      const e = nt(this._id), s = nt(t._parentKey), i = t._toOps(e, s, this._pool);
      for (const [o, a] of this._map)
        a === t && (this._map.delete(o), this.invalidate());
      return t._detach(), { modified: {
        node: this,
        type: "LiveObject",
        updates: {
          [s]: { type: "delete" }
        }
      }, reverse: i };
    }
    return { modified: !1 };
  }
  /**
   * @internal
   */
  _detach() {
    super._detach();
    for (const t of this._map.values())
      ae(t) && t._detach();
  }
  /** @internal */
  _apply(t, e) {
    return t.type === 3 ? this._applyUpdate(t, e) : t.type === 6 ? this._applyDeleteObjectKey(t, e) : super._apply(t, e);
  }
  /**
   * @internal
   */
  _serialize() {
    const t = {};
    for (const [e, s] of this._map)
      ae(s) || (t[e] = s);
    return this.parent.type === "HasParent" && this.parent.node._id ? {
      type: 0,
      parentId: this.parent.node._id,
      parentKey: this.parent.key,
      data: t
    } : {
      type: 0,
      data: t
    };
  }
  /** @internal */
  _applyUpdate(t, e) {
    let s = !1;
    const i = nt(this._id), r = [], o = {
      type: 3,
      id: i,
      data: {}
    };
    for (const c in t.data) {
      const l = this._map.get(c);
      ae(l) ? (r.push(...l._toOps(i, c)), l._detach()) : l !== void 0 ? o.data[c] = l : l === void 0 && r.push({ type: 6, id: i, key: c });
    }
    const a = {};
    for (const c in t.data) {
      const l = t.data[c];
      if (l === void 0)
        continue;
      if (e)
        this._propToLastUpdate.set(c, nt(t.opId));
      else if (this._propToLastUpdate.get(c) === void 0)
        s = !0;
      else if (this._propToLastUpdate.get(c) === t.opId) {
        this._propToLastUpdate.delete(c);
        continue;
      } else
        continue;
      const h = this._map.get(c);
      ae(h) && h._detach(), s = !0, a[c] = { type: "update" }, this._map.set(c, l), this.invalidate();
    }
    return Object.keys(o.data).length !== 0 && r.unshift(o), s ? {
      modified: {
        node: this,
        type: "LiveObject",
        updates: a
      },
      reverse: r
    } : { modified: !1 };
  }
  /** @internal */
  _applyDeleteObjectKey(t, e) {
    const s = t.key;
    if (this._map.has(s) === !1)
      return { modified: !1 };
    if (!e && this._propToLastUpdate.get(s) !== void 0)
      return { modified: !1 };
    const i = this._map.get(s), r = nt(this._id);
    let o = [];
    return ae(i) ? (o = i._toOps(r, t.key), i._detach()) : i !== void 0 && (o = [
      {
        type: 3,
        id: r,
        data: { [s]: i }
      }
    ]), this._map.delete(s), this.invalidate(), {
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [t.key]: { type: "delete" } }
      },
      reverse: o
    };
  }
  /**
   * Transform the LiveObject into a javascript object
   */
  toObject() {
    return Object.fromEntries(this._map);
  }
  /**
   * Adds or updates a property with a specified key and a value.
   * @param key The key of the property to add
   * @param value The value of the property to add
   */
  set(t, e) {
    var s;
    (s = this._pool) == null || s.assertStorageIsWritable(), this.update({ [t]: e });
  }
  /**
   * Returns a specified property from the LiveObject.
   * @param key The key of the property to get
   */
  get(t) {
    return this._map.get(t);
  }
  /**
   * Deletes a key from the LiveObject
   * @param key The key of the property to delete
   */
  delete(t) {
    var o;
    (o = this._pool) == null || o.assertStorageIsWritable();
    const e = t, s = this._map.get(e);
    if (s === void 0)
      return;
    if (this._pool === void 0 || this._id === void 0) {
      ae(s) && s._detach(), this._map.delete(e), this.invalidate();
      return;
    }
    let i;
    ae(s) ? (s._detach(), i = s._toOps(this._id, e)) : i = [
      {
        type: 3,
        data: { [e]: s },
        id: this._id
      }
    ], this._map.delete(e), this.invalidate();
    const r = /* @__PURE__ */ new Map();
    r.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [t]: { type: "delete" } }
    }), this._pool.dispatch(
      [
        {
          type: 6,
          key: e,
          id: this._id,
          opId: this._pool.generateOpId()
        }
      ],
      i,
      r
    );
  }
  /**
   * Adds or updates multiple properties at once with an object.
   * @param patch The object used to overrides properties
   */
  update(t) {
    var l;
    if ((l = this._pool) == null || l.assertStorageIsWritable(), this._pool === void 0 || this._id === void 0) {
      for (const h in t) {
        const d = t[h];
        if (d === void 0)
          continue;
        const u = this._map.get(h);
        ae(u) && u._detach(), ae(d) && d._setParentLink(this, h), this._map.set(h, d), this.invalidate();
      }
      return;
    }
    const e = [], s = [], i = this._pool.generateOpId(), r = {}, o = {
      id: this._id,
      type: 3,
      data: {}
    }, a = {};
    for (const h in t) {
      const d = t[h];
      if (d === void 0)
        continue;
      const u = this._map.get(h);
      if (ae(u) ? (s.push(...u._toOps(this._id, h)), u._detach()) : u === void 0 ? s.push({ type: 6, id: this._id, key: h }) : o.data[h] = u, ae(d)) {
        d._setParentLink(this, h), d._attach(this._pool.generateId(), this._pool);
        const f = d._toOps(this._id, h, this._pool), p = f.find(
          (m) => m.parentId === this._id
        );
        p && this._propToLastUpdate.set(h, nt(p.opId)), e.push(...f);
      } else
        r[h] = d, this._propToLastUpdate.set(h, i);
      this._map.set(h, d), this.invalidate(), a[h] = { type: "update" };
    }
    Object.keys(o.data).length !== 0 && s.unshift(o), Object.keys(r).length !== 0 && e.unshift({
      opId: i,
      id: this._id,
      type: 3,
      data: r
    });
    const c = /* @__PURE__ */ new Map();
    c.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: a
    }), this._pool.dispatch(e, s, c);
  }
  toImmutable() {
    return super.toImmutable();
  }
  /** @internal */
  toTreeNode(t) {
    return super.toTreeNode(t);
  }
  /** @internal */
  _toTreeNode(t) {
    const e = this._id ?? tl();
    return {
      type: "LiveObject",
      id: e,
      key: t,
      payload: Array.from(this._map.entries()).map(
        ([s, i]) => ae(i) ? i.toTreeNode(s) : { type: "Json", id: `${e}:${s}`, key: s, payload: i }
      )
    };
  }
  /** @internal */
  _toImmutable() {
    const t = {};
    for (const [e, s] of this._map)
      t[e] = ji(s) ? s.toImmutable() : s;
    return process.env.NODE_ENV === "production" ? t : Object.freeze(t);
  }
  clone() {
    return new Wr(
      Object.fromEntries(
        Array.from(this._map).map(([t, e]) => [
          t,
          ji(e) ? e.clone() : Po(e)
        ])
      )
    );
  }
};
function Kr(n) {
  return Xi(um(n));
}
function um(n) {
  switch (n.type) {
    case 8:
      return n.data;
    case 4:
      return new vi(n.data);
    case 7:
      return new wr();
    case 2:
      return new br();
    default:
      return ys(n, "Unknown creation Op");
  }
}
function fm(n, t) {
  return n === t ? !0 : n.parent.type === "HasParent" ? fm(n.parent.node, t) : !1;
}
function pm([n, t], e, s) {
  switch (t.type) {
    case 0:
      return vi._deserialize([n, t], e, s);
    case 1:
      return br._deserialize([n, t], e, s);
    case 2:
      return wr._deserialize([n, t], e, s);
    case 3:
      return yi._deserialize([n, t], e, s);
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function cb([n, t], e, s) {
  switch (t.type) {
    case 0:
      return vi._deserialize([n, t], e, s);
    case 1:
      return br._deserialize([n, t], e, s);
    case 2:
      return wr._deserialize([n, t], e, s);
    case 3:
      return t.data;
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function ji(n) {
  return gm(n) || lb(n) || hb(n);
}
function ae(n) {
  return ji(n) || db(n);
}
function gm(n) {
  return n instanceof br;
}
function lb(n) {
  return n instanceof wr;
}
function hb(n) {
  return n instanceof vi;
}
function db(n) {
  return n instanceof yi;
}
function ub(n) {
  return n === void 0 ? void 0 : ji(n) ? n.clone() : Po(n);
}
function Xn(n) {
  return n instanceof yi ? n.data : n instanceof br || n instanceof wr || n instanceof vi ? n : ys(n, "Unknown AbstractCrdt");
}
function Xi(n) {
  return n instanceof vi || n instanceof wr || n instanceof br ? n : new yi(n);
}
function fb(n, t) {
  const e = [];
  return n.forEach((s, i) => {
    t.get(i) || e.push({
      type: 5,
      id: i
    });
  }), t.forEach((s, i) => {
    const r = n.get(i);
    if (r)
      s.type === 0 && (r.type !== 0 || JSON.stringify(s.data) !== JSON.stringify(r.data)) && e.push({
        type: 3,
        id: i,
        data: s.data
      }), s.parentKey !== r.parentKey && e.push({
        type: 1,
        id: i,
        parentKey: nt(s.parentKey, "Parent key must not be missing")
      });
    else
      switch (s.type) {
        case 3:
          e.push({
            type: 8,
            id: i,
            parentId: s.parentId,
            parentKey: s.parentKey,
            data: s.data
          });
          break;
        case 1:
          e.push({
            type: 2,
            id: i,
            parentId: s.parentId,
            parentKey: s.parentKey
          });
          break;
        case 0:
          if (s.parentId === void 0 || s.parentKey === void 0)
            throw new Error(
              "Internal error. Cannot serialize storage root into an operation"
            );
          e.push({
            type: 4,
            id: i,
            parentId: s.parentId,
            parentKey: s.parentKey,
            data: s.data
          });
          break;
        case 2:
          e.push({
            type: 7,
            id: i,
            parentId: s.parentId,
            parentKey: s.parentKey
          });
          break;
      }
  }), e;
}
function pb(n, t) {
  const e = n.updates;
  for (const [s, i] of Z2(t.updates))
    e[s] = i;
  return {
    ...t,
    updates: e
  };
}
function gb(n, t) {
  const e = n.updates;
  for (const [s, i] of Z2(t.updates))
    e[s] = i;
  return {
    ...t,
    updates: e
  };
}
function mb(n, t) {
  const e = n.updates;
  return {
    ...t,
    updates: e.concat(t.updates)
  };
}
function Sh(n, t) {
  return n === void 0 ? t : n.type === "LiveObject" && t.type === "LiveObject" ? pb(n, t) : n.type === "LiveMap" && t.type === "LiveMap" ? gb(n, t) : n.type === "LiveList" && t.type === "LiveList" ? mb(n, t) : t;
}
function _b(n, t) {
  const e = { name: n };
  if (typeof Error.captureStackTrace == "function")
    return Error.captureStackTrace(e, t), e.stack;
}
function yb(n) {
  return n === null || typeof n == "string" || typeof n == "number" || typeof n == "boolean";
}
function mm(n) {
  return Array.isArray(n);
}
function vb(n) {
  return !yb(n) && !mm(n);
}
var bb = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
function wb(n) {
  let t = [];
  const e = Object.entries(n), s = [], i = [], r = [];
  return e.forEach(([o, a]) => {
    if (!bb.test(o))
      throw new Error("Key must only contain letters, numbers, _");
    d0(a) ? s.push([o, a]) : u0(a) ? i.push([o, a]) : typeof a == "object" && !("startsWith" in a) && r.push([o, a]);
  }), t = [
    ...l0(s),
    ...h0(i)
  ], r.forEach(([o, a]) => {
    const c = Object.entries(a), l = [], h = [];
    c.forEach(([d, u]) => {
      if (_m(d))
        throw new Error("Key cannot be empty");
      d0(u) ? l.push([f0(o, d), u]) : u0(u) && h.push([
        f0(o, d),
        u
      ]);
    }), t = [
      ...t,
      ...l0(l),
      ...h0(h)
    ];
  }), t.map(
    ({ key: o, operator: a, value: c }) => Sb(o, a, Cb(c))
  ).join(" AND ");
}
var l0 = (n) => {
  const t = [];
  return n.forEach(([e, s]) => {
    t.push({
      key: e,
      operator: ":",
      value: s
    });
  }), t;
}, h0 = (n) => {
  const t = [];
  return n.forEach(([e, s]) => {
    "startsWith" in s && typeof s.startsWith == "string" && t.push({
      key: e,
      operator: "^",
      value: s.startsWith
    });
  }), t;
}, d0 = (n) => typeof n == "string" || typeof n == "number" || typeof n == "boolean", u0 = (n) => typeof n == "object" && n !== null && "startsWith" in n, Sb = (n, t, e) => `${n}${t}${e}`, f0 = (n, t) => t ? `${n}[${JSON.stringify(t)}]` : n, Cb = (n) => {
  if (typeof n == "string") {
    if (_m(n))
      throw new Error("Value cannot be empty");
    return JSON.stringify(n);
  }
  return n.toString();
}, _m = (n) => !n || n.toString().trim() === "", ym = /* @__PURE__ */ ((n) => (n[n.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", n[n.BROADCAST_EVENT = 103] = "BROADCAST_EVENT", n[n.FETCH_STORAGE = 200] = "FETCH_STORAGE", n[n.UPDATE_STORAGE = 201] = "UPDATE_STORAGE", n[n.FETCH_YDOC = 300] = "FETCH_YDOC", n[n.UPDATE_YDOC = 301] = "UPDATE_YDOC", n))(ym || {});
function vm(n, t) {
  let e = !1;
  const s = { ...n };
  return Object.keys(t).forEach((i) => {
    const r = i, o = t[r];
    s[r] !== o && (o === void 0 ? delete s[r] : s[r] = o, e = !0);
  }), e ? s : n;
}
var el = class {
  constructor() {
    this._ev = It();
  }
  get didInvalidate() {
    return this._ev.observable;
  }
  invalidate() {
    this._cache !== void 0 && (this._cache = void 0, this._ev.notify());
  }
  get current() {
    return this._cache ?? (this._cache = this._toImmutable());
  }
};
function kb(n, t) {
  const { connectionId: e, id: s, info: i } = n, r = Cd(n.scopes);
  return Bs(
    Xc({
      connectionId: e,
      id: s,
      info: i,
      canWrite: r,
      canComment: em(n.scopes),
      isReadOnly: !r,
      // Deprecated, kept for backward-compatibility
      presence: t
    })
  );
}
var xb = class extends el {
  //
  // --------------------------------------------------------------
  //
  constructor() {
    super(), this._connections = /* @__PURE__ */ new Map(), this._presences = /* @__PURE__ */ new Map(), this._users = /* @__PURE__ */ new Map();
  }
  connectionIds() {
    return this._connections.keys();
  }
  /** @internal */
  _toImmutable() {
    return Sd(
      Array.from(this._presences.keys()).map(
        (t) => this.getUser(Number(t))
      )
    );
  }
  clearOthers() {
    this._connections = /* @__PURE__ */ new Map(), this._presences = /* @__PURE__ */ new Map(), this._users = /* @__PURE__ */ new Map(), this.invalidate();
  }
  /** @internal */
  _getUser(n) {
    const t = this._connections.get(n), e = this._presences.get(n);
    if (t !== void 0 && e !== void 0)
      return kb(t, e);
  }
  getUser(n) {
    const t = this._users.get(n);
    if (t)
      return t;
    const e = this._getUser(n);
    if (e)
      return this._users.set(n, e), e;
  }
  /** @internal */
  _invalidateUser(n) {
    this._users.has(n) && this._users.delete(n), this.invalidate();
  }
  /**
   * Records a known connection. This records the connection ID and the
   * associated metadata.
   */
  setConnection(n, t, e, s) {
    this._connections.set(
      n,
      Bs({
        connectionId: n,
        id: t,
        info: e,
        scopes: s
      })
    ), this._presences.has(n) && this._invalidateUser(n);
  }
  /**
   * Removes a known connectionId. Removes both the connection's metadata and
   * the presence information.
   */
  removeConnection(n) {
    this._connections.delete(n), this._presences.delete(n), this._invalidateUser(n);
  }
  /**
   * Stores a new user from a full presence update. If the user already exists,
   * its known presence data is overwritten.
   */
  setOther(n, t) {
    this._presences.set(n, Bs(Xc(t))), this._connections.has(n) && this._invalidateUser(n);
  }
  /**
   * Patches the presence data for an existing "other". If we don't know the
   * initial presence data for this user yet, discard this patch and await the
   * full .setOther() call first.
   */
  patchOther(n, t) {
    const e = this._presences.get(n);
    if (e === void 0)
      return;
    const s = vm(e, t);
    e !== s && (this._presences.set(n, Bs(s)), this._invalidateUser(n));
  }
}, Eb = class extends el {
  constructor(n) {
    super(), this._data = Bs(Xc(n));
  }
  /** @internal */
  _toImmutable() {
    return this._data;
  }
  /**
   * Patches the current object.
   */
  patch(n) {
    const t = this._data, e = vm(t, n);
    t !== e && (this._data = Bs(e), this.invalidate());
  }
}, p0 = class extends el {
  constructor(n) {
    super(), this._value = Bs(n);
  }
  /** @internal */
  _toImmutable() {
    return this._value;
  }
  set(n) {
    this._value = Bs(n), this.invalidate();
  }
}, Ch = class extends el {
  constructor(...n) {
    super();
    const t = n.pop(), e = n;
    this._refs = e, this._refs.forEach((s) => {
      s.didInvalidate.subscribe(() => this.invalidate());
    }), this._transform = t;
  }
  /** @internal */
  _toImmutable() {
    return this._transform(
      ...this._refs.map((n) => n.current)
    );
  }
}, Tb = 1024 * 1024 - 1024;
function Ab(n) {
  let t = 0;
  return () => `${n}:${t++}`;
}
function g0(n, t) {
  return {
    type: "User",
    id: `${t.connectionId}`,
    key: n,
    payload: t
  };
}
function Ib() {
  const n = typeof document < "u" ? document : void 0, t = { current: null };
  function e() {
    (n == null ? void 0 : n.visibilityState) === "hidden" ? t.current = t.current ?? Date.now() : t.current = null;
  }
  return n == null || n.addEventListener("visibilitychange", e), [t, () => {
    n == null || n.removeEventListener("visibilitychange", e);
  }];
}
var m0 = class extends Error {
  constructor(n, t, e) {
    super(n), this.message = n, this.status = t, this.details = e;
  }
};
function Ob(n, t, e) {
  async function s(p, m, _) {
    const v = await t();
    return e(n, p, v, _, m);
  }
  async function i(p, m, _) {
    const v = await s(p, _, m);
    if (!v.ok && v.status >= 400 && v.status < 600) {
      let g;
      try {
        const y = await v.json();
        g = new m0(
          y.message,
          v.status,
          y
        );
      } catch {
        g = new m0(v.statusText, v.status);
      }
      throw g;
    }
    let b;
    try {
      b = await v.json();
    } catch {
      b = {};
    }
    return b;
  }
  async function r(p) {
    var v;
    let m;
    p != null && p.query && (m = wb(p.query));
    const _ = await s(
      "/threads",
      {
        since: (v = p == null ? void 0 : p.since) == null ? void 0 : v.toISOString(),
        query: m
      },
      {
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
    if (_.ok) {
      const b = await _.json();
      return {
        threads: b.data.map((g) => Ua(g)),
        inboxNotifications: b.inboxNotifications.map(
          (g) => Ad(g)
        ),
        deletedThreads: b.deletedThreads.map(
          (g) => cm(g)
        ),
        deletedInboxNotifications: b.deletedInboxNotifications.map(
          (g) => lm(g)
        ),
        meta: {
          requestedAt: new Date(b.meta.requestedAt)
        }
      };
    } else {
      if (_.status === 404)
        return {
          threads: [],
          inboxNotifications: [],
          deletedThreads: [],
          deletedInboxNotifications: [],
          meta: {
            requestedAt: /* @__PURE__ */ new Date()
          }
        };
      throw new Error("There was an error while getting threads.");
    }
  }
  async function o({ threadId: p }) {
    const m = await s(
      `/thread-with-notification/${p}`
    );
    if (m.ok) {
      const _ = await m.json();
      return {
        thread: Ua(_.thread),
        inboxNotification: _.inboxNotification ? Ad(_.inboxNotification) : void 0
      };
    } else {
      if (m.status === 404)
        return;
      throw new Error(`There was an error while getting thread ${p}.`);
    }
  }
  async function a({
    metadata: p,
    body: m,
    commentId: _,
    threadId: v
  }) {
    const b = await i(
      "/threads",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          id: v,
          comment: {
            id: _,
            body: m
          },
          metadata: p
        })
      }
    );
    return Ua(b);
  }
  async function c({
    metadata: p,
    threadId: m
  }) {
    return await i(
      `/threads/${encodeURIComponent(m)}/metadata`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(p)
      }
    );
  }
  async function l({
    threadId: p,
    commentId: m,
    body: _
  }) {
    const v = await i(
      `/threads/${encodeURIComponent(p)}/comments`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          id: m,
          body: _
        })
      }
    );
    return Td(v);
  }
  async function h({
    threadId: p,
    commentId: m,
    body: _
  }) {
    const v = await i(
      `/threads/${encodeURIComponent(p)}/comments/${encodeURIComponent(
        m
      )}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          body: _
        })
      }
    );
    return Td(v);
  }
  async function d({
    threadId: p,
    commentId: m
  }) {
    await i(
      `/threads/${encodeURIComponent(p)}/comments/${encodeURIComponent(
        m
      )}`,
      {
        method: "DELETE"
      }
    );
  }
  async function u({
    threadId: p,
    commentId: m,
    emoji: _
  }) {
    const v = await i(
      `/threads/${encodeURIComponent(p)}/comments/${encodeURIComponent(
        m
      )}/reactions`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ emoji: _ })
      }
    );
    return G7(v);
  }
  async function f({
    threadId: p,
    commentId: m,
    emoji: _
  }) {
    await i(
      `/threads/${encodeURIComponent(p)}/comments/${encodeURIComponent(
        m
      )}/reactions/${encodeURIComponent(_)}`,
      {
        method: "DELETE"
      }
    );
  }
  return {
    getThreads: r,
    getThread: o,
    createThread: a,
    editThreadMetadata: c,
    createComment: l,
    editComment: h,
    deleteComment: d,
    addReaction: u,
    removeReaction: f
  };
}
var Db = 50;
function Pb(n, t) {
  const e = typeof n.initialPresence == "function" ? n.initialPresence(t.roomId) : n.initialPresence, s = typeof n.initialStorage == "function" ? n.initialStorage(t.roomId) : n.initialStorage, [i, r] = Ib(), o = {
    ...t.delegates,
    // A connection is allowed to go into "zombie state" only if all of the
    // following conditions apply:
    //
    // - The `backgroundKeepAliveTimeout` client option is configured
    // - The browser window has been in the background for at least
    //   `backgroundKeepAliveTimeout` milliseconds
    // - There are no pending changes
    //
    canZombie() {
      return t.backgroundKeepAliveTimeout !== void 0 && i.current !== null && Date.now() > i.current + t.backgroundKeepAliveTimeout && aa() !== "synchronizing";
    }
  }, a = new y7(
    o,
    t.enableDebugLogging
  ), c = {
    buffer: {
      flushTimerID: void 0,
      lastFlushedAt: 0,
      presenceUpdates: (
        // Queue up the initial presence message as a Full Presence update
        {
          type: "full",
          data: e
        }
      ),
      messages: [],
      storageOperations: []
    },
    staticSessionInfo: new p0(null),
    dynamicSessionInfo: new p0(null),
    myPresence: new Eb(e),
    others: new xb(),
    initialStorage: s,
    idFactory: null,
    // Storage
    clock: 0,
    opClock: 0,
    nodes: /* @__PURE__ */ new Map(),
    root: void 0,
    undoStack: [],
    redoStack: [],
    pausedHistory: null,
    activeBatch: null,
    unacknowledgedOps: /* @__PURE__ */ new Map(),
    // Debug
    opStackTraces: process.env.NODE_ENV !== "production" ? /* @__PURE__ */ new Map() : void 0
  }, l = (x) => x(), h = t.unstable_batchedUpdates ?? l;
  let d;
  function u(x) {
    const D = a.authValue;
    if (D !== null) {
      const R = Pd(D);
      if (R !== d)
        if (d = R, D.type === "secret") {
          const j = D.token.parsed;
          c.staticSessionInfo.set({
            userId: j.k === "sec-legacy" ? j.id : j.uid,
            userInfo: j.k === "sec-legacy" ? j.info : j.ui
          });
        } else
          c.staticSessionInfo.set({
            userId: void 0,
            userInfo: void 0
          });
    }
    h(() => {
      g.status.notify(x), E(l);
    });
  }
  let f, p = !1;
  function m(x) {
    x === "reconnecting" ? f = setTimeout(() => {
      h(() => {
        g.lostConnection.notify("lost"), p = !0, c.others.clearOthers(), q({ others: [{ type: "reset" }] }, l);
      });
    }, t.lostConnectionTimeout) : (clearTimeout(f), p && (h(x === "disconnected" ? () => {
      g.lostConnection.notify("failed");
    } : () => {
      g.lostConnection.notify("restored");
    }), p = !1));
  }
  function _() {
    c.buffer.presenceUpdates = {
      type: "full",
      data: (
        // Because context.me.current is a readonly object, we'll have to
        // make a copy here. Otherwise, type errors happen later when
        // "patching" my presence.
        { ...c.myPresence.current }
      )
    }, Ce !== null && Bf({ flush: !1 }), _t();
  }
  function v() {
    clearTimeout(c.buffer.flushTimerID);
  }
  a.events.onMessage.subscribe(St), a.events.statusDidChange.subscribe(u), a.events.statusDidChange.subscribe(m), a.events.didConnect.subscribe(_), a.events.didDisconnect.subscribe(v), a.events.onLiveblocksError.subscribe((x) => {
    h(() => {
      process.env.NODE_ENV !== "production" && zu(
        `Connection to websocket server closed. Reason: ${x.message} (code: ${x.code}).`
      ), g.error.notify(x);
    });
  });
  const b = {
    roomId: t.roomId,
    getNode: (x) => c.nodes.get(x),
    addNode: (x, D) => void c.nodes.set(x, D),
    deleteNode: (x) => void c.nodes.delete(x),
    generateId: () => `${ht()}:${c.clock++}`,
    generateOpId: () => `${ht()}:${c.opClock++}`,
    dispatch(x, D, R) {
      const j = c.activeBatch;
      if (process.env.NODE_ENV !== "production") {
        const tt = _b("Storage mutation", this.dispatch);
        if (tt)
          for (const Z of x)
            Z.opId && nt(c.opStackTraces).set(Z.opId, tt);
      }
      if (j) {
        for (const tt of x)
          j.ops.push(tt);
        for (const [tt, Z] of R)
          j.updates.storageUpdates.set(
            tt,
            Sh(
              j.updates.storageUpdates.get(tt),
              Z
            )
          );
        j.reverseOps.unshift(...D);
      } else
        h(() => {
          V(D, l), c.redoStack.length = 0, As(x), q({ storageUpdates: R }, l);
        });
    },
    assertStorageIsWritable: () => {
      var R;
      const x = (R = c.dynamicSessionInfo.current) == null ? void 0 : R.scopes;
      if (x === void 0)
        return;
      if (!Cd(x))
        throw new Error(
          "Cannot write to storage with a read only user, please ensure the user has write permissions"
        );
    }
  }, g = {
    connection: It(),
    // Old/deprecated API
    status: It(),
    // New/recommended API
    lostConnection: It(),
    customEvent: It(),
    self: It(),
    myPresence: It(),
    others: It(),
    error: It(),
    storage: It(),
    history: It(),
    storageDidLoad: It(),
    storageStatus: It(),
    ydoc: It(),
    comments: It()
  };
  async function y(x, D, R, j, tt) {
    var Zt;
    const Z = hm(
      t.baseUrl,
      `/v2/c/rooms/${encodeURIComponent(x)}${D}`,
      tt
    );
    return await (((Zt = t.polyfills) == null ? void 0 : Zt.fetch) || /* istanbul ignore next */
    fetch)(Z, {
      ...j,
      headers: {
        ...j == null ? void 0 : j.headers,
        Authorization: `Bearer ${Pd(R)}`
      }
    });
  }
  async function S(x, D) {
    return y(D, "/storage", x, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  async function w(x, D) {
    if (!a.authValue)
      throw new Error("Not authorized");
    return y(t.roomId, x, a.authValue, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(D)
    });
  }
  function k(x) {
    var j;
    const D = JSON.stringify(x), R = (j = c.dynamicSessionInfo.current) == null ? void 0 : j.nonce;
    if (t.unstable_fallbackToHTTP && R && new TextEncoder().encode(D).length > Tb) {
      w("/send-message", { nonce: R, messages: x }).then(
        (Z) => {
          !Z.ok && Z.status === 403 && a.reconnect();
        }
      ), hs(
        "Message was too large for websockets and sent over HTTP instead"
      );
      return;
    }
    a.send(D);
  }
  const C = new Ch(
    c.staticSessionInfo,
    c.dynamicSessionInfo,
    c.myPresence,
    (x, D, R) => {
      if (x === null || D === null)
        return null;
      {
        const j = Cd(D.scopes);
        return {
          connectionId: D.actor,
          id: x.userId,
          info: x.userInfo,
          presence: R,
          canWrite: j,
          canComment: em(D.scopes),
          isReadOnly: !j
          // Deprecated, kept for backward-compatibility
        };
      }
    }
  );
  let A;
  function E(x) {
    const D = C.current;
    D !== null && D !== A && (x(() => {
      g.self.notify(D);
    }), A = D);
  }
  const I = new Ch(
    C,
    (x) => x !== null ? g0("Me", x) : null
  );
  function P(x, D) {
    if (x.items.length === 0)
      throw new Error("Internal error: cannot load storage without items");
    c.root !== void 0 ? M(x.items, D) : c.root = vi._fromItems(x.items, b);
    const R = c.undoStack.length;
    for (const j in c.initialStorage)
      c.root.get(j) === void 0 && c.root.set(j, ub(c.initialStorage[j]));
    c.undoStack.length = R;
  }
  function M(x, D) {
    if (c.root === void 0)
      return;
    const R = /* @__PURE__ */ new Map();
    for (const [Z, Jt] of c.nodes)
      R.set(Z, Jt._serialize());
    const j = fb(R, new Map(x)), tt = rt(j, !1);
    q(tt.updates, D);
  }
  function F(x, D) {
    c.undoStack.length >= 50 && c.undoStack.shift(), c.undoStack.push(x), Lt(D);
  }
  function V(x, D) {
    c.pausedHistory !== null ? c.pausedHistory.unshift(...x) : F(x, D);
  }
  function q(x, D) {
    const R = x.storageUpdates, j = x.others;
    D(() => {
      if (j !== void 0 && j.length > 0) {
        const tt = c.others.current;
        for (const Z of j)
          g.others.notify({ ...Z, others: tt });
      }
      if ((x.presence ?? !1) && (E(l), g.myPresence.notify(c.myPresence.current)), R !== void 0 && R.size > 0) {
        const tt = Array.from(R.values());
        g.storage.notify(tt);
      }
      ca();
    });
  }
  function ht() {
    const x = c.dynamicSessionInfo.current;
    if (x)
      return x.actor;
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function rt(x, D) {
    const R = {
      reverse: [],
      storageUpdates: /* @__PURE__ */ new Map(),
      presence: !1
    }, j = /* @__PURE__ */ new Set(), tt = x.map((Z) => Z.type !== "presence" && !Z.opId ? { ...Z, opId: b.generateOpId() } : Z);
    for (const Z of tt)
      if (Z.type === "presence") {
        const Jt = {
          type: "presence",
          data: {}
        };
        for (const Zt in Z.data)
          Jt.data[Zt] = c.myPresence.current[Zt];
        if (c.myPresence.patch(Z.data), c.buffer.presenceUpdates === null)
          c.buffer.presenceUpdates = { type: "partial", data: Z.data };
        else
          for (const Zt in Z.data)
            c.buffer.presenceUpdates.data[Zt] = Z.data[Zt];
        R.reverse.unshift(Jt), R.presence = !0;
      } else {
        let Jt;
        if (D)
          Jt = 0;
        else {
          const Or = nt(Z.opId);
          process.env.NODE_ENV !== "production" && nt(c.opStackTraces).delete(Or), Jt = c.unacknowledgedOps.delete(Or) ? 2 : 1;
        }
        const Zt = Dt(Z, Jt);
        if (Zt.modified) {
          const Or = Zt.modified.node._id;
          Or && j.has(Or) || (R.storageUpdates.set(
            nt(Zt.modified.node._id),
            Sh(
              R.storageUpdates.get(nt(Zt.modified.node._id)),
              Zt.modified
            )
          ), R.reverse.unshift(...Zt.reverse)), (Z.type === 2 || Z.type === 7 || Z.type === 4) && j.add(nt(Z.id));
        }
      }
    return {
      ops: tt,
      reverse: R.reverse,
      updates: {
        storageUpdates: R.storageUpdates,
        presence: R.presence
      }
    };
  }
  function Dt(x, D) {
    if (sb(x))
      return { modified: !1 };
    switch (x.type) {
      case 6:
      case 3:
      case 5: {
        const R = c.nodes.get(x.id);
        return R === void 0 ? { modified: !1 } : R._apply(
          x,
          D === 0
          /* UNDOREDO_RECONNECT */
        );
      }
      case 1: {
        const R = c.nodes.get(x.id);
        return R === void 0 ? { modified: !1 } : R.parent.type === "HasParent" && gm(R.parent.node) ? R.parent.node._setChildKey(
          Mo(x.parentKey),
          R,
          D
        ) : { modified: !1 };
      }
      case 4:
      case 2:
      case 7:
      case 8: {
        if (x.parentId === void 0)
          return { modified: !1 };
        const R = c.nodes.get(x.parentId);
        return R === void 0 ? { modified: !1 } : R._attachChild(x, D);
      }
    }
  }
  function K(x, D) {
    const R = {};
    c.buffer.presenceUpdates === null && (c.buffer.presenceUpdates = {
      type: "partial",
      data: {}
    });
    for (const j in x) {
      const tt = x[j];
      tt !== void 0 && (c.buffer.presenceUpdates.data[j] = tt, R[j] = c.myPresence.current[j]);
    }
    c.myPresence.patch(x), c.activeBatch ? (D != null && D.addToHistory && c.activeBatch.reverseOps.unshift({
      type: "presence",
      data: R
    }), c.activeBatch.updates.presence = !0) : (_t(), h(() => {
      D != null && D.addToHistory && V(
        [{ type: "presence", data: R }],
        l
      ), q({ presence: !0 }, l);
    }));
  }
  function X(x) {
    if (x.targetActor !== void 0) {
      const R = c.others.getUser(x.actor);
      c.others.setOther(x.actor, x.data);
      const j = c.others.getUser(x.actor);
      if (R === void 0 && j !== void 0)
        return { type: "enter", user: j };
    } else
      c.others.patchOther(x.actor, x.data);
    const D = c.others.getUser(x.actor);
    if (D)
      return {
        type: "update",
        updates: x.data,
        user: D
      };
  }
  function vt(x) {
    const D = c.others.getUser(x.actor);
    return D ? (c.others.removeConnection(x.actor), { type: "leave", user: D }) : null;
  }
  function Tt(x, D) {
    c.dynamicSessionInfo.set({
      actor: x.actor,
      nonce: x.nonce,
      scopes: x.scopes
    }), c.idFactory = Ab(x.actor), E(D);
    for (const R of c.others.connectionIds())
      x.users[R] === void 0 && c.others.removeConnection(R);
    for (const R in x.users) {
      const j = x.users[R], tt = Number(R);
      c.others.setConnection(
        tt,
        j.id,
        j.info,
        j.scopes
      );
    }
    return { type: "reset" };
  }
  function Ct() {
    return c.undoStack.length > 0;
  }
  function Ve() {
    return c.redoStack.length > 0;
  }
  function Lt(x) {
    x(() => {
      g.history.notify({ canUndo: Ct(), canRedo: Ve() });
    });
  }
  function T(x) {
    c.others.setConnection(
      x.actor,
      x.id,
      x.info,
      x.scopes
    ), c.buffer.messages.push({
      type: 100,
      data: c.myPresence.current,
      targetActor: x.actor
    }), _t();
    const D = c.others.getUser(x.actor);
    return D ? { type: "enter", user: D } : void 0;
  }
  function $(x) {
    return vb(x) ? x : null;
  }
  function W(x) {
    const D = Ku(x);
    return D === void 0 ? null : mm(D) ? Sd(D.map((R) => $(R))) : Sd([$(D)]);
  }
  function Pt(x, D) {
    if (x.size === 0)
      return;
    const R = [], j = Array.from(x.values()), tt = rt(j, !0);
    R.push({
      type: 201,
      ops: tt.ops
    }), q(tt.updates, D), k(R);
  }
  function St(x) {
    if (typeof x.data != "string")
      return;
    const D = W(x.data);
    if (D === null || D.length === 0)
      return;
    const R = {
      storageUpdates: /* @__PURE__ */ new Map(),
      others: []
    };
    h(() => {
      var j;
      for (const tt of D)
        switch (tt.type) {
          case 101: {
            const Z = T(tt);
            Z && R.others.push(Z);
            break;
          }
          case 100: {
            const Z = X(tt);
            Z && R.others.push(Z);
            break;
          }
          case 103: {
            const Z = c.others.current;
            g.customEvent.notify({
              connectionId: tt.actor,
              user: tt.actor < 0 ? null : Z.find((Jt) => Jt.connectionId === tt.actor) ?? null,
              event: tt.event
            });
            break;
          }
          case 102: {
            const Z = vt(tt);
            Z && R.others.push(Z);
            break;
          }
          case 300: {
            g.ydoc.notify(tt);
            break;
          }
          case 104: {
            R.others.push(Tt(tt, l));
            break;
          }
          case 200: {
            Ff(tt);
            break;
          }
          case 201: {
            const Z = rt(tt.ops, !1);
            for (const [Jt, Zt] of Z.updates.storageUpdates)
              R.storageUpdates.set(
                Jt,
                Sh(R.storageUpdates.get(Jt), Zt)
              );
            break;
          }
          case 299: {
            if (Wu(
              "Storage mutation rejection error",
              tt.reason
            ), process.env.NODE_ENV !== "production") {
              const Z = /* @__PURE__ */ new Set();
              for (const Jt of tt.opIds) {
                const Zt = (j = c.opStackTraces) == null ? void 0 : j.get(Jt);
                Zt && Z.add(Zt);
              }
              throw Z.size > 0 && K2(
                "The following function calls caused the rejected storage mutations:",
                `

${Array.from(Z).join(`

`)}`
              ), new Error(
                `Storage mutations rejected by server: ${tt.reason}`
              );
            }
            break;
          }
          case 400:
          case 401:
          case 405:
          case 406:
          case 402:
          case 403:
          case 404: {
            g.comments.notify(tt);
            break;
          }
        }
      q(R, l);
    });
  }
  function _t() {
    const x = c.buffer.storageOperations;
    if (x.length > 0) {
      for (const j of x)
        c.unacknowledgedOps.set(nt(j.opId), j);
      ca();
    }
    if (a.getStatus() !== "connected") {
      c.buffer.storageOperations = [];
      return;
    }
    const D = Date.now(), R = D - c.buffer.lastFlushedAt;
    if (R >= t.throttleDelay) {
      const j = Oe();
      if (j.length === 0)
        return;
      k(j), c.buffer = {
        flushTimerID: void 0,
        lastFlushedAt: D,
        messages: [],
        storageOperations: [],
        presenceUpdates: null
      };
    } else
      clearTimeout(c.buffer.flushTimerID), c.buffer.flushTimerID = setTimeout(
        _t,
        t.throttleDelay - R
      );
  }
  function Oe() {
    const x = [];
    c.buffer.presenceUpdates && x.push(
      c.buffer.presenceUpdates.type === "full" ? {
        type: 100,
        // Populating the `targetActor` field turns this message into
        // a Full Presence update message (not a patch), which will get
        // interpreted by other clients as such.
        targetActor: -1,
        data: c.buffer.presenceUpdates.data
      } : {
        type: 100,
        data: c.buffer.presenceUpdates.data
      }
    );
    for (const D of c.buffer.messages)
      x.push(D);
    return c.buffer.storageOperations.length > 0 && x.push({
      type: 201,
      ops: c.buffer.storageOperations
    }), x;
  }
  function fs(x, D) {
    const R = {
      type: 301,
      update: x,
      guid: D
    };
    c.buffer.messages.push(R), g.ydoc.notify(R), _t();
  }
  function At(x, D = {
    shouldQueueEventIfNotReady: !1
  }) {
    a.getStatus() !== "connected" && !D.shouldQueueEventIfNotReady || (c.buffer.messages.push({
      type: 103,
      event: x
    }), _t());
  }
  function As(x) {
    const { storageOperations: D } = c.buffer;
    for (const R of x)
      D.push(R);
    _t();
  }
  let Ce = null, Je = null;
  function Ff(x) {
    const D = new Map(c.unacknowledgedOps);
    P(x, l), Pt(D, l), Je == null || Je(), ca(), g.storageDidLoad.notify();
  }
  async function Y_() {
    if (!a.authValue)
      return;
    const D = await (await S(a.authValue, t.roomId)).json();
    Ff({ type: 200, items: D });
  }
  function Bf(x) {
    const D = c.buffer.messages;
    t.unstable_streamData ? Y_() : D.some(
      (R) => R.type === 200
      /* FETCH_STORAGE */
    ) || D.push({
      type: 200
      /* FETCH_STORAGE */
    }), x.flush && _t();
  }
  function Vf() {
    return Ce === null && (Bf({ flush: !0 }), Ce = new Promise((x) => {
      Je = x;
    }), ca()), Ce;
  }
  function Z_() {
    const x = c.root;
    return x !== void 0 ? x : (Vf(), null);
  }
  async function q_() {
    return c.root !== void 0 ? Promise.resolve({
      root: c.root
    }) : (await Vf(), {
      root: nt(c.root)
    });
  }
  function X_(x, D) {
    c.buffer.messages.find((R) => R.type === 300 && R.vector === x && R.guid === D) || c.buffer.messages.push({
      type: 300,
      vector: x,
      guid: D
    }), _t();
  }
  function J_() {
    if (c.activeBatch)
      throw new Error("undo is not allowed during a batch");
    const x = c.undoStack.pop();
    if (x === void 0)
      return;
    c.pausedHistory = null;
    const D = rt(x, !0);
    h(() => {
      q(D.updates, l), c.redoStack.push(D.reverse), Lt(l);
    });
    for (const R of D.ops)
      R.type !== "presence" && c.buffer.storageOperations.push(R);
    _t();
  }
  function Q_() {
    if (c.activeBatch)
      throw new Error("redo is not allowed during a batch");
    const x = c.redoStack.pop();
    if (x === void 0)
      return;
    c.pausedHistory = null;
    const D = rt(x, !0);
    h(() => {
      q(D.updates, l), c.undoStack.push(D.reverse), Lt(l);
    });
    for (const R of D.ops)
      R.type !== "presence" && c.buffer.storageOperations.push(R);
    _t();
  }
  function ty() {
    c.undoStack.length = 0, c.redoStack.length = 0;
  }
  function ey(x) {
    if (c.activeBatch)
      return x();
    let D;
    return h(() => {
      c.activeBatch = {
        ops: [],
        updates: {
          storageUpdates: /* @__PURE__ */ new Map(),
          presence: !1,
          others: []
        },
        reverseOps: []
      };
      try {
        D = x();
      } finally {
        const R = c.activeBatch;
        c.activeBatch = null, R.reverseOps.length > 0 && V(R.reverseOps, l), R.ops.length > 0 && (c.redoStack.length = 0), R.ops.length > 0 && As(R.ops), q(R.updates, l), _t();
      }
    }), D;
  }
  function sy() {
    c.pausedHistory === null && (c.pausedHistory = []);
  }
  function ny() {
    const x = c.pausedHistory;
    c.pausedHistory = null, x !== null && x.length > 0 && F(x, h);
  }
  function aa() {
    return c.root === void 0 ? Ce === null ? "not-loaded" : "loading" : c.unacknowledgedOps.size === 0 ? "synchronized" : "synchronizing";
  }
  let jf = aa();
  function ca() {
    const x = aa();
    jf !== x && (jf = x, g.storageStatus.notify(x));
  }
  const iy = new Ch(
    c.others,
    (x) => x.map((D, R) => g0(`Other ${R}`, D))
  ), Gf = {
    status: g.status.observable,
    lostConnection: g.lostConnection.observable,
    customEvent: g.customEvent.observable,
    others: g.others.observable,
    self: g.self.observable,
    myPresence: g.myPresence.observable,
    error: g.error.observable,
    storage: g.storage.observable,
    history: g.history.observable,
    storageDidLoad: g.storageDidLoad.observable,
    storageStatus: g.storageStatus.observable,
    ydoc: g.ydoc.observable,
    comments: g.comments.observable
  }, ry = Ob(
    t.roomId,
    o.authenticate,
    y
  );
  async function Xl(x, D) {
    const R = await o.authenticate(), j = await y(
      t.roomId,
      x,
      R,
      D
    );
    if (!j.ok && j.status >= 400 && j.status < 600) {
      let Z;
      try {
        const Jt = await j.json();
        Z = new dc(
          Jt.message,
          j.status,
          Jt
        );
      } catch {
        Z = new dc(
          j.statusText,
          j.status
        );
      }
      throw Z;
    }
    let tt;
    try {
      tt = await j.json();
    } catch {
      tt = {};
    }
    return tt;
  }
  function oy() {
    return Xl(
      "/notification-settings"
    );
  }
  function ay(x) {
    return Xl(
      "/notification-settings",
      {
        method: "POST",
        body: JSON.stringify(x),
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  }
  async function cy(x) {
    await Xl("/inbox-notifications/read", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ inboxNotificationIds: x })
    });
  }
  const ly = new Zu(
    async (x) => {
      const D = x.flat();
      return await cy(D), D;
    },
    { delay: Db }
  );
  async function hy(x) {
    await ly.get(x);
  }
  return Object.defineProperty(
    {
      [Sn]: {
        get presenceBuffer() {
          var x;
          return Po(((x = c.buffer.presenceUpdates) == null ? void 0 : x.data) ?? null);
        },
        // prettier-ignore
        get undoStack() {
          return Po(c.undoStack);
        },
        // prettier-ignore
        get nodeCount() {
          return c.nodes.size;
        },
        // prettier-ignore
        // Support for the Liveblocks browser extension
        getSelf_forDevTools: () => I.current,
        getOthers_forDevTools: () => iy.current,
        // prettier-ignore
        simulate: {
          // These exist only for our E2E testing app
          explicitClose: (x) => a._privateSendMachineEvent({ type: "EXPLICIT_SOCKET_CLOSE", event: x }),
          rawSend: (x) => a.send(x)
        },
        comments: {
          ...ry
        },
        notifications: {
          getRoomNotificationSettings: oy,
          updateRoomNotificationSettings: ay,
          markInboxNotificationAsRead: hy
        }
      },
      id: t.roomId,
      subscribe: Mb(Gf),
      connect: () => a.connect(),
      reconnect: () => a.reconnect(),
      disconnect: () => a.disconnect(),
      destroy: () => {
        r(), a.destroy();
      },
      // Presence
      updatePresence: K,
      updateYDoc: fs,
      broadcastEvent: At,
      // Storage
      batch: ey,
      history: {
        undo: J_,
        redo: Q_,
        canUndo: Ct,
        canRedo: Ve,
        clear: ty,
        pause: sy,
        resume: ny
      },
      fetchYDoc: X_,
      getStorage: q_,
      getStorageSnapshot: Z_,
      getStorageStatus: aa,
      events: Gf,
      // Core
      getStatus: () => a.getStatus(),
      getConnectionState: () => a.getLegacyStatus(),
      getSelf: () => C.current,
      // Presence
      getPresence: () => c.myPresence.current,
      getOthers: () => c.others.current
    },
    // Explictly make the internal field non-enumerable, to avoid aggressive
    // freezing when used with Immer
    Sn,
    { enumerable: !1 }
  );
}
function Mb(n) {
  function t(i, r) {
    return n.storage.subscribe((o) => {
      const a = o.filter(
        (c) => fm(c.node, i)
      );
      a.length > 0 && r(a);
    });
  }
  function e(i, r) {
    return n.storage.subscribe((o) => {
      for (const a of o)
        a.node._id === i._id && r(a.node);
    });
  }
  function s(i, r, o) {
    if (typeof i == "string" && Rb(i)) {
      if (typeof r != "function")
        throw new Error("Second argument must be a callback function");
      const a = r;
      switch (i) {
        case "event":
          return n.customEvent.subscribe(
            a
          );
        case "my-presence":
          return n.myPresence.subscribe(a);
        case "others": {
          const c = a;
          return n.others.subscribe((l) => {
            const { others: h, ...d } = l;
            return c(h, d);
          });
        }
        case "error":
          return n.error.subscribe(a);
        case "connection": {
          const c = a;
          return n.status.subscribe(
            (l) => c(q2(l))
          );
        }
        case "status":
          return n.status.subscribe(a);
        case "lost-connection":
          return n.lostConnection.subscribe(
            a
          );
        case "history":
          return n.history.subscribe(a);
        case "storage-status":
          return n.storageStatus.subscribe(
            a
          );
        default:
          return ys(
            i,
            `"${String(i)}" is not a valid event name`
          );
      }
    }
    if (r === void 0 || typeof i == "function")
      if (typeof i == "function") {
        const a = i;
        return n.storage.subscribe(a);
      } else
        throw new Error("Please specify a listener callback");
    if (ae(i)) {
      const a = i;
      return o != null && o.isDeep ? t(a, r) : e(a, r);
    }
    throw new Error(
      `${String(i)} is not a value that can be subscribed to.`
    );
  }
  return s;
}
function Rb(n) {
  return n === "my-presence" || n === "others" || n === "event" || n === "error" || n === "history" || n === "status" || n === "storage-status" || n === "lost-connection" || n === "connection";
}
function $b(n, t) {
  return async () => t.getAuthValue({ requestedScope: "room:read", roomId: n });
}
function Nb(n, t, e) {
  return (s) => {
    const i = e ?? (typeof WebSocket > "u" ? void 0 : WebSocket);
    if (i === void 0)
      throw new qn(
        "To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill."
      );
    const r = new URL(t);
    if (r.protocol = r.protocol === "http:" ? "ws" : "wss", r.pathname = "/v7", r.searchParams.set("roomId", n), s.type === "secret")
      r.searchParams.set("tok", s.token.raw);
    else if (s.type === "public")
      r.searchParams.set("pubkey", s.publicApiKey);
    else
      return ys(s, "Unhandled case");
    return r.searchParams.set("version", qi), new i(r.toString());
  };
}
function Lb() {
  const n = am({
    threads: {},
    queries: {},
    optimisticUpdates: [],
    inboxNotifications: {},
    notificationSettings: {}
  });
  return {
    ...n,
    deleteThread(t) {
      n.set((e) => ({
        ...e,
        threads: Ub(e.threads, t),
        inboxNotifications: Object.fromEntries(
          Object.entries(e.inboxNotifications).filter(
            ([s, i]) => i.kind === "thread" && i.threadId === t
          )
        )
      }));
    },
    updateThreadAndNotification(t, e) {
      n.set((s) => {
        const i = s.threads[t.id];
        return {
          ...s,
          threads: i === void 0 || bm(t, i) === 1 ? { ...s.threads, [t.id]: t } : s.threads,
          inboxNotifications: e === void 0 ? s.inboxNotifications : {
            ...s.inboxNotifications,
            [e.id]: e
          }
        };
      });
    },
    updateThreadsAndNotifications(t, e, s, i, r) {
      n.set((o) => ({
        ...o,
        threads: Fb(o.threads, {
          newThreads: t,
          deletedThreads: s
        }),
        inboxNotifications: Bb(
          o.inboxNotifications,
          {
            newInboxNotifications: e,
            deletedNotifications: i
          }
        ),
        queries: r !== void 0 ? {
          ...o.queries,
          [r]: {
            isLoading: !1
          }
        } : o.queries
      }));
    },
    updateRoomInboxNotificationSettings(t, e, s) {
      n.set((i) => ({
        ...i,
        notificationSettings: {
          ...i.notificationSettings,
          [t]: e
        },
        queries: {
          ...i.queries,
          [s]: {
            isLoading: !1
          }
        }
      }));
    },
    pushOptimisticUpdate(t) {
      n.set((e) => ({
        ...e,
        optimisticUpdates: [...e.optimisticUpdates, t]
      }));
    },
    setQueryState(t, e) {
      n.set((s) => ({
        ...s,
        queries: {
          ...s.queries,
          [t]: e
        }
      }));
    }
  };
}
function Ub(n, t) {
  if (Object.prototype.hasOwnProperty.call(n, t)) {
    const { [t]: e, ...s } = n;
    return s;
  }
  return n;
}
function bm(n, t) {
  return n.updatedAt && t.updatedAt ? n.updatedAt > t.updatedAt ? 1 : n.updatedAt < t.updatedAt ? -1 : 0 : n.updatedAt || t.updatedAt ? n.updatedAt ? 1 : -1 : n.createdAt > t.createdAt ? 1 : n.createdAt < t.createdAt ? -1 : 0;
}
function Fb(n, t) {
  const e = { ...n };
  return t.newThreads.forEach((s) => {
    const i = e[s.id];
    i && bm(i, s) === 1 || (e[s.id] = s);
  }), t.deletedThreads.forEach(({ id: s, deletedAt: i }) => {
    const r = e[s];
    r !== void 0 && (r.deletedAt = i, r.updatedAt = i, r.comments = []);
  }), e;
}
function Bb(n, t) {
  const e = { ...n };
  return t.newInboxNotifications.forEach((s) => {
    const i = e[s.id];
    i && Vb(
      i,
      s
    ) === 1 || (e[s.id] = s);
  }), t.deletedNotifications.forEach(
    ({ id: s }) => delete e[s]
  ), e;
}
function Vb(n, t) {
  return n.notifiedAt > t.notifiedAt ? 1 : n.notifiedAt < t.notifiedAt ? -1 : n.readAt && t.readAt ? n.readAt > t.readAt ? 1 : n.readAt < t.readAt ? -1 : 0 : n.readAt || t.readAt ? n.readAt ? 1 : -1 : 0;
}
var jb = 16, Gb = 1e3, Hb = 100, zb = 15e3, Wb = 200, Kb = 1e3, Yb = 3e4, Zb = 5e3, qb = 50, Xb = 50;
function Jb(n) {
  return typeof n == "string" && n.startsWith("http") ? n : C7;
}
function Pd(n) {
  return n.type === "public" ? n.publicApiKey : n.token.raw;
}
function Qb(n) {
  var I;
  const t = n, e = ew(t.throttle ?? Hb), s = sw(
    t.lostConnectionTimeout ?? Zb
  ), i = tw(
    t.backgroundKeepAliveTimeout
  ), r = Jb(t.baseUrl), o = b7(n), a = /* @__PURE__ */ new Map();
  function c(P) {
    L7(P.id), a.delete(P.id), P.destroy();
  }
  function l(P) {
    const M = () => {
      const F = M;
      P.unsubs.delete(F) ? P.unsubs.size === 0 && c(P.room) : hs(
        "This leave function was already called. Calling it more than once has no effect."
      );
    };
    return P.unsubs.add(M), {
      room: P.room,
      leave: M
    };
  }
  function h(P, M) {
    var rt, Dt;
    const F = a.get(P);
    if (F !== void 0)
      return l(F);
    j7(
      M.initialPresence === null || M.initialPresence === void 0,
      "Please provide an initial presence value for the current user when entering the room."
    );
    const V = Pb(
      {
        initialPresence: M.initialPresence ?? {},
        initialStorage: M.initialStorage
      },
      {
        roomId: P,
        throttleDelay: e,
        lostConnectionTimeout: s,
        backgroundKeepAliveTimeout: i,
        polyfills: t.polyfills,
        delegates: t.mockedDelegates ?? {
          createSocket: Nb(
            P,
            r,
            (rt = t.polyfills) == null ? void 0 : rt.WebSocket
          ),
          authenticate: $b(P, o)
        },
        enableDebugLogging: t.enableDebugLogging,
        unstable_batchedUpdates: M == null ? void 0 : M.unstable_batchedUpdates,
        baseUrl: r,
        unstable_fallbackToHTTP: !!t.unstable_fallbackToHTTP,
        unstable_streamData: !!t.unstable_streamData
      }
    ), q = {
      room: V,
      unsubs: /* @__PURE__ */ new Set()
    };
    if (a.set(P, q), x7(() => Array.from(a.keys())), N7(P, V), M.autoConnect ?? M.shouldInitiallyConnect ?? !0) {
      if (typeof atob > "u") {
        if (((Dt = t.polyfills) == null ? void 0 : Dt.atob) === void 0)
          throw new Error(
            "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
          );
        global.atob = t.polyfills.atob;
      }
      V.connect();
    }
    return l(q);
  }
  function d(P, M) {
    const { room: F, leave: V } = h(P, M);
    return F;
  }
  function u(P) {
    var F;
    const M = (F = a.get(P)) == null ? void 0 : F.room;
    return M || null;
  }
  function f(P) {
    var F;
    const M = ((F = a.get(P)) == null ? void 0 : F.unsubs) ?? /* @__PURE__ */ new Set();
    for (const V of M)
      V();
  }
  function p() {
    o.reset();
    for (const { room: P } of a.values())
      a7(P.getStatus()) || P.reconnect();
  }
  const m = am(null), {
    getInboxNotifications: _,
    getUnreadInboxNotificationsCount: v,
    markAllInboxNotificationsAsRead: b,
    markInboxNotificationAsRead: g
  } = W7({
    baseUrl: r,
    fetcher: ((I = t.polyfills) == null ? void 0 : I.fetch) || /* istanbul ignore next */
    fetch,
    authManager: o,
    currentUserIdStore: m
  }), y = Lb(), S = t.resolveUsers, w = _0(
    () => !S,
    "Set the resolveUsers option in createClient to specify user info."
  ), k = r0(
    async (P) => {
      const M = P.flat(), F = await (S == null ? void 0 : S({ userIds: M }));
      return w(), F ?? M.map(() => {
      });
    },
    { delay: qb }
  ), C = t.resolveRoomsInfo, A = _0(
    () => !C,
    "Set the resolveRoomsInfo option in createClient to specify room info."
  ), E = r0(
    async (P) => {
      const M = P.flat(), F = await (C == null ? void 0 : C({ roomIds: M }));
      return A(), F ?? M.map(() => {
      });
    },
    { delay: Xb }
  );
  return Object.defineProperty(
    {
      logout: p,
      // Old, deprecated APIs
      enter: d,
      getRoom: u,
      leave: f,
      // New, preferred API
      enterRoom: h,
      // Internal
      [Sn]: {
        notifications: {
          getInboxNotifications: _,
          getUnreadInboxNotificationsCount: v,
          markAllInboxNotificationsAsRead: b,
          markInboxNotificationAsRead: g
        },
        currentUserIdStore: m,
        resolveMentionSuggestions: t.resolveMentionSuggestions,
        cacheStore: y,
        usersStore: k,
        roomsInfoStore: E,
        getRoomIds() {
          return Array.from(a.keys());
        }
      }
    },
    Sn,
    {
      enumerable: !1
    }
  );
}
var dc = class extends Error {
  constructor(n, t, e) {
    super(n), this.message = n, this.status = t, this.details = e;
  }
};
function Ju(n, t, e, s, i) {
  if (typeof t != "number" || t < e || s !== void 0 && t > s)
    throw new Error(
      s !== void 0 ? `${n} should be between ${i ?? e} and ${s}.` : `${n} should be at least ${i ?? e}.`
    );
  return t;
}
function tw(n) {
  if (n !== void 0)
    return Ju(
      "backgroundKeepAliveTimeout",
      n,
      zb
    );
}
function ew(n) {
  return Ju("throttle", n, jb, Gb);
}
function sw(n) {
  return Ju(
    "lostConnectionTimeout",
    n,
    Wb,
    Yb,
    Kb
  );
}
function _0(n, ...t) {
  let e = !1;
  return process.env.NODE_ENV !== "production" ? () => {
    !e && (typeof n == "function" ? n() : n) && (hs(...t), e = !0);
  } : () => {
  };
}
var nw = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
new RegExp(
  Object.keys(nw).map((n) => `\\${n}`).join("|"),
  "g"
);
var iw = {
  _: "\\_",
  "*": "\\*",
  "#": "\\#",
  "`": "\\`",
  "~": "\\~",
  "!": "\\!",
  "|": "\\|",
  "(": "\\(",
  ")": "\\)",
  "{": "\\{",
  "}": "\\}",
  "[": "\\[",
  "]": "\\]"
};
new RegExp(
  Object.keys(iw).map((n) => `\\${n}`).join("|"),
  "g"
);
Hu(G2, qi, K8);
var rw = "@liveblocks/client", ow = "1.12.0", aw = "esm";
Hu(rw, ow, aw);
const wm = "3.7.7", cw = wm, Sr = typeof Buffer == "function", y0 = typeof TextDecoder == "function" ? new TextDecoder() : void 0, v0 = typeof TextEncoder == "function" ? new TextEncoder() : void 0, lw = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Yr = Array.prototype.slice.call(lw), ba = ((n) => {
  let t = {};
  return n.forEach((e, s) => t[e] = s), t;
})(Yr), hw = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, ue = String.fromCharCode.bind(String), b0 = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (n) => new Uint8Array(Array.prototype.slice.call(n, 0)), Sm = (n) => n.replace(/=/g, "").replace(/[+\/]/g, (t) => t == "+" ? "-" : "_"), Cm = (n) => n.replace(/[^A-Za-z0-9\+\/]/g, ""), km = (n) => {
  let t, e, s, i, r = "";
  const o = n.length % 3;
  for (let a = 0; a < n.length; ) {
    if ((e = n.charCodeAt(a++)) > 255 || (s = n.charCodeAt(a++)) > 255 || (i = n.charCodeAt(a++)) > 255)
      throw new TypeError("invalid character found");
    t = e << 16 | s << 8 | i, r += Yr[t >> 18 & 63] + Yr[t >> 12 & 63] + Yr[t >> 6 & 63] + Yr[t & 63];
  }
  return o ? r.slice(0, o - 3) + "===".substring(o) : r;
}, Qu = typeof btoa == "function" ? (n) => btoa(n) : Sr ? (n) => Buffer.from(n, "binary").toString("base64") : km, Md = Sr ? (n) => Buffer.from(n).toString("base64") : (n) => {
  let e = [];
  for (let s = 0, i = n.length; s < i; s += 4096)
    e.push(ue.apply(null, n.subarray(s, s + 4096)));
  return Qu(e.join(""));
}, Fa = (n, t = !1) => t ? Sm(Md(n)) : Md(n), dw = (n) => {
  if (n.length < 2) {
    var t = n.charCodeAt(0);
    return t < 128 ? n : t < 2048 ? ue(192 | t >>> 6) + ue(128 | t & 63) : ue(224 | t >>> 12 & 15) + ue(128 | t >>> 6 & 63) + ue(128 | t & 63);
  } else {
    var t = 65536 + (n.charCodeAt(0) - 55296) * 1024 + (n.charCodeAt(1) - 56320);
    return ue(240 | t >>> 18 & 7) + ue(128 | t >>> 12 & 63) + ue(128 | t >>> 6 & 63) + ue(128 | t & 63);
  }
}, uw = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, xm = (n) => n.replace(uw, dw), w0 = Sr ? (n) => Buffer.from(n, "utf8").toString("base64") : v0 ? (n) => Md(v0.encode(n)) : (n) => Qu(xm(n)), Ji = (n, t = !1) => t ? Sm(w0(n)) : w0(n), S0 = (n) => Ji(n, !0), fw = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, pw = (n) => {
  switch (n.length) {
    case 4:
      var t = (7 & n.charCodeAt(0)) << 18 | (63 & n.charCodeAt(1)) << 12 | (63 & n.charCodeAt(2)) << 6 | 63 & n.charCodeAt(3), e = t - 65536;
      return ue((e >>> 10) + 55296) + ue((e & 1023) + 56320);
    case 3:
      return ue((15 & n.charCodeAt(0)) << 12 | (63 & n.charCodeAt(1)) << 6 | 63 & n.charCodeAt(2));
    default:
      return ue((31 & n.charCodeAt(0)) << 6 | 63 & n.charCodeAt(1));
  }
}, Em = (n) => n.replace(fw, pw), Tm = (n) => {
  if (n = n.replace(/\s+/g, ""), !hw.test(n))
    throw new TypeError("malformed base64.");
  n += "==".slice(2 - (n.length & 3));
  let t, e = "", s, i;
  for (let r = 0; r < n.length; )
    t = ba[n.charAt(r++)] << 18 | ba[n.charAt(r++)] << 12 | (s = ba[n.charAt(r++)]) << 6 | (i = ba[n.charAt(r++)]), e += s === 64 ? ue(t >> 16 & 255) : i === 64 ? ue(t >> 16 & 255, t >> 8 & 255) : ue(t >> 16 & 255, t >> 8 & 255, t & 255);
  return e;
}, tf = typeof atob == "function" ? (n) => atob(Cm(n)) : Sr ? (n) => Buffer.from(n, "base64").toString("binary") : Tm, Am = Sr ? (n) => b0(Buffer.from(n, "base64")) : (n) => b0(tf(n).split("").map((t) => t.charCodeAt(0))), Im = (n) => Am(Om(n)), gw = Sr ? (n) => Buffer.from(n, "base64").toString("utf8") : y0 ? (n) => y0.decode(Am(n)) : (n) => Em(tf(n)), Om = (n) => Cm(n.replace(/[-_]/g, (t) => t == "-" ? "+" : "/")), Rd = (n) => gw(Om(n)), mw = (n) => {
  if (typeof n != "string")
    return !1;
  const t = n.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(t) || !/[^\s0-9a-zA-Z\-_]/.test(t);
}, Dm = (n) => ({
  value: n,
  enumerable: !1,
  writable: !0,
  configurable: !0
}), Pm = function() {
  const n = (t, e) => Object.defineProperty(String.prototype, t, Dm(e));
  n("fromBase64", function() {
    return Rd(this);
  }), n("toBase64", function(t) {
    return Ji(this, t);
  }), n("toBase64URI", function() {
    return Ji(this, !0);
  }), n("toBase64URL", function() {
    return Ji(this, !0);
  }), n("toUint8Array", function() {
    return Im(this);
  });
}, Mm = function() {
  const n = (t, e) => Object.defineProperty(Uint8Array.prototype, t, Dm(e));
  n("toBase64", function(t) {
    return Fa(this, t);
  }), n("toBase64URI", function() {
    return Fa(this, !0);
  }), n("toBase64URL", function() {
    return Fa(this, !0);
  });
}, _w = () => {
  Pm(), Mm();
}, $r = {
  version: wm,
  VERSION: cw,
  atob: tf,
  atobPolyfill: Tm,
  btoa: Qu,
  btoaPolyfill: km,
  fromBase64: Rd,
  toBase64: Ji,
  encode: Ji,
  encodeURI: S0,
  encodeURL: S0,
  utob: xm,
  btou: Em,
  decode: Rd,
  isValid: mw,
  fromUint8Array: Fa,
  toUint8Array: Im,
  extendString: Pm,
  extendUint8Array: Mm,
  extendBuiltins: _w
};
var kh = () => /* @__PURE__ */ new Map(), yw = (n, t, e) => {
  let s = n.get(t);
  return s === void 0 && n.set(t, s = e()), s;
}, vw = () => /* @__PURE__ */ new Set(), bw = Array.from, ef = class {
  constructor() {
    this._observers = kh();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(n, t) {
    yw(this._observers, n, vw).add(t);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(n, t) {
    const e = (...s) => {
      this.off(n, e), t(...s);
    };
    this.on(n, e);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(n, t) {
    const e = this._observers.get(n);
    e !== void 0 && (e.delete(t), e.size === 0 && this._observers.delete(n));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(n, t) {
    return bw((this._observers.get(n) || kh()).values()).forEach((e) => e(...t));
  }
  destroy() {
    this._observers = kh();
  }
}, Ps = "__yjs", wa = "__yjs_clientid", ww = class extends ef {
  constructor(n, t) {
    super(), this.states = /* @__PURE__ */ new Map(), this.actorToClientMap = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = 0, this.doc = n, this.room = t, this.room.updatePresence({
      [wa]: this.doc.clientID
    }), this.othersUnsub = this.room.events.others.subscribe((e) => {
      let s;
      if (this.rebuildActorToClientMap(e.others), e.type === "leave") {
        const i = this.actorToClientMap.get(
          e.user.connectionId
        );
        i !== void 0 && (s = { added: [], updated: [], removed: [i] }), this.rebuildActorToClientMap(e.others);
      }
      if (e.type === "enter" || e.type === "update") {
        this.rebuildActorToClientMap(e.others);
        const i = this.actorToClientMap.get(
          e.user.connectionId
        );
        i !== void 0 && (s = {
          added: e.type === "enter" ? [i] : [],
          updated: e.type === "update" ? [i] : [],
          removed: []
        });
      }
      s !== void 0 && (this.emit("change", [s, "presence"]), this.emit("update", [s, "presence"]));
    });
  }
  rebuildActorToClientMap(n) {
    this.actorToClientMap.clear(), n.forEach((t) => {
      t.presence[wa] !== void 0 && this.actorToClientMap.set(
        t.connectionId,
        t.presence[wa]
      );
    });
  }
  destroy() {
    this.emit("destroy", [this]), this.othersUnsub(), this.setLocalState(null), super.destroy();
  }
  getLocalState() {
    const n = this.room.getPresence();
    return Object.keys(n).length === 0 || typeof n[Ps] > "u" ? null : n[Ps];
  }
  setLocalState(n) {
    var r;
    const t = (r = this.room.getSelf()) == null ? void 0 : r.presence;
    if (n === null) {
      if (t === void 0)
        return;
      this.room.updatePresence({ ...t, [Ps]: null }), this.emit("update", [
        { added: [], updated: [], removed: [this.doc.clientID] },
        "local"
      ]);
      return;
    }
    const e = t == null ? void 0 : t[Ps], s = e === void 0 ? [this.doc.clientID] : [], i = e === void 0 ? [] : [this.doc.clientID];
    this.room.updatePresence({
      [Ps]: {
        ...e || {},
        ...n || {}
      }
    }), this.emit("update", [{ added: s, updated: i, removed: [] }, "local"]);
  }
  setLocalStateField(n, t) {
    var i;
    const e = (i = this.room.getSelf()) == null ? void 0 : i.presence[Ps], s = { [n]: t };
    this.room.updatePresence({
      [Ps]: { ...e || {}, ...s }
    });
  }
  // Translate liveblocks presence to yjs awareness
  getStates() {
    var s;
    const t = this.room.getOthers().reduce((i, r) => {
      const o = r.presence[Ps], a = r.presence[wa];
      return o !== void 0 && a !== void 0 && i.set(a, o || {}), i;
    }, /* @__PURE__ */ new Map()), e = (s = this.room.getSelf()) == null ? void 0 : s.presence[Ps];
    return e !== void 0 && t.set(this.doc.clientID, e), t;
  }
}, C0 = class extends ef {
  constructor({
    doc: n,
    isRoot: t,
    updateDoc: e,
    fetchDoc: s
  }) {
    super(), this.unsubscribers = [], this._synced = !1, this.handleServerUpdate = ({
      update: i,
      stateVector: r
    }) => {
      if (uo(this.doc, $r.toUint8Array(i), "backend"), r) {
        try {
          const o = Yo(
            this.doc,
            $r.toUint8Array(r)
          );
          this.updateRoomDoc($r.fromUint8Array(o));
        } catch (o) {
          console.warn(o);
        }
        this.synced = !0;
      }
    }, this.syncDoc = () => {
      this.synced = !1;
      const i = $r.fromUint8Array(bu(this.doc));
      this.fetchRoomDoc(i);
    }, this.updateHandler = (i, r) => {
      if (r !== "backend") {
        const o = $r.fromUint8Array(i);
        this.updateRoomDoc(o);
      }
    }, this.doc = n, this.doc.on("update", this.updateHandler), this.updateRoomDoc = (i) => {
      e(i, t ? void 0 : this.doc.guid);
    }, this.fetchRoomDoc = (i) => {
      s(i, t ? void 0 : this.doc.guid);
    }, this.syncDoc();
  }
  // The sync'd property is required by some provider implementations
  get synced() {
    return this._synced;
  }
  set synced(n) {
    this._synced !== n && (this._synced = n, this.emit("synced", [n]), this.emit("sync", [n]));
  }
  destroy() {
    this.doc.off("update", this.updateHandler), this.unsubscribers.forEach((n) => n()), this._observers = /* @__PURE__ */ new Map(), this.doc.destroy();
  }
}, Sw = "@liveblocks/yjs", Cw = "1.12.0", kw = "esm";
Hu(Sw, Cw, kw);
var xw = {
  autoloadSubdocs: !1
}, Ew = class extends ef {
  constructor(n, t, e = xw) {
    super(), this.unsubscribers = [], this.subdocHandlers = /* @__PURE__ */ new Map(), this.handleSubdocs = ({
      loaded: s,
      removed: i,
      added: r
    }) => {
      var o;
      if (s.forEach(this.createSubdocHandler), this.options.autoloadSubdocs)
        for (const a of r)
          this.subdocHandlers.has(a.guid) || a.load();
      for (const a of i)
        this.subdocHandlers.has(a.guid) && ((o = this.subdocHandlers.get(a.guid)) == null || o.destroy(), this.subdocHandlers.delete(a.guid));
    }, this.updateDoc = (s, i) => {
      this.room.updateYDoc(s, i);
    }, this.fetchDoc = (s, i) => {
      this.room.fetchYDoc(s, i);
    }, this.createSubdocHandler = (s) => {
      var r;
      if (this.subdocHandlers.has(s.guid)) {
        (r = this.subdocHandlers.get(s.guid)) == null || r.syncDoc();
        return;
      }
      const i = new C0({
        doc: s,
        isRoot: !1,
        updateDoc: this.updateDoc,
        fetchDoc: this.fetchDoc
      });
      this.subdocHandlers.set(s.guid, i);
    }, this.loadSubdoc = (s) => {
      for (const i of this.rootDoc.subdocs)
        if (i.guid === s)
          return i.load(), !0;
      return !1;
    }, this.syncDoc = () => {
      this.rootDocHandler.syncDoc();
      for (const [s, i] of this.subdocHandlers)
        i.syncDoc();
    }, this.rootDoc = t, this.room = n, this.options = e, this.rootDocHandler = new C0({
      doc: t,
      isRoot: !0,
      updateDoc: this.updateDoc,
      fetchDoc: this.fetchDoc
    }), this.awareness = new ww(this.rootDoc, this.room), this.unsubscribers.push(
      this.room.events.status.subscribe((s) => {
        s === "connected" ? this.rootDocHandler.syncDoc() : this.rootDocHandler.synced = !1;
      })
    ), this.unsubscribers.push(
      this.room.events.ydoc.subscribe((s) => {
        var c;
        const { type: i } = s;
        if (i === ym.UPDATE_YDOC)
          return;
        const { stateVector: r, update: o, guid: a } = s;
        a !== void 0 ? (c = this.subdocHandlers.get(a)) == null || c.handleServerUpdate({ update: o, stateVector: r }) : this.rootDocHandler.handleServerUpdate({ update: o, stateVector: r });
      })
    ), this.rootDocHandler.on("synced", () => {
      const s = this.rootDocHandler.synced;
      for (const [i, r] of this.subdocHandlers)
        r.syncDoc();
      this.emit("synced", [s]), this.emit("sync", [s]);
    }), this.rootDoc.on("subdocs", this.handleSubdocs), this.syncDoc();
  }
  // The sync'd property is required by some provider implementations
  get synced() {
    return this.rootDocHandler.synced;
  }
  destroy() {
    this.unsubscribers.forEach((n) => n()), this.awareness.destroy(), this.rootDocHandler.destroy(), this._observers = /* @__PURE__ */ new Map();
    for (const [n, t] of this.subdocHandlers)
      t.destroy();
    this.subdocHandlers.clear(), super.destroy();
  }
  // Some provider implementations expect to be able to call connect/disconnect, implement as noop
  disconnect() {
  }
  connect() {
  }
};
class Tw {
  constructor(t) {
    this.Block = t;
  }
  add(t, e) {
    const s = this.Block, i = s.pickModelProps(t, {
      initProps: {
        std: e.std,
        model: t
      }
    });
    new s(i).mount(e), this.renderChildren(t, e);
  }
  remove(t, e) {
    const s = this.getNode(t, e);
    e.std.selection.update((i) => i.filter((r) => r.blockId !== t.id)), s == null || s.destroy();
  }
  update(t, e) {
    const s = this.getNode(t, e);
    if (!s || !s.update) {
      console.warn("Node not implemented update:", s);
      return;
    }
    s == null || s.update(e);
  }
  renderChildren(t, e) {
    const s = e.std.spec;
    t.children.forEach((i) => {
      var a;
      const r = i.flavour, o = (a = s.getView(r)) == null ? void 0 : a.component;
      o && o.add(i, e);
    });
  }
  getNode(t, e) {
    const { stage: s } = e;
    return s.findOne("#" + t.getFullId());
  }
}
const Ec = class Ec extends Nu {
  constructor() {
    super();
  }
  getFullId() {
    return this.flavour + ":" + this.id;
  }
  static props() {
    return {
      // title: internal.Text(),
      name: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      rotation: 0,
      scaleX: 1,
      scaleY: 1
    };
  }
  static defineSchema() {
    return h6({
      flavour: this.flavour,
      props: this.props,
      metadata: this.metadata,
      toModel: () => new this()
    });
  }
};
Ec.flavour = "xpix:base", Ec.metadata = {
  version: 1,
  role: "root"
};
let ai = Ec;
class Rm extends ai {
  // Schema config
}
var sf = { exports: {} }, sl = {}, $m = {}, ft = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n._registerNode = n.Konva = n.glob = void 0;
  const t = Math.PI / 180;
  function e() {
    return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
  }
  n.glob = typeof Kf < "u" ? Kf : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {}, n.Konva = {
    _global: n.glob,
    version: "9.3.6",
    isBrowser: e(),
    isUnminified: /param/.test((function(i) {
    }).toString()),
    dblClickWindow: 400,
    getAngle(i) {
      return n.Konva.angleDeg ? i * t : i;
    },
    enableTrace: !1,
    pointerEventsEnabled: !0,
    autoDrawEnabled: !0,
    hitOnDragEnabled: !1,
    capturePointerEventsEnabled: !1,
    _mouseListenClick: !1,
    _touchListenClick: !1,
    _pointerListenClick: !1,
    _mouseInDblClickWindow: !1,
    _touchInDblClickWindow: !1,
    _pointerInDblClickWindow: !1,
    _mouseDblClickPointerId: null,
    _touchDblClickPointerId: null,
    _pointerDblClickPointerId: null,
    pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
    dragDistance: 3,
    angleDeg: !0,
    showWarnings: !0,
    dragButtons: [0, 1],
    isDragging() {
      return n.Konva.DD.isDragging;
    },
    isTransforming() {
      var i;
      return (i = n.Konva.Transformer) === null || i === void 0 ? void 0 : i.isTransforming();
    },
    isDragReady() {
      return !!n.Konva.DD.node;
    },
    releaseCanvasOnDestroy: !0,
    document: n.glob.document,
    _injectGlobal(i) {
      n.glob.Konva = i;
    }
  };
  const s = (i) => {
    n.Konva[i.prototype.getClassName()] = i;
  };
  n._registerNode = s, n.Konva._injectGlobal(n.Konva);
})(ft);
var Vt = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Util = n.Transform = void 0;
  const t = ft;
  class e {
    constructor(y = [1, 0, 0, 1, 0, 0]) {
      this.dirty = !1, this.m = y && y.slice() || [1, 0, 0, 1, 0, 0];
    }
    reset() {
      this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
    }
    copy() {
      return new e(this.m);
    }
    copyInto(y) {
      y.m[0] = this.m[0], y.m[1] = this.m[1], y.m[2] = this.m[2], y.m[3] = this.m[3], y.m[4] = this.m[4], y.m[5] = this.m[5];
    }
    point(y) {
      var S = this.m;
      return {
        x: S[0] * y.x + S[2] * y.y + S[4],
        y: S[1] * y.x + S[3] * y.y + S[5]
      };
    }
    translate(y, S) {
      return this.m[4] += this.m[0] * y + this.m[2] * S, this.m[5] += this.m[1] * y + this.m[3] * S, this;
    }
    scale(y, S) {
      return this.m[0] *= y, this.m[1] *= y, this.m[2] *= S, this.m[3] *= S, this;
    }
    rotate(y) {
      var S = Math.cos(y), w = Math.sin(y), k = this.m[0] * S + this.m[2] * w, C = this.m[1] * S + this.m[3] * w, A = this.m[0] * -w + this.m[2] * S, E = this.m[1] * -w + this.m[3] * S;
      return this.m[0] = k, this.m[1] = C, this.m[2] = A, this.m[3] = E, this;
    }
    getTranslation() {
      return {
        x: this.m[4],
        y: this.m[5]
      };
    }
    skew(y, S) {
      var w = this.m[0] + this.m[2] * S, k = this.m[1] + this.m[3] * S, C = this.m[2] + this.m[0] * y, A = this.m[3] + this.m[1] * y;
      return this.m[0] = w, this.m[1] = k, this.m[2] = C, this.m[3] = A, this;
    }
    multiply(y) {
      var S = this.m[0] * y.m[0] + this.m[2] * y.m[1], w = this.m[1] * y.m[0] + this.m[3] * y.m[1], k = this.m[0] * y.m[2] + this.m[2] * y.m[3], C = this.m[1] * y.m[2] + this.m[3] * y.m[3], A = this.m[0] * y.m[4] + this.m[2] * y.m[5] + this.m[4], E = this.m[1] * y.m[4] + this.m[3] * y.m[5] + this.m[5];
      return this.m[0] = S, this.m[1] = w, this.m[2] = k, this.m[3] = C, this.m[4] = A, this.m[5] = E, this;
    }
    invert() {
      var y = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), S = this.m[3] * y, w = -this.m[1] * y, k = -this.m[2] * y, C = this.m[0] * y, A = y * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), E = y * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      return this.m[0] = S, this.m[1] = w, this.m[2] = k, this.m[3] = C, this.m[4] = A, this.m[5] = E, this;
    }
    getMatrix() {
      return this.m;
    }
    decompose() {
      var y = this.m[0], S = this.m[1], w = this.m[2], k = this.m[3], C = this.m[4], A = this.m[5], E = y * k - S * w;
      let I = {
        x: C,
        y: A,
        rotation: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0
      };
      if (y != 0 || S != 0) {
        var P = Math.sqrt(y * y + S * S);
        I.rotation = S > 0 ? Math.acos(y / P) : -Math.acos(y / P), I.scaleX = P, I.scaleY = E / P, I.skewX = (y * w + S * k) / E, I.skewY = 0;
      } else if (w != 0 || k != 0) {
        var M = Math.sqrt(w * w + k * k);
        I.rotation = Math.PI / 2 - (k > 0 ? Math.acos(-w / M) : -Math.acos(w / M)), I.scaleX = E / M, I.scaleY = M, I.skewX = 0, I.skewY = (y * w + S * k) / E;
      }
      return I.rotation = n.Util._getRotation(I.rotation), I;
    }
  }
  n.Transform = e;
  var s = "[object Array]", i = "[object Number]", r = "[object String]", o = "[object Boolean]", a = Math.PI / 180, c = 180 / Math.PI, l = "#", h = "", d = "0", u = "Konva warning: ", f = "Konva error: ", p = "rgb(", m = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 132, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 255, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [119, 128, 144],
    slategrey: [119, 128, 144],
    snow: [255, 255, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    transparent: [255, 255, 255, 0],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 5]
  }, _ = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, v = [];
  const b = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(g) {
    setTimeout(g, 60);
  };
  n.Util = {
    _isElement(g) {
      return !!(g && g.nodeType == 1);
    },
    _isFunction(g) {
      return !!(g && g.constructor && g.call && g.apply);
    },
    _isPlainObject(g) {
      return !!g && g.constructor === Object;
    },
    _isArray(g) {
      return Object.prototype.toString.call(g) === s;
    },
    _isNumber(g) {
      return Object.prototype.toString.call(g) === i && !isNaN(g) && isFinite(g);
    },
    _isString(g) {
      return Object.prototype.toString.call(g) === r;
    },
    _isBoolean(g) {
      return Object.prototype.toString.call(g) === o;
    },
    isObject(g) {
      return g instanceof Object;
    },
    isValidSelector(g) {
      if (typeof g != "string")
        return !1;
      var y = g[0];
      return y === "#" || y === "." || y === y.toUpperCase();
    },
    _sign(g) {
      return g === 0 || g > 0 ? 1 : -1;
    },
    requestAnimFrame(g) {
      v.push(g), v.length === 1 && b(function() {
        const y = v;
        v = [], y.forEach(function(S) {
          S();
        });
      });
    },
    createCanvasElement() {
      var g = document.createElement("canvas");
      try {
        g.style = g.style || {};
      } catch {
      }
      return g;
    },
    createImageElement() {
      return document.createElement("img");
    },
    _isInDocument(g) {
      for (; g = g.parentNode; )
        if (g == document)
          return !0;
      return !1;
    },
    _urlToImage(g, y) {
      var S = n.Util.createImageElement();
      S.onload = function() {
        y(S);
      }, S.src = g;
    },
    _rgbToHex(g, y, S) {
      return ((1 << 24) + (g << 16) + (y << 8) + S).toString(16).slice(1);
    },
    _hexToRgb(g) {
      g = g.replace(l, h);
      var y = parseInt(g, 16);
      return {
        r: y >> 16 & 255,
        g: y >> 8 & 255,
        b: y & 255
      };
    },
    getRandomColor() {
      for (var g = (Math.random() * 16777215 << 0).toString(16); g.length < 6; )
        g = d + g;
      return l + g;
    },
    getRGB(g) {
      var y;
      return g in m ? (y = m[g], {
        r: y[0],
        g: y[1],
        b: y[2]
      }) : g[0] === l ? this._hexToRgb(g.substring(1)) : g.substr(0, 4) === p ? (y = _.exec(g.replace(/ /g, "")), {
        r: parseInt(y[1], 10),
        g: parseInt(y[2], 10),
        b: parseInt(y[3], 10)
      }) : {
        r: 0,
        g: 0,
        b: 0
      };
    },
    colorToRGBA(g) {
      return g = g || "black", n.Util._namedColorToRBA(g) || n.Util._hex3ColorToRGBA(g) || n.Util._hex4ColorToRGBA(g) || n.Util._hex6ColorToRGBA(g) || n.Util._hex8ColorToRGBA(g) || n.Util._rgbColorToRGBA(g) || n.Util._rgbaColorToRGBA(g) || n.Util._hslColorToRGBA(g);
    },
    _namedColorToRBA(g) {
      var y = m[g.toLowerCase()];
      return y ? {
        r: y[0],
        g: y[1],
        b: y[2],
        a: 1
      } : null;
    },
    _rgbColorToRGBA(g) {
      if (g.indexOf("rgb(") === 0) {
        g = g.match(/rgb\(([^)]+)\)/)[1];
        var y = g.split(/ *, */).map(Number);
        return {
          r: y[0],
          g: y[1],
          b: y[2],
          a: 1
        };
      }
    },
    _rgbaColorToRGBA(g) {
      if (g.indexOf("rgba(") === 0) {
        g = g.match(/rgba\(([^)]+)\)/)[1];
        var y = g.split(/ *, */).map((S, w) => S.slice(-1) === "%" ? w === 3 ? parseInt(S) / 100 : parseInt(S) / 100 * 255 : Number(S));
        return {
          r: y[0],
          g: y[1],
          b: y[2],
          a: y[3]
        };
      }
    },
    _hex8ColorToRGBA(g) {
      if (g[0] === "#" && g.length === 9)
        return {
          r: parseInt(g.slice(1, 3), 16),
          g: parseInt(g.slice(3, 5), 16),
          b: parseInt(g.slice(5, 7), 16),
          a: parseInt(g.slice(7, 9), 16) / 255
        };
    },
    _hex6ColorToRGBA(g) {
      if (g[0] === "#" && g.length === 7)
        return {
          r: parseInt(g.slice(1, 3), 16),
          g: parseInt(g.slice(3, 5), 16),
          b: parseInt(g.slice(5, 7), 16),
          a: 1
        };
    },
    _hex4ColorToRGBA(g) {
      if (g[0] === "#" && g.length === 5)
        return {
          r: parseInt(g[1] + g[1], 16),
          g: parseInt(g[2] + g[2], 16),
          b: parseInt(g[3] + g[3], 16),
          a: parseInt(g[4] + g[4], 16) / 255
        };
    },
    _hex3ColorToRGBA(g) {
      if (g[0] === "#" && g.length === 4)
        return {
          r: parseInt(g[1] + g[1], 16),
          g: parseInt(g[2] + g[2], 16),
          b: parseInt(g[3] + g[3], 16),
          a: 1
        };
    },
    _hslColorToRGBA(g) {
      if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(g)) {
        const [y, ...S] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(g), w = Number(S[0]) / 360, k = Number(S[1]) / 100, C = Number(S[2]) / 100;
        let A, E, I;
        if (k === 0)
          return I = C * 255, {
            r: Math.round(I),
            g: Math.round(I),
            b: Math.round(I),
            a: 1
          };
        C < 0.5 ? A = C * (1 + k) : A = C + k - C * k;
        const P = 2 * C - A, M = [0, 0, 0];
        for (let F = 0; F < 3; F++)
          E = w + 1 / 3 * -(F - 1), E < 0 && E++, E > 1 && E--, 6 * E < 1 ? I = P + (A - P) * 6 * E : 2 * E < 1 ? I = A : 3 * E < 2 ? I = P + (A - P) * (2 / 3 - E) * 6 : I = P, M[F] = I * 255;
        return {
          r: Math.round(M[0]),
          g: Math.round(M[1]),
          b: Math.round(M[2]),
          a: 1
        };
      }
    },
    haveIntersection(g, y) {
      return !(y.x > g.x + g.width || y.x + y.width < g.x || y.y > g.y + g.height || y.y + y.height < g.y);
    },
    cloneObject(g) {
      var y = {};
      for (var S in g)
        this._isPlainObject(g[S]) ? y[S] = this.cloneObject(g[S]) : this._isArray(g[S]) ? y[S] = this.cloneArray(g[S]) : y[S] = g[S];
      return y;
    },
    cloneArray(g) {
      return g.slice(0);
    },
    degToRad(g) {
      return g * a;
    },
    radToDeg(g) {
      return g * c;
    },
    _degToRad(g) {
      return n.Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), n.Util.degToRad(g);
    },
    _radToDeg(g) {
      return n.Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), n.Util.radToDeg(g);
    },
    _getRotation(g) {
      return t.Konva.angleDeg ? n.Util.radToDeg(g) : g;
    },
    _capitalize(g) {
      return g.charAt(0).toUpperCase() + g.slice(1);
    },
    throw(g) {
      throw new Error(f + g);
    },
    error(g) {
      console.error(f + g);
    },
    warn(g) {
      t.Konva.showWarnings && console.warn(u + g);
    },
    each(g, y) {
      for (var S in g)
        y(S, g[S]);
    },
    _inRange(g, y, S) {
      return y <= g && g < S;
    },
    _getProjectionToSegment(g, y, S, w, k, C) {
      var A, E, I, P = (g - S) * (g - S) + (y - w) * (y - w);
      if (P == 0)
        A = g, E = y, I = (k - S) * (k - S) + (C - w) * (C - w);
      else {
        var M = ((k - g) * (S - g) + (C - y) * (w - y)) / P;
        M < 0 ? (A = g, E = y, I = (g - k) * (g - k) + (y - C) * (y - C)) : M > 1 ? (A = S, E = w, I = (S - k) * (S - k) + (w - C) * (w - C)) : (A = g + M * (S - g), E = y + M * (w - y), I = (A - k) * (A - k) + (E - C) * (E - C));
      }
      return [A, E, I];
    },
    _getProjectionToLine(g, y, S) {
      var w = n.Util.cloneObject(g), k = Number.MAX_VALUE;
      return y.forEach(function(C, A) {
        if (!(!S && A === y.length - 1)) {
          var E = y[(A + 1) % y.length], I = n.Util._getProjectionToSegment(C.x, C.y, E.x, E.y, g.x, g.y), P = I[0], M = I[1], F = I[2];
          F < k && (w.x = P, w.y = M, k = F);
        }
      }), w;
    },
    _prepareArrayForTween(g, y, S) {
      var w, k = [], C = [];
      if (g.length > y.length) {
        var A = y;
        y = g, g = A;
      }
      for (w = 0; w < g.length; w += 2)
        k.push({
          x: g[w],
          y: g[w + 1]
        });
      for (w = 0; w < y.length; w += 2)
        C.push({
          x: y[w],
          y: y[w + 1]
        });
      var E = [];
      return C.forEach(function(I) {
        var P = n.Util._getProjectionToLine(I, k, S);
        E.push(P.x), E.push(P.y);
      }), E;
    },
    _prepareToStringify(g) {
      var y;
      g.visitedByCircularReferenceRemoval = !0;
      for (var S in g)
        if (g.hasOwnProperty(S) && g[S] && typeof g[S] == "object") {
          if (y = Object.getOwnPropertyDescriptor(g, S), g[S].visitedByCircularReferenceRemoval || n.Util._isElement(g[S]))
            if (y.configurable)
              delete g[S];
            else
              return null;
          else if (n.Util._prepareToStringify(g[S]) === null)
            if (y.configurable)
              delete g[S];
            else
              return null;
        }
      return delete g.visitedByCircularReferenceRemoval, g;
    },
    _assign(g, y) {
      for (var S in y)
        g[S] = y[S];
      return g;
    },
    _getFirstPointerId(g) {
      return g.touches ? g.changedTouches[0].identifier : g.pointerId || 999;
    },
    releaseCanvas(...g) {
      t.Konva.releaseCanvasOnDestroy && g.forEach((y) => {
        y.width = 0, y.height = 0;
      });
    },
    drawRoundedRectPath(g, y, S, w) {
      let k = 0, C = 0, A = 0, E = 0;
      typeof w == "number" ? k = C = A = E = Math.min(w, y / 2, S / 2) : (k = Math.min(w[0] || 0, y / 2, S / 2), C = Math.min(w[1] || 0, y / 2, S / 2), E = Math.min(w[2] || 0, y / 2, S / 2), A = Math.min(w[3] || 0, y / 2, S / 2)), g.moveTo(k, 0), g.lineTo(y - C, 0), g.arc(y - C, C, C, Math.PI * 3 / 2, 0, !1), g.lineTo(y, S - E), g.arc(y - E, S - E, E, 0, Math.PI / 2, !1), g.lineTo(A, S), g.arc(A, S - A, A, Math.PI / 2, Math.PI, !1), g.lineTo(0, k), g.arc(k, k, k, Math.PI, Math.PI * 3 / 2, !1);
    }
  };
})(Vt);
var Nt = {}, ut = {}, z = {};
Object.defineProperty(z, "__esModule", { value: !0 });
z.getComponentValidator = z.getBooleanValidator = z.getNumberArrayValidator = z.getFunctionValidator = z.getStringOrGradientValidator = z.getStringValidator = z.getNumberOrAutoValidator = z.getNumberOrArrayOfNumbersValidator = z.getNumberValidator = z.alphaComponent = z.RGBComponent = void 0;
const Xs = ft, jt = Vt;
function Js(n) {
  return jt.Util._isString(n) ? '"' + n + '"' : Object.prototype.toString.call(n) === "[object Number]" || jt.Util._isBoolean(n) ? n : Object.prototype.toString.call(n);
}
function Aw(n) {
  return n > 255 ? 255 : n < 0 ? 0 : Math.round(n);
}
z.RGBComponent = Aw;
function Iw(n) {
  return n > 1 ? 1 : n < 1e-4 ? 1e-4 : n;
}
z.alphaComponent = Iw;
function Ow() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      return jt.Util._isNumber(n) || jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a number.'), n;
    };
}
z.getNumberValidator = Ow;
function Dw(n) {
  if (Xs.Konva.isUnminified)
    return function(t, e) {
      let s = jt.Util._isNumber(t), i = jt.Util._isArray(t) && t.length == n;
      return !s && !i && jt.Util.warn(Js(t) + ' is a not valid value for "' + e + '" attribute. The value should be a number or Array<number>(' + n + ")"), t;
    };
}
z.getNumberOrArrayOfNumbersValidator = Dw;
function Pw() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      var e = jt.Util._isNumber(n), s = n === "auto";
      return e || s || jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a number or "auto".'), n;
    };
}
z.getNumberOrAutoValidator = Pw;
function Mw() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      return jt.Util._isString(n) || jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a string.'), n;
    };
}
z.getStringValidator = Mw;
function Rw() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      const e = jt.Util._isString(n), s = Object.prototype.toString.call(n) === "[object CanvasGradient]" || n && n.addColorStop;
      return e || s || jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a string or a native gradient.'), n;
    };
}
z.getStringOrGradientValidator = Rw;
function $w() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      return jt.Util._isFunction(n) || jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a function.'), n;
    };
}
z.getFunctionValidator = $w;
function Nw() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      const e = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
      return e && n instanceof e || (jt.Util._isArray(n) ? n.forEach(function(s) {
        jt.Util._isNumber(s) || jt.Util.warn('"' + t + '" attribute has non numeric element ' + s + ". Make sure that all elements are numbers.");
      }) : jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a array of numbers.')), n;
    };
}
z.getNumberArrayValidator = Nw;
function Lw() {
  if (Xs.Konva.isUnminified)
    return function(n, t) {
      var e = n === !0 || n === !1;
      return e || jt.Util.warn(Js(n) + ' is a not valid value for "' + t + '" attribute. The value should be a boolean.'), n;
    };
}
z.getBooleanValidator = Lw;
function Uw(n) {
  if (Xs.Konva.isUnminified)
    return function(t, e) {
      return t == null || jt.Util.isObject(t) || jt.Util.warn(Js(t) + ' is a not valid value for "' + e + '" attribute. The value should be an object with properties ' + n), t;
    };
}
z.getComponentValidator = Uw;
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Factory = void 0;
  const t = Vt, e = z;
  var s = "get", i = "set";
  n.Factory = {
    addGetterSetter(r, o, a, c, l) {
      n.Factory.addGetter(r, o, a), n.Factory.addSetter(r, o, c, l), n.Factory.addOverloadedGetterSetter(r, o);
    },
    addGetter(r, o, a) {
      var c = s + t.Util._capitalize(o);
      r.prototype[c] = r.prototype[c] || function() {
        var l = this.attrs[o];
        return l === void 0 ? a : l;
      };
    },
    addSetter(r, o, a, c) {
      var l = i + t.Util._capitalize(o);
      r.prototype[l] || n.Factory.overWriteSetter(r, o, a, c);
    },
    overWriteSetter(r, o, a, c) {
      var l = i + t.Util._capitalize(o);
      r.prototype[l] = function(h) {
        return a && h !== void 0 && h !== null && (h = a.call(this, h, o)), this._setAttr(o, h), c && c.call(this), this;
      };
    },
    addComponentsGetterSetter(r, o, a, c, l) {
      var h = a.length, d = t.Util._capitalize, u = s + d(o), f = i + d(o), p, m;
      r.prototype[u] = function() {
        var v = {};
        for (p = 0; p < h; p++)
          m = a[p], v[m] = this.getAttr(o + d(m));
        return v;
      };
      var _ = (0, e.getComponentValidator)(a);
      r.prototype[f] = function(v) {
        var b = this.attrs[o], g;
        c && (v = c.call(this, v)), _ && _.call(this, v, o);
        for (g in v)
          v.hasOwnProperty(g) && this._setAttr(o + d(g), v[g]);
        return v || a.forEach((y) => {
          this._setAttr(o + d(y), void 0);
        }), this._fireChangeEvent(o, b, v), l && l.call(this), this;
      }, n.Factory.addOverloadedGetterSetter(r, o);
    },
    addOverloadedGetterSetter(r, o) {
      var a = t.Util._capitalize(o), c = i + a, l = s + a;
      r.prototype[o] = function() {
        return arguments.length ? (this[c](arguments[0]), this) : this[l]();
      };
    },
    addDeprecatedGetterSetter(r, o, a, c) {
      t.Util.error("Adding deprecated " + o);
      var l = s + t.Util._capitalize(o), h = o + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
      r.prototype[l] = function() {
        t.Util.error(h);
        var d = this.attrs[o];
        return d === void 0 ? a : d;
      }, n.Factory.addSetter(r, o, c, function() {
        t.Util.error(h);
      }), n.Factory.addOverloadedGetterSetter(r, o);
    },
    backCompat(r, o) {
      t.Util.each(o, function(a, c) {
        var l = r.prototype[c], h = s + t.Util._capitalize(a), d = i + t.Util._capitalize(a);
        function u() {
          l.apply(this, arguments), t.Util.error('"' + a + '" method is deprecated and will be removed soon. Use ""' + c + '" instead.');
        }
        r.prototype[a] = u, r.prototype[h] = u, r.prototype[d] = u;
      });
    },
    afterSetFilter() {
      this._filterUpToDate = !1;
    }
  };
})(ut);
var rs = {}, Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.HitContext = Vs.SceneContext = Vs.Context = void 0;
const Nm = Vt, Fw = ft;
function Bw(n) {
  var t = [], e = n.length, s = Nm.Util, i, r;
  for (i = 0; i < e; i++)
    r = n[i], s._isNumber(r) ? r = Math.round(r * 1e3) / 1e3 : s._isString(r) || (r = r + ""), t.push(r);
  return t;
}
var k0 = ",", Vw = "(", jw = ")", Gw = "([", Hw = "])", zw = ";", Ww = "()", Kw = "=", x0 = [
  "arc",
  "arcTo",
  "beginPath",
  "bezierCurveTo",
  "clearRect",
  "clip",
  "closePath",
  "createLinearGradient",
  "createPattern",
  "createRadialGradient",
  "drawImage",
  "ellipse",
  "fill",
  "fillText",
  "getImageData",
  "createImageData",
  "lineTo",
  "moveTo",
  "putImageData",
  "quadraticCurveTo",
  "rect",
  "roundRect",
  "restore",
  "rotate",
  "save",
  "scale",
  "setLineDash",
  "setTransform",
  "stroke",
  "strokeText",
  "transform",
  "translate"
], Yw = [
  "fillStyle",
  "strokeStyle",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "letterSpacing",
  "lineCap",
  "lineDashOffset",
  "lineJoin",
  "lineWidth",
  "miterLimit",
  "direction",
  "font",
  "textAlign",
  "textBaseline",
  "globalAlpha",
  "globalCompositeOperation",
  "imageSmoothingEnabled"
];
const Zw = 100;
class nl {
  constructor(t) {
    this.canvas = t, Fw.Konva.enableTrace && (this.traceArr = [], this._enableTrace());
  }
  fillShape(t) {
    t.fillEnabled() && this._fill(t);
  }
  _fill(t) {
  }
  strokeShape(t) {
    t.hasStroke() && this._stroke(t);
  }
  _stroke(t) {
  }
  fillStrokeShape(t) {
    t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t));
  }
  getTrace(t, e) {
    var s = this.traceArr, i = s.length, r = "", o, a, c, l;
    for (o = 0; o < i; o++)
      a = s[o], c = a.method, c ? (l = a.args, r += c, t ? r += Ww : Nm.Util._isArray(l[0]) ? r += Gw + l.join(k0) + Hw : (e && (l = l.map((h) => typeof h == "number" ? Math.floor(h) : h)), r += Vw + l.join(k0) + jw)) : (r += a.property, t || (r += Kw + a.val)), r += zw;
    return r;
  }
  clearTrace() {
    this.traceArr = [];
  }
  _trace(t) {
    var e = this.traceArr, s;
    e.push(t), s = e.length, s >= Zw && e.shift();
  }
  reset() {
    var t = this.getCanvas().getPixelRatio();
    this.setTransform(1 * t, 0, 0, 1 * t, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  clear(t) {
    var e = this.getCanvas();
    t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, e.getWidth() / e.pixelRatio, e.getHeight() / e.pixelRatio);
  }
  _applyLineCap(t) {
    const e = t.attrs.lineCap;
    e && this.setAttr("lineCap", e);
  }
  _applyOpacity(t) {
    var e = t.getAbsoluteOpacity();
    e !== 1 && this.setAttr("globalAlpha", e);
  }
  _applyLineJoin(t) {
    const e = t.attrs.lineJoin;
    e && this.setAttr("lineJoin", e);
  }
  setAttr(t, e) {
    this._context[t] = e;
  }
  arc(t, e, s, i, r, o) {
    this._context.arc(t, e, s, i, r, o);
  }
  arcTo(t, e, s, i, r) {
    this._context.arcTo(t, e, s, i, r);
  }
  beginPath() {
    this._context.beginPath();
  }
  bezierCurveTo(t, e, s, i, r, o) {
    this._context.bezierCurveTo(t, e, s, i, r, o);
  }
  clearRect(t, e, s, i) {
    this._context.clearRect(t, e, s, i);
  }
  clip(...t) {
    this._context.clip.apply(this._context, t);
  }
  closePath() {
    this._context.closePath();
  }
  createImageData(t, e) {
    var s = arguments;
    if (s.length === 2)
      return this._context.createImageData(t, e);
    if (s.length === 1)
      return this._context.createImageData(t);
  }
  createLinearGradient(t, e, s, i) {
    return this._context.createLinearGradient(t, e, s, i);
  }
  createPattern(t, e) {
    return this._context.createPattern(t, e);
  }
  createRadialGradient(t, e, s, i, r, o) {
    return this._context.createRadialGradient(t, e, s, i, r, o);
  }
  drawImage(t, e, s, i, r, o, a, c, l) {
    var h = arguments, d = this._context;
    h.length === 3 ? d.drawImage(t, e, s) : h.length === 5 ? d.drawImage(t, e, s, i, r) : h.length === 9 && d.drawImage(t, e, s, i, r, o, a, c, l);
  }
  ellipse(t, e, s, i, r, o, a, c) {
    this._context.ellipse(t, e, s, i, r, o, a, c);
  }
  isPointInPath(t, e, s, i) {
    return s ? this._context.isPointInPath(s, t, e, i) : this._context.isPointInPath(t, e, i);
  }
  fill(...t) {
    this._context.fill.apply(this._context, t);
  }
  fillRect(t, e, s, i) {
    this._context.fillRect(t, e, s, i);
  }
  strokeRect(t, e, s, i) {
    this._context.strokeRect(t, e, s, i);
  }
  fillText(t, e, s, i) {
    i ? this._context.fillText(t, e, s, i) : this._context.fillText(t, e, s);
  }
  measureText(t) {
    return this._context.measureText(t);
  }
  getImageData(t, e, s, i) {
    return this._context.getImageData(t, e, s, i);
  }
  lineTo(t, e) {
    this._context.lineTo(t, e);
  }
  moveTo(t, e) {
    this._context.moveTo(t, e);
  }
  rect(t, e, s, i) {
    this._context.rect(t, e, s, i);
  }
  roundRect(t, e, s, i, r) {
    this._context.roundRect(t, e, s, i, r);
  }
  putImageData(t, e, s) {
    this._context.putImageData(t, e, s);
  }
  quadraticCurveTo(t, e, s, i) {
    this._context.quadraticCurveTo(t, e, s, i);
  }
  restore() {
    this._context.restore();
  }
  rotate(t) {
    this._context.rotate(t);
  }
  save() {
    this._context.save();
  }
  scale(t, e) {
    this._context.scale(t, e);
  }
  setLineDash(t) {
    this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t);
  }
  getLineDash() {
    return this._context.getLineDash();
  }
  setTransform(t, e, s, i, r, o) {
    this._context.setTransform(t, e, s, i, r, o);
  }
  stroke(t) {
    t ? this._context.stroke(t) : this._context.stroke();
  }
  strokeText(t, e, s, i) {
    this._context.strokeText(t, e, s, i);
  }
  transform(t, e, s, i, r, o) {
    this._context.transform(t, e, s, i, r, o);
  }
  translate(t, e) {
    this._context.translate(t, e);
  }
  _enableTrace() {
    var t = this, e = x0.length, s = this.setAttr, i, r, o = function(a) {
      var c = t[a], l;
      t[a] = function() {
        return r = Bw(Array.prototype.slice.call(arguments, 0)), l = c.apply(t, arguments), t._trace({
          method: a,
          args: r
        }), l;
      };
    };
    for (i = 0; i < e; i++)
      o(x0[i]);
    t.setAttr = function() {
      s.apply(t, arguments);
      var a = arguments[0], c = arguments[1];
      (a === "shadowOffsetX" || a === "shadowOffsetY" || a === "shadowBlur") && (c = c / this.canvas.getPixelRatio()), t._trace({
        property: a,
        val: c
      });
    };
  }
  _applyGlobalCompositeOperation(t) {
    const e = t.attrs.globalCompositeOperation;
    var s = !e || e === "source-over";
    s || this.setAttr("globalCompositeOperation", e);
  }
}
Vs.Context = nl;
Yw.forEach(function(n) {
  Object.defineProperty(nl.prototype, n, {
    get() {
      return this._context[n];
    },
    set(t) {
      this._context[n] = t;
    }
  });
});
class qw extends nl {
  constructor(t, { willReadFrequently: e = !1 } = {}) {
    super(t), this._context = t._canvas.getContext("2d", {
      willReadFrequently: e
    });
  }
  _fillColor(t) {
    var e = t.fill();
    this.setAttr("fillStyle", e), t._fillFunc(this);
  }
  _fillPattern(t) {
    this.setAttr("fillStyle", t._getFillPattern()), t._fillFunc(this);
  }
  _fillLinearGradient(t) {
    var e = t._getLinearGradient();
    e && (this.setAttr("fillStyle", e), t._fillFunc(this));
  }
  _fillRadialGradient(t) {
    const e = t._getRadialGradient();
    e && (this.setAttr("fillStyle", e), t._fillFunc(this));
  }
  _fill(t) {
    const e = t.fill(), s = t.getFillPriority();
    if (e && s === "color") {
      this._fillColor(t);
      return;
    }
    const i = t.getFillPatternImage();
    if (i && s === "pattern") {
      this._fillPattern(t);
      return;
    }
    const r = t.getFillLinearGradientColorStops();
    if (r && s === "linear-gradient") {
      this._fillLinearGradient(t);
      return;
    }
    const o = t.getFillRadialGradientColorStops();
    if (o && s === "radial-gradient") {
      this._fillRadialGradient(t);
      return;
    }
    e ? this._fillColor(t) : i ? this._fillPattern(t) : r ? this._fillLinearGradient(t) : o && this._fillRadialGradient(t);
  }
  _strokeLinearGradient(t) {
    const e = t.getStrokeLinearGradientStartPoint(), s = t.getStrokeLinearGradientEndPoint(), i = t.getStrokeLinearGradientColorStops(), r = this.createLinearGradient(e.x, e.y, s.x, s.y);
    if (i) {
      for (var o = 0; o < i.length; o += 2)
        r.addColorStop(i[o], i[o + 1]);
      this.setAttr("strokeStyle", r);
    }
  }
  _stroke(t) {
    var e = t.dash(), s = t.getStrokeScaleEnabled();
    if (t.hasStroke()) {
      if (!s) {
        this.save();
        var i = this.getCanvas().getPixelRatio();
        this.setTransform(i, 0, 0, i, 0, 0);
      }
      this._applyLineCap(t), e && t.dashEnabled() && (this.setLineDash(e), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
      var r = t.getStrokeLinearGradientColorStops();
      r ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), s || this.restore();
    }
  }
  _applyShadow(t) {
    var e, s, i, r = (e = t.getShadowRGBA()) !== null && e !== void 0 ? e : "black", o = (s = t.getShadowBlur()) !== null && s !== void 0 ? s : 5, a = (i = t.getShadowOffset()) !== null && i !== void 0 ? i : {
      x: 0,
      y: 0
    }, c = t.getAbsoluteScale(), l = this.canvas.getPixelRatio(), h = c.x * l, d = c.y * l;
    this.setAttr("shadowColor", r), this.setAttr("shadowBlur", o * Math.min(Math.abs(h), Math.abs(d))), this.setAttr("shadowOffsetX", a.x * h), this.setAttr("shadowOffsetY", a.y * d);
  }
}
Vs.SceneContext = qw;
class Xw extends nl {
  constructor(t) {
    super(t), this._context = t._canvas.getContext("2d", {
      willReadFrequently: !0
    });
  }
  _fill(t) {
    this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore();
  }
  strokeShape(t) {
    t.hasHitStroke() && this._stroke(t);
  }
  _stroke(t) {
    if (t.hasHitStroke()) {
      const r = t.getStrokeScaleEnabled();
      if (!r) {
        this.save();
        var e = this.getCanvas().getPixelRatio();
        this.setTransform(e, 0, 0, e, 0, 0);
      }
      this._applyLineCap(t);
      var s = t.hitStrokeWidth(), i = s === "auto" ? t.strokeWidth() : s;
      this.setAttr("lineWidth", i), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), r || this.restore();
    }
  }
}
Vs.HitContext = Xw;
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.HitCanvas = rs.SceneCanvas = rs.Canvas = void 0;
const uc = Vt, Lm = Vs, Um = ft, Jw = ut, Qw = z;
var Sa;
function tS() {
  if (Sa)
    return Sa;
  var n = uc.Util.createCanvasElement(), t = n.getContext("2d");
  return Sa = function() {
    var e = Um.Konva._global.devicePixelRatio || 1, s = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
    return e / s;
  }(), uc.Util.releaseCanvas(n), Sa;
}
class il {
  constructor(t) {
    this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
    var e = t || {}, s = e.pixelRatio || Um.Konva.pixelRatio || tS();
    this.pixelRatio = s, this._canvas = uc.Util.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
  }
  getContext() {
    return this.context;
  }
  getPixelRatio() {
    return this.pixelRatio;
  }
  setPixelRatio(t) {
    var e = this.pixelRatio;
    this.pixelRatio = t, this.setSize(this.getWidth() / e, this.getHeight() / e);
  }
  setWidth(t) {
    this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + "px";
    var e = this.pixelRatio, s = this.getContext()._context;
    s.scale(e, e);
  }
  setHeight(t) {
    this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + "px";
    var e = this.pixelRatio, s = this.getContext()._context;
    s.scale(e, e);
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setSize(t, e) {
    this.setWidth(t || 0), this.setHeight(e || 0);
  }
  toDataURL(t, e) {
    try {
      return this._canvas.toDataURL(t, e);
    } catch {
      try {
        return this._canvas.toDataURL();
      } catch (i) {
        return uc.Util.error("Unable to get data URL. " + i.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
      }
    }
  }
}
rs.Canvas = il;
Jw.Factory.addGetterSetter(il, "pixelRatio", void 0, (0, Qw.getNumberValidator)());
class eS extends il {
  constructor(t = { width: 0, height: 0, willReadFrequently: !1 }) {
    super(t), this.context = new Lm.SceneContext(this, {
      willReadFrequently: t.willReadFrequently
    }), this.setSize(t.width, t.height);
  }
}
rs.SceneCanvas = eS;
class sS extends il {
  constructor(t = { width: 0, height: 0 }) {
    super(t), this.hitCanvas = !0, this.context = new Lm.HitContext(this), this.setSize(t.width, t.height);
  }
}
rs.HitCanvas = sS;
var rl = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.DD = void 0;
  const t = ft, e = Vt;
  n.DD = {
    get isDragging() {
      var s = !1;
      return n.DD._dragElements.forEach((i) => {
        i.dragStatus === "dragging" && (s = !0);
      }), s;
    },
    justDragged: !1,
    get node() {
      var s;
      return n.DD._dragElements.forEach((i) => {
        s = i.node;
      }), s;
    },
    _dragElements: /* @__PURE__ */ new Map(),
    _drag(s) {
      const i = [];
      n.DD._dragElements.forEach((r, o) => {
        const { node: a } = r, c = a.getStage();
        c.setPointersPositions(s), r.pointerId === void 0 && (r.pointerId = e.Util._getFirstPointerId(s));
        const l = c._changedPointerPositions.find((u) => u.id === r.pointerId);
        if (l) {
          if (r.dragStatus !== "dragging") {
            var h = a.dragDistance(), d = Math.max(Math.abs(l.x - r.startPointerPos.x), Math.abs(l.y - r.startPointerPos.y));
            if (d < h || (a.startDrag({ evt: s }), !a.isDragging()))
              return;
          }
          a._setDragPosition(s, r), i.push(a);
        }
      }), i.forEach((r) => {
        r.fire("dragmove", {
          type: "dragmove",
          target: r,
          evt: s
        }, !0);
      });
    },
    _endDragBefore(s) {
      const i = [];
      n.DD._dragElements.forEach((r) => {
        const { node: o } = r, a = o.getStage();
        if (s && a.setPointersPositions(s), !a._changedPointerPositions.find((h) => h.id === r.pointerId))
          return;
        (r.dragStatus === "dragging" || r.dragStatus === "stopped") && (n.DD.justDragged = !0, t.Konva._mouseListenClick = !1, t.Konva._touchListenClick = !1, t.Konva._pointerListenClick = !1, r.dragStatus = "stopped");
        const l = r.node.getLayer() || r.node instanceof t.Konva.Stage && r.node;
        l && i.indexOf(l) === -1 && i.push(l);
      }), i.forEach((r) => {
        r.draw();
      });
    },
    _endDragAfter(s) {
      n.DD._dragElements.forEach((i, r) => {
        i.dragStatus === "stopped" && i.node.fire("dragend", {
          type: "dragend",
          target: i.node,
          evt: s
        }, !0), i.dragStatus !== "dragging" && n.DD._dragElements.delete(r);
      });
    }
  }, t.Konva.isBrowser && (window.addEventListener("mouseup", n.DD._endDragBefore, !0), window.addEventListener("touchend", n.DD._endDragBefore, !0), window.addEventListener("mousemove", n.DD._drag), window.addEventListener("touchmove", n.DD._drag), window.addEventListener("mouseup", n.DD._endDragAfter, !1), window.addEventListener("touchend", n.DD._endDragAfter, !1));
})(rl);
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.Node = void 0;
const pt = Vt, Qo = ut, Nr = rs, rn = ft, Ge = rl, Yt = z;
var Ba = "absoluteOpacity", Ca = "allEventListeners", Rs = "absoluteTransform", E0 = "absoluteScale", Ln = "canvas", nS = "Change", iS = "children", rS = "konva", $d = "listening", T0 = "mouseenter", A0 = "mouseleave", I0 = "set", O0 = "Shape", Va = " ", D0 = "stage", on = "transform", oS = "Stage", Nd = "visible", aS = [
  "xChange.konva",
  "yChange.konva",
  "scaleXChange.konva",
  "scaleYChange.konva",
  "skewXChange.konva",
  "skewYChange.konva",
  "rotationChange.konva",
  "offsetXChange.konva",
  "offsetYChange.konva",
  "transformsEnabledChange.konva"
].join(Va);
let cS = 1, ot = class Ld {
  constructor(t) {
    this._id = cS++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = /* @__PURE__ */ new Map(), this._attachedDepsListeners = /* @__PURE__ */ new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0;
  }
  hasChildren() {
    return !1;
  }
  _clearCache(t) {
    (t === on || t === Rs) && this._cache.get(t) ? this._cache.get(t).dirty = !0 : t ? this._cache.delete(t) : this._cache.clear();
  }
  _getCache(t, e) {
    var s = this._cache.get(t), i = t === on || t === Rs, r = s === void 0 || i && s.dirty === !0;
    return r && (s = e.call(this), this._cache.set(t, s)), s;
  }
  _calculate(t, e, s) {
    if (!this._attachedDepsListeners.get(t)) {
      const i = e.map((r) => r + "Change.konva").join(Va);
      this.on(i, () => {
        this._clearCache(t);
      }), this._attachedDepsListeners.set(t, !0);
    }
    return this._getCache(t, s);
  }
  _getCanvasCache() {
    return this._cache.get(Ln);
  }
  _clearSelfAndDescendantCache(t) {
    this._clearCache(t), t === Rs && this.fire("absoluteTransformChange");
  }
  clearCache() {
    if (this._cache.has(Ln)) {
      const { scene: t, filter: e, hit: s } = this._cache.get(Ln);
      pt.Util.releaseCanvas(t, e, s), this._cache.delete(Ln);
    }
    return this._clearSelfAndDescendantCache(), this._requestDraw(), this;
  }
  cache(t) {
    var e = t || {}, s = {};
    (e.x === void 0 || e.y === void 0 || e.width === void 0 || e.height === void 0) && (s = this.getClientRect({
      skipTransform: !0,
      relativeTo: this.getParent() || void 0
    }));
    var i = Math.ceil(e.width || s.width), r = Math.ceil(e.height || s.height), o = e.pixelRatio, a = e.x === void 0 ? Math.floor(s.x) : e.x, c = e.y === void 0 ? Math.floor(s.y) : e.y, l = e.offset || 0, h = e.drawBorder || !1, d = e.hitCanvasPixelRatio || 1;
    if (!i || !r) {
      pt.Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
      return;
    }
    const u = Math.abs(Math.round(s.x) - a) > 0.5 ? 1 : 0, f = Math.abs(Math.round(s.y) - c) > 0.5 ? 1 : 0;
    i += l * 2 + u, r += l * 2 + f, a -= l, c -= l;
    var p = new Nr.SceneCanvas({
      pixelRatio: o,
      width: i,
      height: r
    }), m = new Nr.SceneCanvas({
      pixelRatio: o,
      width: 0,
      height: 0,
      willReadFrequently: !0
    }), _ = new Nr.HitCanvas({
      pixelRatio: d,
      width: i,
      height: r
    }), v = p.getContext(), b = _.getContext();
    return _.isCache = !0, p.isCache = !0, this._cache.delete(Ln), this._filterUpToDate = !1, e.imageSmoothingEnabled === !1 && (p.getContext()._context.imageSmoothingEnabled = !1, m.getContext()._context.imageSmoothingEnabled = !1), v.save(), b.save(), v.translate(-a, -c), b.translate(-a, -c), this._isUnderCache = !0, this._clearSelfAndDescendantCache(Ba), this._clearSelfAndDescendantCache(E0), this.drawScene(p, this), this.drawHit(_, this), this._isUnderCache = !1, v.restore(), b.restore(), h && (v.save(), v.beginPath(), v.rect(0, 0, i, r), v.closePath(), v.setAttr("strokeStyle", "red"), v.setAttr("lineWidth", 5), v.stroke(), v.restore()), this._cache.set(Ln, {
      scene: p,
      filter: m,
      hit: _,
      x: a,
      y: c
    }), this._requestDraw(), this;
  }
  isCached() {
    return this._cache.has(Ln);
  }
  getClientRect(t) {
    throw new Error('abstract "getClientRect" method call');
  }
  _transformedRect(t, e) {
    var s = [
      { x: t.x, y: t.y },
      { x: t.x + t.width, y: t.y },
      { x: t.x + t.width, y: t.y + t.height },
      { x: t.x, y: t.y + t.height }
    ], i = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0, c = this.getAbsoluteTransform(e);
    return s.forEach(function(l) {
      var h = c.point(l);
      i === void 0 && (i = o = h.x, r = a = h.y), i = Math.min(i, h.x), r = Math.min(r, h.y), o = Math.max(o, h.x), a = Math.max(a, h.y);
    }), {
      x: i,
      y: r,
      width: o - i,
      height: a - r
    };
  }
  _drawCachedSceneCanvas(t) {
    t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this);
    const e = this._getCanvasCache();
    t.translate(e.x, e.y);
    var s = this._getCachedSceneCanvas(), i = s.pixelRatio;
    t.drawImage(s._canvas, 0, 0, s.width / i, s.height / i), t.restore();
  }
  _drawCachedHitCanvas(t) {
    var e = this._getCanvasCache(), s = e.hit;
    t.save(), t.translate(e.x, e.y), t.drawImage(s._canvas, 0, 0, s.width / s.pixelRatio, s.height / s.pixelRatio), t.restore();
  }
  _getCachedSceneCanvas() {
    var t = this.filters(), e = this._getCanvasCache(), s = e.scene, i = e.filter, r = i.getContext(), o, a, c, l;
    if (t) {
      if (!this._filterUpToDate) {
        var h = s.pixelRatio;
        i.setSize(s.width / s.pixelRatio, s.height / s.pixelRatio);
        try {
          for (o = t.length, r.clear(), r.drawImage(s._canvas, 0, 0, s.getWidth() / h, s.getHeight() / h), a = r.getImageData(0, 0, i.getWidth(), i.getHeight()), c = 0; c < o; c++) {
            if (l = t[c], typeof l != "function") {
              pt.Util.error("Filter should be type of function, but got " + typeof l + " instead. Please check correct filters");
              continue;
            }
            l.call(this, a), r.putImageData(a, 0, 0);
          }
        } catch (d) {
          pt.Util.error("Unable to apply filter. " + d.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
        }
        this._filterUpToDate = !0;
      }
      return i;
    }
    return s;
  }
  on(t, e) {
    if (this._cache && this._cache.delete(Ca), arguments.length === 3)
      return this._delegate.apply(this, arguments);
    var s = t.split(Va), i = s.length, r, o, a, c, l;
    for (r = 0; r < i; r++)
      o = s[r], a = o.split("."), c = a[0], l = a[1] || "", this.eventListeners[c] || (this.eventListeners[c] = []), this.eventListeners[c].push({
        name: l,
        handler: e
      });
    return this;
  }
  off(t, e) {
    var s = (t || "").split(Va), i = s.length, r, o, a, c, l, h;
    if (this._cache && this._cache.delete(Ca), !t)
      for (o in this.eventListeners)
        this._off(o);
    for (r = 0; r < i; r++)
      if (a = s[r], c = a.split("."), l = c[0], h = c[1], l)
        this.eventListeners[l] && this._off(l, h, e);
      else
        for (o in this.eventListeners)
          this._off(o, h, e);
    return this;
  }
  dispatchEvent(t) {
    var e = {
      target: this,
      type: t.type,
      evt: t
    };
    return this.fire(t.type, e), this;
  }
  addEventListener(t, e) {
    return this.on(t, function(s) {
      e.call(this, s.evt);
    }), this;
  }
  removeEventListener(t) {
    return this.off(t), this;
  }
  _delegate(t, e, s) {
    var i = this;
    this.on(t, function(r) {
      for (var o = r.target.findAncestors(e, !0, i), a = 0; a < o.length; a++)
        r = pt.Util.cloneObject(r), r.currentTarget = o[a], s.call(o[a], r);
    });
  }
  remove() {
    return this.isDragging() && this.stopDrag(), Ge.DD._dragElements.delete(this._id), this._remove(), this;
  }
  _clearCaches() {
    this._clearSelfAndDescendantCache(Rs), this._clearSelfAndDescendantCache(Ba), this._clearSelfAndDescendantCache(E0), this._clearSelfAndDescendantCache(D0), this._clearSelfAndDescendantCache(Nd), this._clearSelfAndDescendantCache($d);
  }
  _remove() {
    this._clearCaches();
    var t = this.getParent();
    t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null);
  }
  destroy() {
    return this.remove(), this.clearCache(), this;
  }
  getAttr(t) {
    var e = "get" + pt.Util._capitalize(t);
    return pt.Util._isFunction(this[e]) ? this[e]() : this.attrs[t];
  }
  getAncestors() {
    for (var t = this.getParent(), e = []; t; )
      e.push(t), t = t.getParent();
    return e;
  }
  getAttrs() {
    return this.attrs || {};
  }
  setAttrs(t) {
    return this._batchTransformChanges(() => {
      var e, s;
      if (!t)
        return this;
      for (e in t)
        e !== iS && (s = I0 + pt.Util._capitalize(e), pt.Util._isFunction(this[s]) ? this[s](t[e]) : this._setAttr(e, t[e]));
    }), this;
  }
  isListening() {
    return this._getCache($d, this._isListening);
  }
  _isListening(t) {
    if (!this.listening())
      return !1;
    const s = this.getParent();
    return s && s !== t && this !== t ? s._isListening(t) : !0;
  }
  isVisible() {
    return this._getCache(Nd, this._isVisible);
  }
  _isVisible(t) {
    if (!this.visible())
      return !1;
    const s = this.getParent();
    return s && s !== t && this !== t ? s._isVisible(t) : !0;
  }
  shouldDrawHit(t, e = !1) {
    if (t)
      return this._isVisible(t) && this._isListening(t);
    var s = this.getLayer(), i = !1;
    Ge.DD._dragElements.forEach((o) => {
      o.dragStatus === "dragging" && (o.node.nodeType === "Stage" || o.node.getLayer() === s) && (i = !0);
    });
    var r = !e && !rn.Konva.hitOnDragEnabled && (i || rn.Konva.isTransforming());
    return this.isListening() && this.isVisible() && !r;
  }
  show() {
    return this.visible(!0), this;
  }
  hide() {
    return this.visible(!1), this;
  }
  getZIndex() {
    return this.index || 0;
  }
  getAbsoluteZIndex() {
    var t = this.getDepth(), e = this, s = 0, i, r, o, a;
    function c(h) {
      for (i = [], r = h.length, o = 0; o < r; o++)
        a = h[o], s++, a.nodeType !== O0 && (i = i.concat(a.getChildren().slice())), a._id === e._id && (o = r);
      i.length > 0 && i[0].getDepth() <= t && c(i);
    }
    const l = this.getStage();
    return e.nodeType !== oS && l && c(l.getChildren()), s;
  }
  getDepth() {
    for (var t = 0, e = this.parent; e; )
      t++, e = e.parent;
    return t;
  }
  _batchTransformChanges(t) {
    this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(on), this._clearSelfAndDescendantCache(Rs)), this._needClearTransformCache = !1;
  }
  setPosition(t) {
    return this._batchTransformChanges(() => {
      this.x(t.x), this.y(t.y);
    }), this;
  }
  getPosition() {
    return {
      x: this.x(),
      y: this.y()
    };
  }
  getRelativePointerPosition() {
    const t = this.getStage();
    if (!t)
      return null;
    var e = t.getPointerPosition();
    if (!e)
      return null;
    var s = this.getAbsoluteTransform().copy();
    return s.invert(), s.point(e);
  }
  getAbsolutePosition(t) {
    let e = !1, s = this.parent;
    for (; s; ) {
      if (s.isCached()) {
        e = !0;
        break;
      }
      s = s.parent;
    }
    e && !t && (t = !0);
    var i = this.getAbsoluteTransform(t).getMatrix(), r = new pt.Transform(), o = this.offset();
    return r.m = i.slice(), r.translate(o.x, o.y), r.getTranslation();
  }
  setAbsolutePosition(t) {
    const { x: e, y: s, ...i } = this._clearTransform();
    this.attrs.x = e, this.attrs.y = s, this._clearCache(on);
    var r = this._getAbsoluteTransform().copy();
    return r.invert(), r.translate(t.x, t.y), t = {
      x: this.attrs.x + r.getTranslation().x,
      y: this.attrs.y + r.getTranslation().y
    }, this._setTransform(i), this.setPosition({ x: t.x, y: t.y }), this._clearCache(on), this._clearSelfAndDescendantCache(Rs), this;
  }
  _setTransform(t) {
    var e;
    for (e in t)
      this.attrs[e] = t[e];
  }
  _clearTransform() {
    var t = {
      x: this.x(),
      y: this.y(),
      rotation: this.rotation(),
      scaleX: this.scaleX(),
      scaleY: this.scaleY(),
      offsetX: this.offsetX(),
      offsetY: this.offsetY(),
      skewX: this.skewX(),
      skewY: this.skewY()
    };
    return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t;
  }
  move(t) {
    var e = t.x, s = t.y, i = this.x(), r = this.y();
    return e !== void 0 && (i += e), s !== void 0 && (r += s), this.setPosition({ x: i, y: r }), this;
  }
  _eachAncestorReverse(t, e) {
    var s = [], i = this.getParent(), r, o;
    if (!(e && e._id === this._id)) {
      for (s.unshift(this); i && (!e || i._id !== e._id); )
        s.unshift(i), i = i.parent;
      for (r = s.length, o = 0; o < r; o++)
        t(s[o]);
    }
  }
  rotate(t) {
    return this.rotation(this.rotation() + t), this;
  }
  moveToTop() {
    if (!this.parent)
      return pt.Util.warn("Node has no parent. moveToTop function is ignored."), !1;
    var t = this.index, e = this.parent.getChildren().length;
    return t < e - 1 ? (this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1;
  }
  moveUp() {
    if (!this.parent)
      return pt.Util.warn("Node has no parent. moveUp function is ignored."), !1;
    var t = this.index, e = this.parent.getChildren().length;
    return t < e - 1 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
  }
  moveDown() {
    if (!this.parent)
      return pt.Util.warn("Node has no parent. moveDown function is ignored."), !1;
    var t = this.index;
    return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
  }
  moveToBottom() {
    if (!this.parent)
      return pt.Util.warn("Node has no parent. moveToBottom function is ignored."), !1;
    var t = this.index;
    return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1;
  }
  setZIndex(t) {
    if (!this.parent)
      return pt.Util.warn("Node has no parent. zIndex parameter is ignored."), this;
    (t < 0 || t >= this.parent.children.length) && pt.Util.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
    var e = this.index;
    return this.parent.children.splice(e, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this;
  }
  getAbsoluteOpacity() {
    return this._getCache(Ba, this._getAbsoluteOpacity);
  }
  _getAbsoluteOpacity() {
    var t = this.opacity(), e = this.getParent();
    return e && !e._isUnderCache && (t *= e.getAbsoluteOpacity()), t;
  }
  moveTo(t) {
    return this.getParent() !== t && (this._remove(), t.add(this)), this;
  }
  toObject() {
    var t = this.getAttrs(), e, s, i, r, o;
    const a = {
      attrs: {},
      className: this.getClassName()
    };
    for (e in t)
      s = t[e], o = pt.Util.isObject(s) && !pt.Util._isPlainObject(s) && !pt.Util._isArray(s), !o && (i = typeof this[e] == "function" && this[e], delete t[e], r = i ? i.call(this) : null, t[e] = s, r !== s && (a.attrs[e] = s));
    return pt.Util._prepareToStringify(a);
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  getParent() {
    return this.parent;
  }
  findAncestors(t, e, s) {
    var i = [];
    e && this._isMatch(t) && i.push(this);
    for (var r = this.parent; r; ) {
      if (r === s)
        return i;
      r._isMatch(t) && i.push(r), r = r.parent;
    }
    return i;
  }
  isAncestorOf(t) {
    return !1;
  }
  findAncestor(t, e, s) {
    return this.findAncestors(t, e, s)[0];
  }
  _isMatch(t) {
    if (!t)
      return !1;
    if (typeof t == "function")
      return t(this);
    var e = t.replace(/ /g, "").split(","), s = e.length, i, r;
    for (i = 0; i < s; i++)
      if (r = e[i], pt.Util.isValidSelector(r) || (pt.Util.warn('Selector "' + r + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), pt.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), pt.Util.warn("Konva is awesome, right?")), r.charAt(0) === "#") {
        if (this.id() === r.slice(1))
          return !0;
      } else if (r.charAt(0) === ".") {
        if (this.hasName(r.slice(1)))
          return !0;
      } else if (this.className === r || this.nodeType === r)
        return !0;
    return !1;
  }
  getLayer() {
    var t = this.getParent();
    return t ? t.getLayer() : null;
  }
  getStage() {
    return this._getCache(D0, this._getStage);
  }
  _getStage() {
    var t = this.getParent();
    return t ? t.getStage() : null;
  }
  fire(t, e = {}, s) {
    return e.target = e.target || this, s ? this._fireAndBubble(t, e) : this._fire(t, e), this;
  }
  getAbsoluteTransform(t) {
    return t ? this._getAbsoluteTransform(t) : this._getCache(Rs, this._getAbsoluteTransform);
  }
  _getAbsoluteTransform(t) {
    var e;
    if (t)
      return e = new pt.Transform(), this._eachAncestorReverse(function(i) {
        var r = i.transformsEnabled();
        r === "all" ? e.multiply(i.getTransform()) : r === "position" && e.translate(i.x() - i.offsetX(), i.y() - i.offsetY());
      }, t), e;
    e = this._cache.get(Rs) || new pt.Transform(), this.parent ? this.parent.getAbsoluteTransform().copyInto(e) : e.reset();
    var s = this.transformsEnabled();
    if (s === "all")
      e.multiply(this.getTransform());
    else if (s === "position") {
      const i = this.attrs.x || 0, r = this.attrs.y || 0, o = this.attrs.offsetX || 0, a = this.attrs.offsetY || 0;
      e.translate(i - o, r - a);
    }
    return e.dirty = !1, e;
  }
  getAbsoluteScale(t) {
    for (var e = this; e; )
      e._isUnderCache && (t = e), e = e.getParent();
    const i = this.getAbsoluteTransform(t).decompose();
    return {
      x: i.scaleX,
      y: i.scaleY
    };
  }
  getAbsoluteRotation() {
    return this.getAbsoluteTransform().decompose().rotation;
  }
  getTransform() {
    return this._getCache(on, this._getTransform);
  }
  _getTransform() {
    var t, e, s = this._cache.get(on) || new pt.Transform();
    s.reset();
    var i = this.x(), r = this.y(), o = rn.Konva.getAngle(this.rotation()), a = (t = this.attrs.scaleX) !== null && t !== void 0 ? t : 1, c = (e = this.attrs.scaleY) !== null && e !== void 0 ? e : 1, l = this.attrs.skewX || 0, h = this.attrs.skewY || 0, d = this.attrs.offsetX || 0, u = this.attrs.offsetY || 0;
    return (i !== 0 || r !== 0) && s.translate(i, r), o !== 0 && s.rotate(o), (l !== 0 || h !== 0) && s.skew(l, h), (a !== 1 || c !== 1) && s.scale(a, c), (d !== 0 || u !== 0) && s.translate(-1 * d, -1 * u), s.dirty = !1, s;
  }
  clone(t) {
    var e = pt.Util.cloneObject(this.attrs), s, i, r, o, a;
    for (s in t)
      e[s] = t[s];
    var c = new this.constructor(e);
    for (s in this.eventListeners)
      for (i = this.eventListeners[s], r = i.length, o = 0; o < r; o++)
        a = i[o], a.name.indexOf(rS) < 0 && (c.eventListeners[s] || (c.eventListeners[s] = []), c.eventListeners[s].push(a));
    return c;
  }
  _toKonvaCanvas(t) {
    t = t || {};
    var e = this.getClientRect(), s = this.getStage(), i = t.x !== void 0 ? t.x : Math.floor(e.x), r = t.y !== void 0 ? t.y : Math.floor(e.y), o = t.pixelRatio || 1, a = new Nr.SceneCanvas({
      width: t.width || Math.ceil(e.width) || (s ? s.width() : 0),
      height: t.height || Math.ceil(e.height) || (s ? s.height() : 0),
      pixelRatio: o
    }), c = a.getContext();
    const l = new Nr.SceneCanvas({
      width: a.width / a.pixelRatio + Math.abs(i),
      height: a.height / a.pixelRatio + Math.abs(r),
      pixelRatio: a.pixelRatio
    });
    return t.imageSmoothingEnabled === !1 && (c._context.imageSmoothingEnabled = !1), c.save(), (i || r) && c.translate(-1 * i, -1 * r), this.drawScene(a, void 0, l), c.restore(), a;
  }
  toCanvas(t) {
    return this._toKonvaCanvas(t)._canvas;
  }
  toDataURL(t) {
    t = t || {};
    var e = t.mimeType || null, s = t.quality || null, i = this._toKonvaCanvas(t).toDataURL(e, s);
    return t.callback && t.callback(i), i;
  }
  toImage(t) {
    return new Promise((e, s) => {
      try {
        const i = t == null ? void 0 : t.callback;
        i && delete t.callback, pt.Util._urlToImage(this.toDataURL(t), function(r) {
          e(r), i == null || i(r);
        });
      } catch (i) {
        s(i);
      }
    });
  }
  toBlob(t) {
    return new Promise((e, s) => {
      try {
        const i = t == null ? void 0 : t.callback;
        i && delete t.callback, this.toCanvas(t).toBlob((r) => {
          e(r), i == null || i(r);
        }, t == null ? void 0 : t.mimeType, t == null ? void 0 : t.quality);
      } catch (i) {
        s(i);
      }
    });
  }
  setSize(t) {
    return this.width(t.width), this.height(t.height), this;
  }
  getSize() {
    return {
      width: this.width(),
      height: this.height()
    };
  }
  getClassName() {
    return this.className || this.nodeType;
  }
  getType() {
    return this.nodeType;
  }
  getDragDistance() {
    return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : rn.Konva.dragDistance;
  }
  _off(t, e, s) {
    var i = this.eventListeners[t], r, o, a;
    for (r = 0; r < i.length; r++)
      if (o = i[r].name, a = i[r].handler, (o !== "konva" || e === "konva") && (!e || o === e) && (!s || s === a)) {
        if (i.splice(r, 1), i.length === 0) {
          delete this.eventListeners[t];
          break;
        }
        r--;
      }
  }
  _fireChangeEvent(t, e, s) {
    this._fire(t + nS, {
      oldVal: e,
      newVal: s
    });
  }
  addName(t) {
    if (!this.hasName(t)) {
      var e = this.name(), s = e ? e + " " + t : t;
      this.name(s);
    }
    return this;
  }
  hasName(t) {
    if (!t)
      return !1;
    const e = this.name();
    if (!e)
      return !1;
    var s = (e || "").split(/\s/g);
    return s.indexOf(t) !== -1;
  }
  removeName(t) {
    var e = (this.name() || "").split(/\s/g), s = e.indexOf(t);
    return s !== -1 && (e.splice(s, 1), this.name(e.join(" "))), this;
  }
  setAttr(t, e) {
    var s = this[I0 + pt.Util._capitalize(t)];
    return pt.Util._isFunction(s) ? s.call(this, e) : this._setAttr(t, e), this;
  }
  _requestDraw() {
    if (rn.Konva.autoDrawEnabled) {
      const t = this.getLayer() || this.getStage();
      t == null || t.batchDraw();
    }
  }
  _setAttr(t, e) {
    var s = this.attrs[t];
    s === e && !pt.Util.isObject(e) || (e == null ? delete this.attrs[t] : this.attrs[t] = e, this._shouldFireChangeEvents && this._fireChangeEvent(t, s, e), this._requestDraw());
  }
  _setComponentAttr(t, e, s) {
    var i;
    s !== void 0 && (i = this.attrs[t], i || (this.attrs[t] = this.getAttr(t)), this.attrs[t][e] = s, this._fireChangeEvent(t, i, s));
  }
  _fireAndBubble(t, e, s) {
    e && this.nodeType === O0 && (e.target = this);
    var i = (t === T0 || t === A0) && (s && (this === s || this.isAncestorOf && this.isAncestorOf(s)) || this.nodeType === "Stage" && !s);
    if (!i) {
      this._fire(t, e);
      var r = (t === T0 || t === A0) && s && s.isAncestorOf && s.isAncestorOf(this) && !s.isAncestorOf(this.parent);
      (e && !e.cancelBubble || !e) && this.parent && this.parent.isListening() && !r && (s && s.parent ? this._fireAndBubble.call(this.parent, t, e, s) : this._fireAndBubble.call(this.parent, t, e));
    }
  }
  _getProtoListeners(t) {
    var e, s, i;
    const r = (e = this._cache.get(Ca)) !== null && e !== void 0 ? e : {};
    let o = r == null ? void 0 : r[t];
    if (o === void 0) {
      o = [];
      let a = Object.getPrototypeOf(this);
      for (; a; ) {
        const c = (i = (s = a.eventListeners) === null || s === void 0 ? void 0 : s[t]) !== null && i !== void 0 ? i : [];
        o.push(...c), a = Object.getPrototypeOf(a);
      }
      r[t] = o, this._cache.set(Ca, r);
    }
    return o;
  }
  _fire(t, e) {
    e = e || {}, e.currentTarget = this, e.type = t;
    const s = this._getProtoListeners(t);
    if (s)
      for (var i = 0; i < s.length; i++)
        s[i].handler.call(this, e);
    const r = this.eventListeners[t];
    if (r)
      for (var i = 0; i < r.length; i++)
        r[i].handler.call(this, e);
  }
  draw() {
    return this.drawScene(), this.drawHit(), this;
  }
  _createDragElement(t) {
    var e = t ? t.pointerId : void 0, s = this.getStage(), i = this.getAbsolutePosition();
    if (s) {
      var r = s._getPointerById(e) || s._changedPointerPositions[0] || i;
      Ge.DD._dragElements.set(this._id, {
        node: this,
        startPointerPos: r,
        offset: {
          x: r.x - i.x,
          y: r.y - i.y
        },
        dragStatus: "ready",
        pointerId: e
      });
    }
  }
  startDrag(t, e = !0) {
    Ge.DD._dragElements.has(this._id) || this._createDragElement(t);
    const s = Ge.DD._dragElements.get(this._id);
    s.dragStatus = "dragging", this.fire("dragstart", {
      type: "dragstart",
      target: this,
      evt: t && t.evt
    }, e);
  }
  _setDragPosition(t, e) {
    const s = this.getStage()._getPointerById(e.pointerId);
    if (s) {
      var i = {
        x: s.x - e.offset.x,
        y: s.y - e.offset.y
      }, r = this.dragBoundFunc();
      if (r !== void 0) {
        const o = r.call(this, i, t);
        o ? i = o : pt.Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      }
      (!this._lastPos || this._lastPos.x !== i.x || this._lastPos.y !== i.y) && (this.setAbsolutePosition(i), this._requestDraw()), this._lastPos = i;
    }
  }
  stopDrag(t) {
    const e = Ge.DD._dragElements.get(this._id);
    e && (e.dragStatus = "stopped"), Ge.DD._endDragBefore(t), Ge.DD._endDragAfter(t);
  }
  setDraggable(t) {
    this._setAttr("draggable", t), this._dragChange();
  }
  isDragging() {
    const t = Ge.DD._dragElements.get(this._id);
    return t ? t.dragStatus === "dragging" : !1;
  }
  _listenDrag() {
    this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(t) {
      var e = t.evt.button !== void 0, s = !e || rn.Konva.dragButtons.indexOf(t.evt.button) >= 0;
      if (s && !this.isDragging()) {
        var i = !1;
        Ge.DD._dragElements.forEach((r) => {
          this.isAncestorOf(r.node) && (i = !0);
        }), i || this._createDragElement(t);
      }
    });
  }
  _dragChange() {
    if (this.attrs.draggable)
      this._listenDrag();
    else {
      this._dragCleanup();
      var t = this.getStage();
      if (!t)
        return;
      const e = Ge.DD._dragElements.get(this._id), s = e && e.dragStatus === "dragging", i = e && e.dragStatus === "ready";
      s ? this.stopDrag() : i && Ge.DD._dragElements.delete(this._id);
    }
  }
  _dragCleanup() {
    this.off("mousedown.konva"), this.off("touchstart.konva");
  }
  isClientRectOnScreen(t = { x: 0, y: 0 }) {
    const e = this.getStage();
    if (!e)
      return !1;
    const s = {
      x: -t.x,
      y: -t.y,
      width: e.width() + 2 * t.x,
      height: e.height() + 2 * t.y
    };
    return pt.Util.haveIntersection(s, this.getClientRect());
  }
  static create(t, e) {
    return pt.Util._isString(t) && (t = JSON.parse(t)), this._createNode(t, e);
  }
  static _createNode(t, e) {
    var s = Ld.prototype.getClassName.call(t), i = t.children, r, o, a;
    e && (t.attrs.container = e), rn.Konva[s] || (pt.Util.warn('Can not find a node with class name "' + s + '". Fallback to "Shape".'), s = "Shape");
    const c = rn.Konva[s];
    if (r = new c(t.attrs), i)
      for (o = i.length, a = 0; a < o; a++)
        r.add(Ld._createNode(i[a]));
    return r;
  }
};
Nt.Node = ot;
ot.prototype.nodeType = "Node";
ot.prototype._attrsAffectingSize = [];
ot.prototype.eventListeners = {};
ot.prototype.on.call(ot.prototype, aS, function() {
  if (this._batchingTransformChange) {
    this._needClearTransformCache = !0;
    return;
  }
  this._clearCache(on), this._clearSelfAndDescendantCache(Rs);
});
ot.prototype.on.call(ot.prototype, "visibleChange.konva", function() {
  this._clearSelfAndDescendantCache(Nd);
});
ot.prototype.on.call(ot.prototype, "listeningChange.konva", function() {
  this._clearSelfAndDescendantCache($d);
});
ot.prototype.on.call(ot.prototype, "opacityChange.konva", function() {
  this._clearSelfAndDescendantCache(Ba);
});
const Ot = Qo.Factory.addGetterSetter;
Ot(ot, "zIndex");
Ot(ot, "absolutePosition");
Ot(ot, "position");
Ot(ot, "x", 0, (0, Yt.getNumberValidator)());
Ot(ot, "y", 0, (0, Yt.getNumberValidator)());
Ot(ot, "globalCompositeOperation", "source-over", (0, Yt.getStringValidator)());
Ot(ot, "opacity", 1, (0, Yt.getNumberValidator)());
Ot(ot, "name", "", (0, Yt.getStringValidator)());
Ot(ot, "id", "", (0, Yt.getStringValidator)());
Ot(ot, "rotation", 0, (0, Yt.getNumberValidator)());
Qo.Factory.addComponentsGetterSetter(ot, "scale", ["x", "y"]);
Ot(ot, "scaleX", 1, (0, Yt.getNumberValidator)());
Ot(ot, "scaleY", 1, (0, Yt.getNumberValidator)());
Qo.Factory.addComponentsGetterSetter(ot, "skew", ["x", "y"]);
Ot(ot, "skewX", 0, (0, Yt.getNumberValidator)());
Ot(ot, "skewY", 0, (0, Yt.getNumberValidator)());
Qo.Factory.addComponentsGetterSetter(ot, "offset", ["x", "y"]);
Ot(ot, "offsetX", 0, (0, Yt.getNumberValidator)());
Ot(ot, "offsetY", 0, (0, Yt.getNumberValidator)());
Ot(ot, "dragDistance", null, (0, Yt.getNumberValidator)());
Ot(ot, "width", 0, (0, Yt.getNumberValidator)());
Ot(ot, "height", 0, (0, Yt.getNumberValidator)());
Ot(ot, "listening", !0, (0, Yt.getBooleanValidator)());
Ot(ot, "preventDefault", !0, (0, Yt.getBooleanValidator)());
Ot(ot, "filters", null, function(n) {
  return this._filterUpToDate = !1, n;
});
Ot(ot, "visible", !0, (0, Yt.getBooleanValidator)());
Ot(ot, "transformsEnabled", "all", (0, Yt.getStringValidator)());
Ot(ot, "size");
Ot(ot, "dragBoundFunc");
Ot(ot, "draggable", !1, (0, Yt.getBooleanValidator)());
Qo.Factory.backCompat(ot, {
  rotateDeg: "rotate",
  setRotationDeg: "setRotation",
  getRotationDeg: "getRotation"
});
var bi = {};
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.Container = void 0;
const Cr = ut, xh = Nt, ol = z;
class wi extends xh.Node {
  constructor() {
    super(...arguments), this.children = [];
  }
  getChildren(t) {
    if (!t)
      return this.children || [];
    const e = this.children || [];
    var s = [];
    return e.forEach(function(i) {
      t(i) && s.push(i);
    }), s;
  }
  hasChildren() {
    return this.getChildren().length > 0;
  }
  removeChildren() {
    return this.getChildren().forEach((t) => {
      t.parent = null, t.index = 0, t.remove();
    }), this.children = [], this._requestDraw(), this;
  }
  destroyChildren() {
    return this.getChildren().forEach((t) => {
      t.parent = null, t.index = 0, t.destroy();
    }), this.children = [], this._requestDraw(), this;
  }
  add(...t) {
    if (t.length === 0)
      return this;
    if (t.length > 1) {
      for (var e = 0; e < t.length; e++)
        this.add(t[e]);
      return this;
    }
    const s = t[0];
    return s.getParent() ? (s.moveTo(this), this) : (this._validateAdd(s), s.index = this.getChildren().length, s.parent = this, s._clearCaches(), this.getChildren().push(s), this._fire("add", {
      child: s
    }), this._requestDraw(), this);
  }
  destroy() {
    return this.hasChildren() && this.destroyChildren(), super.destroy(), this;
  }
  find(t) {
    return this._generalFind(t, !1);
  }
  findOne(t) {
    var e = this._generalFind(t, !0);
    return e.length > 0 ? e[0] : void 0;
  }
  _generalFind(t, e) {
    var s = [];
    return this._descendants((i) => {
      const r = i._isMatch(t);
      return r && s.push(i), !!(r && e);
    }), s;
  }
  _descendants(t) {
    let e = !1;
    const s = this.getChildren();
    for (const i of s) {
      if (e = t(i), e)
        return !0;
      if (i.hasChildren() && (e = i._descendants(t), e))
        return !0;
    }
    return !1;
  }
  toObject() {
    var t = xh.Node.prototype.toObject.call(this);
    return t.children = [], this.getChildren().forEach((e) => {
      t.children.push(e.toObject());
    }), t;
  }
  isAncestorOf(t) {
    for (var e = t.getParent(); e; ) {
      if (e._id === this._id)
        return !0;
      e = e.getParent();
    }
    return !1;
  }
  clone(t) {
    var e = xh.Node.prototype.clone.call(this, t);
    return this.getChildren().forEach(function(s) {
      e.add(s.clone());
    }), e;
  }
  getAllIntersections(t) {
    var e = [];
    return this.find("Shape").forEach((s) => {
      s.isVisible() && s.intersects(t) && e.push(s);
    }), e;
  }
  _clearSelfAndDescendantCache(t) {
    var e;
    super._clearSelfAndDescendantCache(t), !this.isCached() && ((e = this.children) === null || e === void 0 || e.forEach(function(s) {
      s._clearSelfAndDescendantCache(t);
    }));
  }
  _setChildrenIndices() {
    var t;
    (t = this.children) === null || t === void 0 || t.forEach(function(e, s) {
      e.index = s;
    }), this._requestDraw();
  }
  drawScene(t, e, s) {
    var i = this.getLayer(), r = t || i && i.getCanvas(), o = r && r.getContext(), a = this._getCanvasCache(), c = a && a.scene, l = r && r.isCache;
    if (!this.isVisible() && !l)
      return this;
    if (c) {
      o.save();
      var h = this.getAbsoluteTransform(e).getMatrix();
      o.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this._drawCachedSceneCanvas(o), o.restore();
    } else
      this._drawChildren("drawScene", r, e, s);
    return this;
  }
  drawHit(t, e) {
    if (!this.shouldDrawHit(e))
      return this;
    var s = this.getLayer(), i = t || s && s.hitCanvas, r = i && i.getContext(), o = this._getCanvasCache(), a = o && o.hit;
    if (a) {
      r.save();
      var c = this.getAbsoluteTransform(e).getMatrix();
      r.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this._drawCachedHitCanvas(r), r.restore();
    } else
      this._drawChildren("drawHit", i, e);
    return this;
  }
  _drawChildren(t, e, s, i) {
    var r, o = e && e.getContext(), a = this.clipWidth(), c = this.clipHeight(), l = this.clipFunc(), h = typeof a == "number" && typeof c == "number" || l;
    const d = s === this;
    if (h) {
      o.save();
      var u = this.getAbsoluteTransform(s), f = u.getMatrix();
      o.transform(f[0], f[1], f[2], f[3], f[4], f[5]), o.beginPath();
      let v;
      if (l)
        v = l.call(this, o, this);
      else {
        var p = this.clipX(), m = this.clipY();
        o.rect(p || 0, m || 0, a, c);
      }
      o.clip.apply(o, v), f = u.copy().invert().getMatrix(), o.transform(f[0], f[1], f[2], f[3], f[4], f[5]);
    }
    var _ = !d && this.globalCompositeOperation() !== "source-over" && t === "drawScene";
    _ && (o.save(), o._applyGlobalCompositeOperation(this)), (r = this.children) === null || r === void 0 || r.forEach(function(v) {
      v[t](e, s, i);
    }), _ && o.restore(), h && o.restore();
  }
  getClientRect(t = {}) {
    var e, s = t.skipTransform, i = t.relativeTo, r, o, a, c, l = {
      x: 1 / 0,
      y: 1 / 0,
      width: 0,
      height: 0
    }, h = this;
    (e = this.children) === null || e === void 0 || e.forEach(function(m) {
      if (m.visible()) {
        var _ = m.getClientRect({
          relativeTo: h,
          skipShadow: t.skipShadow,
          skipStroke: t.skipStroke
        });
        _.width === 0 && _.height === 0 || (r === void 0 ? (r = _.x, o = _.y, a = _.x + _.width, c = _.y + _.height) : (r = Math.min(r, _.x), o = Math.min(o, _.y), a = Math.max(a, _.x + _.width), c = Math.max(c, _.y + _.height)));
      }
    });
    for (var d = this.find("Shape"), u = !1, f = 0; f < d.length; f++) {
      var p = d[f];
      if (p._isVisible(this)) {
        u = !0;
        break;
      }
    }
    return u && r !== void 0 ? l = {
      x: r,
      y: o,
      width: a - r,
      height: c - o
    } : l = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, s ? l : this._transformedRect(l, i);
  }
}
bi.Container = wi;
Cr.Factory.addComponentsGetterSetter(wi, "clip", [
  "x",
  "y",
  "width",
  "height"
]);
Cr.Factory.addGetterSetter(wi, "clipX", void 0, (0, ol.getNumberValidator)());
Cr.Factory.addGetterSetter(wi, "clipY", void 0, (0, ol.getNumberValidator)());
Cr.Factory.addGetterSetter(wi, "clipWidth", void 0, (0, ol.getNumberValidator)());
Cr.Factory.addGetterSetter(wi, "clipHeight", void 0, (0, ol.getNumberValidator)());
Cr.Factory.addGetterSetter(wi, "clipFunc");
var Fm = {}, Ue = {};
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.releaseCapture = Ue.setPointerCapture = Ue.hasPointerCapture = Ue.createEvent = Ue.getCapturedShape = void 0;
const lS = ft, Ro = /* @__PURE__ */ new Map(), Bm = lS.Konva._global.PointerEvent !== void 0;
function hS(n) {
  return Ro.get(n);
}
Ue.getCapturedShape = hS;
function nf(n) {
  return {
    evt: n,
    pointerId: n.pointerId
  };
}
Ue.createEvent = nf;
function dS(n, t) {
  return Ro.get(n) === t;
}
Ue.hasPointerCapture = dS;
function uS(n, t) {
  Vm(n), t.getStage() && (Ro.set(n, t), Bm && t._fire("gotpointercapture", nf(new PointerEvent("gotpointercapture"))));
}
Ue.setPointerCapture = uS;
function Vm(n, t) {
  const e = Ro.get(n);
  if (!e)
    return;
  const s = e.getStage();
  s && s.content, Ro.delete(n), Bm && e._fire("lostpointercapture", nf(new PointerEvent("lostpointercapture")));
}
Ue.releaseCapture = Vm;
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Stage = n.stages = void 0;
  const t = Vt, e = ut, s = bi, i = ft, r = rs, o = rl, a = ft, c = Ue;
  var l = "Stage", h = "string", d = "px", u = "mouseout", f = "mouseleave", p = "mouseover", m = "mouseenter", _ = "mousemove", v = "mousedown", b = "mouseup", g = "pointermove", y = "pointerdown", S = "pointerup", w = "pointercancel", k = "lostpointercapture", C = "pointerout", A = "pointerleave", E = "pointerover", I = "pointerenter", P = "contextmenu", M = "touchstart", F = "touchend", V = "touchmove", q = "touchcancel", ht = "wheel", rt = 5, Dt = [
    [m, "_pointerenter"],
    [v, "_pointerdown"],
    [_, "_pointermove"],
    [b, "_pointerup"],
    [f, "_pointerleave"],
    [M, "_pointerdown"],
    [V, "_pointermove"],
    [F, "_pointerup"],
    [q, "_pointercancel"],
    [p, "_pointerover"],
    [ht, "_wheel"],
    [P, "_contextmenu"],
    [y, "_pointerdown"],
    [g, "_pointermove"],
    [S, "_pointerup"],
    [w, "_pointercancel"],
    [k, "_lostpointercapture"]
  ];
  const K = {
    mouse: {
      [C]: u,
      [A]: f,
      [E]: p,
      [I]: m,
      [g]: _,
      [y]: v,
      [S]: b,
      [w]: "mousecancel",
      pointerclick: "click",
      pointerdblclick: "dblclick"
    },
    touch: {
      [C]: "touchout",
      [A]: "touchleave",
      [E]: "touchover",
      [I]: "touchenter",
      [g]: V,
      [y]: M,
      [S]: F,
      [w]: q,
      pointerclick: "tap",
      pointerdblclick: "dbltap"
    },
    pointer: {
      [C]: C,
      [A]: A,
      [E]: E,
      [I]: I,
      [g]: g,
      [y]: y,
      [S]: S,
      [w]: w,
      pointerclick: "pointerclick",
      pointerdblclick: "pointerdblclick"
    }
  }, X = (Lt) => Lt.indexOf("pointer") >= 0 ? "pointer" : Lt.indexOf("touch") >= 0 ? "touch" : "mouse", vt = (Lt) => {
    const T = X(Lt);
    if (T === "pointer")
      return i.Konva.pointerEventsEnabled && K.pointer;
    if (T === "touch")
      return K.touch;
    if (T === "mouse")
      return K.mouse;
  };
  function Tt(Lt = {}) {
    return (Lt.clipFunc || Lt.clipWidth || Lt.clipHeight) && t.Util.warn("Stage does not support clipping. Please use clip for Layers or Groups."), Lt;
  }
  const Ct = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);";
  n.stages = [];
  class Ve extends s.Container {
    constructor(T) {
      super(Tt(T)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), n.stages.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
        Tt(this.attrs);
      }), this._checkVisibility();
    }
    _validateAdd(T) {
      const $ = T.getType() === "Layer", W = T.getType() === "FastLayer";
      $ || W || t.Util.throw("You may only add layers to the stage.");
    }
    _checkVisibility() {
      if (!this.content)
        return;
      const T = this.visible() ? "" : "none";
      this.content.style.display = T;
    }
    setContainer(T) {
      if (typeof T === h) {
        if (T.charAt(0) === ".") {
          var $ = T.slice(1);
          T = document.getElementsByClassName($)[0];
        } else {
          var W;
          T.charAt(0) !== "#" ? W = T : W = T.slice(1), T = document.getElementById(W);
        }
        if (!T)
          throw "Can not find container in document with id " + W;
      }
      return this._setAttr("container", T), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), T.appendChild(this.content)), this;
    }
    shouldDrawHit() {
      return !0;
    }
    clear() {
      var T = this.children, $ = T.length, W;
      for (W = 0; W < $; W++)
        T[W].clear();
      return this;
    }
    clone(T) {
      return T || (T = {}), T.container = typeof document < "u" && document.createElement("div"), s.Container.prototype.clone.call(this, T);
    }
    destroy() {
      super.destroy();
      var T = this.content;
      T && t.Util._isInDocument(T) && this.container().removeChild(T);
      var $ = n.stages.indexOf(this);
      return $ > -1 && n.stages.splice($, 1), t.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this;
    }
    getPointerPosition() {
      const T = this._pointerPositions[0] || this._changedPointerPositions[0];
      return T ? {
        x: T.x,
        y: T.y
      } : (t.Util.warn(Ct), null);
    }
    _getPointerById(T) {
      return this._pointerPositions.find(($) => $.id === T);
    }
    getPointersPositions() {
      return this._pointerPositions;
    }
    getStage() {
      return this;
    }
    getContent() {
      return this.content;
    }
    _toKonvaCanvas(T) {
      T = T || {}, T.x = T.x || 0, T.y = T.y || 0, T.width = T.width || this.width(), T.height = T.height || this.height();
      var $ = new r.SceneCanvas({
        width: T.width,
        height: T.height,
        pixelRatio: T.pixelRatio || 1
      }), W = $.getContext()._context, Pt = this.children;
      return (T.x || T.y) && W.translate(-1 * T.x, -1 * T.y), Pt.forEach(function(St) {
        if (St.isVisible()) {
          var _t = St._toKonvaCanvas(T);
          W.drawImage(_t._canvas, T.x, T.y, _t.getWidth() / _t.getPixelRatio(), _t.getHeight() / _t.getPixelRatio());
        }
      }), $;
    }
    getIntersection(T) {
      if (!T)
        return null;
      var $ = this.children, W = $.length, Pt = W - 1, St;
      for (St = Pt; St >= 0; St--) {
        const _t = $[St].getIntersection(T);
        if (_t)
          return _t;
      }
      return null;
    }
    _resizeDOM() {
      var T = this.width(), $ = this.height();
      this.content && (this.content.style.width = T + d, this.content.style.height = $ + d), this.bufferCanvas.setSize(T, $), this.bufferHitCanvas.setSize(T, $), this.children.forEach((W) => {
        W.setSize({ width: T, height: $ }), W.draw();
      });
    }
    add(T, ...$) {
      if (arguments.length > 1) {
        for (var W = 0; W < arguments.length; W++)
          this.add(arguments[W]);
        return this;
      }
      super.add(T);
      var Pt = this.children.length;
      return Pt > rt && t.Util.warn("The stage has " + Pt + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), T.setSize({ width: this.width(), height: this.height() }), T.draw(), i.Konva.isBrowser && this.content.appendChild(T.canvas._canvas), this;
    }
    getParent() {
      return null;
    }
    getLayer() {
      return null;
    }
    hasPointerCapture(T) {
      return c.hasPointerCapture(T, this);
    }
    setPointerCapture(T) {
      c.setPointerCapture(T, this);
    }
    releaseCapture(T) {
      c.releaseCapture(T, this);
    }
    getLayers() {
      return this.children;
    }
    _bindContentEvents() {
      i.Konva.isBrowser && Dt.forEach(([T, $]) => {
        this.content.addEventListener(T, (W) => {
          this[$](W);
        }, { passive: !1 });
      });
    }
    _pointerenter(T) {
      this.setPointersPositions(T);
      const $ = vt(T.type);
      $ && this._fire($.pointerenter, {
        evt: T,
        target: this,
        currentTarget: this
      });
    }
    _pointerover(T) {
      this.setPointersPositions(T);
      const $ = vt(T.type);
      $ && this._fire($.pointerover, {
        evt: T,
        target: this,
        currentTarget: this
      });
    }
    _getTargetShape(T) {
      let $ = this[T + "targetShape"];
      return $ && !$.getStage() && ($ = null), $;
    }
    _pointerleave(T) {
      const $ = vt(T.type), W = X(T.type);
      if ($) {
        this.setPointersPositions(T);
        var Pt = this._getTargetShape(W), St = !(i.Konva.isDragging() || i.Konva.isTransforming()) || i.Konva.hitOnDragEnabled;
        Pt && St ? (Pt._fireAndBubble($.pointerout, { evt: T }), Pt._fireAndBubble($.pointerleave, { evt: T }), this._fire($.pointerleave, {
          evt: T,
          target: this,
          currentTarget: this
        }), this[W + "targetShape"] = null) : St && (this._fire($.pointerleave, {
          evt: T,
          target: this,
          currentTarget: this
        }), this._fire($.pointerout, {
          evt: T,
          target: this,
          currentTarget: this
        })), this.pointerPos = null, this._pointerPositions = [];
      }
    }
    _pointerdown(T) {
      const $ = vt(T.type), W = X(T.type);
      if ($) {
        this.setPointersPositions(T);
        var Pt = !1;
        this._changedPointerPositions.forEach((St) => {
          var _t = this.getIntersection(St);
          if (o.DD.justDragged = !1, i.Konva["_" + W + "ListenClick"] = !0, !_t || !_t.isListening())
            return;
          i.Konva.capturePointerEventsEnabled && _t.setPointerCapture(St.id), this[W + "ClickStartShape"] = _t, _t._fireAndBubble($.pointerdown, {
            evt: T,
            pointerId: St.id
          }), Pt = !0;
          const Oe = T.type.indexOf("touch") >= 0;
          _t.preventDefault() && T.cancelable && Oe && T.preventDefault();
        }), Pt || this._fire($.pointerdown, {
          evt: T,
          target: this,
          currentTarget: this,
          pointerId: this._pointerPositions[0].id
        });
      }
    }
    _pointermove(T) {
      const $ = vt(T.type), W = X(T.type);
      if (!$)
        return;
      i.Konva.isDragging() && o.DD.node.preventDefault() && T.cancelable && T.preventDefault(), this.setPointersPositions(T);
      var Pt = !(i.Konva.isDragging() || i.Konva.isTransforming()) || i.Konva.hitOnDragEnabled;
      if (!Pt)
        return;
      var St = {};
      let _t = !1;
      var Oe = this._getTargetShape(W);
      this._changedPointerPositions.forEach((fs) => {
        const At = c.getCapturedShape(fs.id) || this.getIntersection(fs), As = fs.id, Ce = { evt: T, pointerId: As };
        var Je = Oe !== At;
        if (Je && Oe && (Oe._fireAndBubble($.pointerout, { ...Ce }, At), Oe._fireAndBubble($.pointerleave, { ...Ce }, At)), At) {
          if (St[At._id])
            return;
          St[At._id] = !0;
        }
        At && At.isListening() ? (_t = !0, Je && (At._fireAndBubble($.pointerover, { ...Ce }, Oe), At._fireAndBubble($.pointerenter, { ...Ce }, Oe), this[W + "targetShape"] = At), At._fireAndBubble($.pointermove, { ...Ce })) : Oe && (this._fire($.pointerover, {
          evt: T,
          target: this,
          currentTarget: this,
          pointerId: As
        }), this[W + "targetShape"] = null);
      }), _t || this._fire($.pointermove, {
        evt: T,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      });
    }
    _pointerup(T) {
      const $ = vt(T.type), W = X(T.type);
      if (!$)
        return;
      this.setPointersPositions(T);
      const Pt = this[W + "ClickStartShape"], St = this[W + "ClickEndShape"];
      var _t = {};
      let Oe = !1;
      this._changedPointerPositions.forEach((fs) => {
        const At = c.getCapturedShape(fs.id) || this.getIntersection(fs);
        if (At) {
          if (At.releaseCapture(fs.id), _t[At._id])
            return;
          _t[At._id] = !0;
        }
        const As = fs.id, Ce = { evt: T, pointerId: As };
        let Je = !1;
        i.Konva["_" + W + "InDblClickWindow"] ? (Je = !0, clearTimeout(this[W + "DblTimeout"])) : o.DD.justDragged || (i.Konva["_" + W + "InDblClickWindow"] = !0, clearTimeout(this[W + "DblTimeout"])), this[W + "DblTimeout"] = setTimeout(function() {
          i.Konva["_" + W + "InDblClickWindow"] = !1;
        }, i.Konva.dblClickWindow), At && At.isListening() ? (Oe = !0, this[W + "ClickEndShape"] = At, At._fireAndBubble($.pointerup, { ...Ce }), i.Konva["_" + W + "ListenClick"] && Pt && Pt === At && (At._fireAndBubble($.pointerclick, { ...Ce }), Je && St && St === At && At._fireAndBubble($.pointerdblclick, { ...Ce }))) : (this[W + "ClickEndShape"] = null, i.Konva["_" + W + "ListenClick"] && this._fire($.pointerclick, {
          evt: T,
          target: this,
          currentTarget: this,
          pointerId: As
        }), Je && this._fire($.pointerdblclick, {
          evt: T,
          target: this,
          currentTarget: this,
          pointerId: As
        }));
      }), Oe || this._fire($.pointerup, {
        evt: T,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      }), i.Konva["_" + W + "ListenClick"] = !1, T.cancelable && W !== "touch" && T.preventDefault();
    }
    _contextmenu(T) {
      this.setPointersPositions(T);
      var $ = this.getIntersection(this.getPointerPosition());
      $ && $.isListening() ? $._fireAndBubble(P, { evt: T }) : this._fire(P, {
        evt: T,
        target: this,
        currentTarget: this
      });
    }
    _wheel(T) {
      this.setPointersPositions(T);
      var $ = this.getIntersection(this.getPointerPosition());
      $ && $.isListening() ? $._fireAndBubble(ht, { evt: T }) : this._fire(ht, {
        evt: T,
        target: this,
        currentTarget: this
      });
    }
    _pointercancel(T) {
      this.setPointersPositions(T);
      const $ = c.getCapturedShape(T.pointerId) || this.getIntersection(this.getPointerPosition());
      $ && $._fireAndBubble(S, c.createEvent(T)), c.releaseCapture(T.pointerId);
    }
    _lostpointercapture(T) {
      c.releaseCapture(T.pointerId);
    }
    setPointersPositions(T) {
      var $ = this._getContentPosition(), W = null, Pt = null;
      T = T || window.event, T.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(T.touches, (St) => {
        this._pointerPositions.push({
          id: St.identifier,
          x: (St.clientX - $.left) / $.scaleX,
          y: (St.clientY - $.top) / $.scaleY
        });
      }), Array.prototype.forEach.call(T.changedTouches || T.touches, (St) => {
        this._changedPointerPositions.push({
          id: St.identifier,
          x: (St.clientX - $.left) / $.scaleX,
          y: (St.clientY - $.top) / $.scaleY
        });
      })) : (W = (T.clientX - $.left) / $.scaleX, Pt = (T.clientY - $.top) / $.scaleY, this.pointerPos = {
        x: W,
        y: Pt
      }, this._pointerPositions = [{ x: W, y: Pt, id: t.Util._getFirstPointerId(T) }], this._changedPointerPositions = [
        { x: W, y: Pt, id: t.Util._getFirstPointerId(T) }
      ]);
    }
    _setPointerPosition(T) {
      t.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(T);
    }
    _getContentPosition() {
      if (!this.content || !this.content.getBoundingClientRect)
        return {
          top: 0,
          left: 0,
          scaleX: 1,
          scaleY: 1
        };
      var T = this.content.getBoundingClientRect();
      return {
        top: T.top,
        left: T.left,
        scaleX: T.width / this.content.clientWidth || 1,
        scaleY: T.height / this.content.clientHeight || 1
      };
    }
    _buildDOM() {
      if (this.bufferCanvas = new r.SceneCanvas({
        width: this.width(),
        height: this.height()
      }), this.bufferHitCanvas = new r.HitCanvas({
        pixelRatio: 1,
        width: this.width(),
        height: this.height()
      }), !!i.Konva.isBrowser) {
        var T = this.container();
        if (!T)
          throw "Stage has no container. A container is required.";
        T.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), T.appendChild(this.content), this._resizeDOM();
      }
    }
    cache() {
      return t.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
    }
    clearCache() {
      return this;
    }
    batchDraw() {
      return this.getChildren().forEach(function(T) {
        T.batchDraw();
      }), this;
    }
  }
  n.Stage = Ve, Ve.prototype.nodeType = l, (0, a._registerNode)(Ve), e.Factory.addGetterSetter(Ve, "container");
})(Fm);
var ta = {}, ie = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Shape = n.shapes = void 0;
  const t = ft, e = Vt, s = ut, i = Nt, r = z, o = ft, a = Ue;
  var c = "hasShadow", l = "shadowRGBA", h = "patternImage", d = "linearGradient", u = "radialGradient";
  let f;
  function p() {
    return f || (f = e.Util.createCanvasElement().getContext("2d"), f);
  }
  n.shapes = {};
  function m(A) {
    const E = this.attrs.fillRule;
    E ? A.fill(E) : A.fill();
  }
  function _(A) {
    A.stroke();
  }
  function v(A) {
    A.fill();
  }
  function b(A) {
    A.stroke();
  }
  function g() {
    this._clearCache(c);
  }
  function y() {
    this._clearCache(l);
  }
  function S() {
    this._clearCache(h);
  }
  function w() {
    this._clearCache(d);
  }
  function k() {
    this._clearCache(u);
  }
  class C extends i.Node {
    constructor(E) {
      super(E);
      let I;
      for (; I = e.Util.getRandomColor(), !(I && !(I in n.shapes)); )
        ;
      this.colorKey = I, n.shapes[I] = this;
    }
    getContext() {
      return e.Util.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext();
    }
    getCanvas() {
      return e.Util.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas();
    }
    getSceneFunc() {
      return this.attrs.sceneFunc || this._sceneFunc;
    }
    getHitFunc() {
      return this.attrs.hitFunc || this._hitFunc;
    }
    hasShadow() {
      return this._getCache(c, this._hasShadow);
    }
    _hasShadow() {
      return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
    }
    _getFillPattern() {
      return this._getCache(h, this.__getFillPattern);
    }
    __getFillPattern() {
      if (this.fillPatternImage()) {
        var E = p();
        const I = E.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
        if (I && I.setTransform) {
          const P = new e.Transform();
          P.translate(this.fillPatternX(), this.fillPatternY()), P.rotate(t.Konva.getAngle(this.fillPatternRotation())), P.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), P.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
          const M = P.getMatrix(), F = typeof DOMMatrix > "u" ? {
            a: M[0],
            b: M[1],
            c: M[2],
            d: M[3],
            e: M[4],
            f: M[5]
          } : new DOMMatrix(M);
          I.setTransform(F);
        }
        return I;
      }
    }
    _getLinearGradient() {
      return this._getCache(d, this.__getLinearGradient);
    }
    __getLinearGradient() {
      var E = this.fillLinearGradientColorStops();
      if (E) {
        for (var I = p(), P = this.fillLinearGradientStartPoint(), M = this.fillLinearGradientEndPoint(), F = I.createLinearGradient(P.x, P.y, M.x, M.y), V = 0; V < E.length; V += 2)
          F.addColorStop(E[V], E[V + 1]);
        return F;
      }
    }
    _getRadialGradient() {
      return this._getCache(u, this.__getRadialGradient);
    }
    __getRadialGradient() {
      var E = this.fillRadialGradientColorStops();
      if (E) {
        for (var I = p(), P = this.fillRadialGradientStartPoint(), M = this.fillRadialGradientEndPoint(), F = I.createRadialGradient(P.x, P.y, this.fillRadialGradientStartRadius(), M.x, M.y, this.fillRadialGradientEndRadius()), V = 0; V < E.length; V += 2)
          F.addColorStop(E[V], E[V + 1]);
        return F;
      }
    }
    getShadowRGBA() {
      return this._getCache(l, this._getShadowRGBA);
    }
    _getShadowRGBA() {
      if (this.hasShadow()) {
        var E = e.Util.colorToRGBA(this.shadowColor());
        if (E)
          return "rgba(" + E.r + "," + E.g + "," + E.b + "," + E.a * (this.shadowOpacity() || 1) + ")";
      }
    }
    hasFill() {
      return this._calculate("hasFill", [
        "fillEnabled",
        "fill",
        "fillPatternImage",
        "fillLinearGradientColorStops",
        "fillRadialGradientColorStops"
      ], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()));
    }
    hasStroke() {
      return this._calculate("hasStroke", [
        "strokeEnabled",
        "strokeWidth",
        "stroke",
        "strokeLinearGradientColorStops"
      ], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()));
    }
    hasHitStroke() {
      const E = this.hitStrokeWidth();
      return E === "auto" ? this.hasStroke() : this.strokeEnabled() && !!E;
    }
    intersects(E) {
      var I = this.getStage();
      if (!I)
        return !1;
      const P = I.bufferHitCanvas;
      return P.getContext().clear(), this.drawHit(P, void 0, !0), P.context.getImageData(Math.round(E.x), Math.round(E.y), 1, 1).data[3] > 0;
    }
    destroy() {
      return i.Node.prototype.destroy.call(this), delete n.shapes[this.colorKey], delete this.colorKey, this;
    }
    _useBufferCanvas(E) {
      var I;
      if (!((I = this.attrs.perfectDrawEnabled) !== null && I !== void 0 ? I : !0))
        return !1;
      const M = E || this.hasFill(), F = this.hasStroke(), V = this.getAbsoluteOpacity() !== 1;
      if (M && F && V)
        return !0;
      const q = this.hasShadow(), ht = this.shadowForStrokeEnabled();
      return !!(M && F && q && ht);
    }
    setStrokeHitEnabled(E) {
      e.Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), E ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
    }
    getStrokeHitEnabled() {
      return this.hitStrokeWidth() !== 0;
    }
    getSelfRect() {
      var E = this.size();
      return {
        x: this._centroid ? -E.width / 2 : 0,
        y: this._centroid ? -E.height / 2 : 0,
        width: E.width,
        height: E.height
      };
    }
    getClientRect(E = {}) {
      const I = E.skipTransform, P = E.relativeTo, M = this.getSelfRect(), V = !E.skipStroke && this.hasStroke() && this.strokeWidth() || 0, q = M.width + V, ht = M.height + V, rt = !E.skipShadow && this.hasShadow(), Dt = rt ? this.shadowOffsetX() : 0, K = rt ? this.shadowOffsetY() : 0, X = q + Math.abs(Dt), vt = ht + Math.abs(K), Tt = rt && this.shadowBlur() || 0, Ct = X + Tt * 2, Ve = vt + Tt * 2, Lt = {
        width: Ct,
        height: Ve,
        x: -(V / 2 + Tt) + Math.min(Dt, 0) + M.x,
        y: -(V / 2 + Tt) + Math.min(K, 0) + M.y
      };
      return I ? Lt : this._transformedRect(Lt, P);
    }
    drawScene(E, I, P) {
      var M = this.getLayer(), F = E || M.getCanvas(), V = F.getContext(), q = this._getCanvasCache(), ht = this.getSceneFunc(), rt = this.hasShadow(), Dt, K, X = F.isCache, vt = I === this;
      if (!this.isVisible() && !vt)
        return this;
      if (q) {
        V.save();
        var Tt = this.getAbsoluteTransform(I).getMatrix();
        return V.transform(Tt[0], Tt[1], Tt[2], Tt[3], Tt[4], Tt[5]), this._drawCachedSceneCanvas(V), V.restore(), this;
      }
      if (!ht)
        return this;
      if (V.save(), this._useBufferCanvas() && !X) {
        Dt = this.getStage();
        const Lt = P || Dt.bufferCanvas;
        K = Lt.getContext(), K.clear(), K.save(), K._applyLineJoin(this);
        var Ct = this.getAbsoluteTransform(I).getMatrix();
        K.transform(Ct[0], Ct[1], Ct[2], Ct[3], Ct[4], Ct[5]), ht.call(this, K, this), K.restore();
        var Ve = Lt.pixelRatio;
        rt && V._applyShadow(this), V._applyOpacity(this), V._applyGlobalCompositeOperation(this), V.drawImage(Lt._canvas, 0, 0, Lt.width / Ve, Lt.height / Ve);
      } else {
        if (V._applyLineJoin(this), !vt) {
          var Ct = this.getAbsoluteTransform(I).getMatrix();
          V.transform(Ct[0], Ct[1], Ct[2], Ct[3], Ct[4], Ct[5]), V._applyOpacity(this), V._applyGlobalCompositeOperation(this);
        }
        rt && V._applyShadow(this), ht.call(this, V, this);
      }
      return V.restore(), this;
    }
    drawHit(E, I, P = !1) {
      if (!this.shouldDrawHit(I, P))
        return this;
      var M = this.getLayer(), F = E || M.hitCanvas, V = F && F.getContext(), q = this.hitFunc() || this.sceneFunc(), ht = this._getCanvasCache(), rt = ht && ht.hit;
      if (this.colorKey || e.Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), rt) {
        V.save();
        var Dt = this.getAbsoluteTransform(I).getMatrix();
        return V.transform(Dt[0], Dt[1], Dt[2], Dt[3], Dt[4], Dt[5]), this._drawCachedHitCanvas(V), V.restore(), this;
      }
      if (!q)
        return this;
      if (V.save(), V._applyLineJoin(this), !(this === I)) {
        var X = this.getAbsoluteTransform(I).getMatrix();
        V.transform(X[0], X[1], X[2], X[3], X[4], X[5]);
      }
      return q.call(this, V, this), V.restore(), this;
    }
    drawHitFromCache(E = 0) {
      var I = this._getCanvasCache(), P = this._getCachedSceneCanvas(), M = I.hit, F = M.getContext(), V = M.getWidth(), q = M.getHeight(), ht, rt, Dt, K, X, vt;
      F.clear(), F.drawImage(P._canvas, 0, 0, V, q);
      try {
        for (ht = F.getImageData(0, 0, V, q), rt = ht.data, Dt = rt.length, K = e.Util._hexToRgb(this.colorKey), X = 0; X < Dt; X += 4)
          vt = rt[X + 3], vt > E ? (rt[X] = K.r, rt[X + 1] = K.g, rt[X + 2] = K.b, rt[X + 3] = 255) : rt[X + 3] = 0;
        F.putImageData(ht, 0, 0);
      } catch (Tt) {
        e.Util.error("Unable to draw hit graph from cached scene canvas. " + Tt.message);
      }
      return this;
    }
    hasPointerCapture(E) {
      return a.hasPointerCapture(E, this);
    }
    setPointerCapture(E) {
      a.setPointerCapture(E, this);
    }
    releaseCapture(E) {
      a.releaseCapture(E, this);
    }
  }
  n.Shape = C, C.prototype._fillFunc = m, C.prototype._strokeFunc = _, C.prototype._fillFuncHit = v, C.prototype._strokeFuncHit = b, C.prototype._centroid = !1, C.prototype.nodeType = "Shape", (0, o._registerNode)(C), C.prototype.eventListeners = {}, C.prototype.on.call(C.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", g), C.prototype.on.call(C.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", y), C.prototype.on.call(C.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", S), C.prototype.on.call(C.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", w), C.prototype.on.call(C.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", k), s.Factory.addGetterSetter(C, "stroke", void 0, (0, r.getStringOrGradientValidator)()), s.Factory.addGetterSetter(C, "strokeWidth", 2, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "fillAfterStrokeEnabled", !1), s.Factory.addGetterSetter(C, "hitStrokeWidth", "auto", (0, r.getNumberOrAutoValidator)()), s.Factory.addGetterSetter(C, "strokeHitEnabled", !0, (0, r.getBooleanValidator)()), s.Factory.addGetterSetter(C, "perfectDrawEnabled", !0, (0, r.getBooleanValidator)()), s.Factory.addGetterSetter(C, "shadowForStrokeEnabled", !0, (0, r.getBooleanValidator)()), s.Factory.addGetterSetter(C, "lineJoin"), s.Factory.addGetterSetter(C, "lineCap"), s.Factory.addGetterSetter(C, "sceneFunc"), s.Factory.addGetterSetter(C, "hitFunc"), s.Factory.addGetterSetter(C, "dash"), s.Factory.addGetterSetter(C, "dashOffset", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "shadowColor", void 0, (0, r.getStringValidator)()), s.Factory.addGetterSetter(C, "shadowBlur", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "shadowOpacity", 1, (0, r.getNumberValidator)()), s.Factory.addComponentsGetterSetter(C, "shadowOffset", ["x", "y"]), s.Factory.addGetterSetter(C, "shadowOffsetX", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "shadowOffsetY", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "fillPatternImage"), s.Factory.addGetterSetter(C, "fill", void 0, (0, r.getStringOrGradientValidator)()), s.Factory.addGetterSetter(C, "fillPatternX", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "fillPatternY", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "fillLinearGradientColorStops"), s.Factory.addGetterSetter(C, "strokeLinearGradientColorStops"), s.Factory.addGetterSetter(C, "fillRadialGradientStartRadius", 0), s.Factory.addGetterSetter(C, "fillRadialGradientEndRadius", 0), s.Factory.addGetterSetter(C, "fillRadialGradientColorStops"), s.Factory.addGetterSetter(C, "fillPatternRepeat", "repeat"), s.Factory.addGetterSetter(C, "fillEnabled", !0), s.Factory.addGetterSetter(C, "strokeEnabled", !0), s.Factory.addGetterSetter(C, "shadowEnabled", !0), s.Factory.addGetterSetter(C, "dashEnabled", !0), s.Factory.addGetterSetter(C, "strokeScaleEnabled", !0), s.Factory.addGetterSetter(C, "fillPriority", "color"), s.Factory.addComponentsGetterSetter(C, "fillPatternOffset", ["x", "y"]), s.Factory.addGetterSetter(C, "fillPatternOffsetX", 0, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "fillPatternOffsetY", 0, (0, r.getNumberValidator)()), s.Factory.addComponentsGetterSetter(C, "fillPatternScale", ["x", "y"]), s.Factory.addGetterSetter(C, "fillPatternScaleX", 1, (0, r.getNumberValidator)()), s.Factory.addGetterSetter(C, "fillPatternScaleY", 1, (0, r.getNumberValidator)()), s.Factory.addComponentsGetterSetter(C, "fillLinearGradientStartPoint", [
    "x",
    "y"
  ]), s.Factory.addComponentsGetterSetter(C, "strokeLinearGradientStartPoint", [
    "x",
    "y"
  ]), s.Factory.addGetterSetter(C, "fillLinearGradientStartPointX", 0), s.Factory.addGetterSetter(C, "strokeLinearGradientStartPointX", 0), s.Factory.addGetterSetter(C, "fillLinearGradientStartPointY", 0), s.Factory.addGetterSetter(C, "strokeLinearGradientStartPointY", 0), s.Factory.addComponentsGetterSetter(C, "fillLinearGradientEndPoint", [
    "x",
    "y"
  ]), s.Factory.addComponentsGetterSetter(C, "strokeLinearGradientEndPoint", [
    "x",
    "y"
  ]), s.Factory.addGetterSetter(C, "fillLinearGradientEndPointX", 0), s.Factory.addGetterSetter(C, "strokeLinearGradientEndPointX", 0), s.Factory.addGetterSetter(C, "fillLinearGradientEndPointY", 0), s.Factory.addGetterSetter(C, "strokeLinearGradientEndPointY", 0), s.Factory.addComponentsGetterSetter(C, "fillRadialGradientStartPoint", [
    "x",
    "y"
  ]), s.Factory.addGetterSetter(C, "fillRadialGradientStartPointX", 0), s.Factory.addGetterSetter(C, "fillRadialGradientStartPointY", 0), s.Factory.addComponentsGetterSetter(C, "fillRadialGradientEndPoint", [
    "x",
    "y"
  ]), s.Factory.addGetterSetter(C, "fillRadialGradientEndPointX", 0), s.Factory.addGetterSetter(C, "fillRadialGradientEndPointY", 0), s.Factory.addGetterSetter(C, "fillPatternRotation", 0), s.Factory.addGetterSetter(C, "fillRule", void 0, (0, r.getStringValidator)()), s.Factory.backCompat(C, {
    dashArray: "dash",
    getDashArray: "getDash",
    setDashArray: "getDash",
    drawFunc: "sceneFunc",
    getDrawFunc: "getSceneFunc",
    setDrawFunc: "setSceneFunc",
    drawHitFunc: "hitFunc",
    getDrawHitFunc: "getHitFunc",
    setDrawHitFunc: "setHitFunc"
  });
})(ie);
Object.defineProperty(ta, "__esModule", { value: !0 });
ta.Layer = void 0;
const Ms = Vt, Eh = bi, Pi = Nt, rf = ut, P0 = rs, fS = z, pS = ie, gS = ft;
var mS = "#", _S = "beforeDraw", yS = "draw", jm = [
  { x: 0, y: 0 },
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 }
], vS = jm.length;
class kr extends Eh.Container {
  constructor(t) {
    super(t), this.canvas = new P0.SceneCanvas(), this.hitCanvas = new P0.HitCanvas({
      pixelRatio: 1
    }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled();
  }
  createPNGStream() {
    return this.canvas._canvas.createPNGStream();
  }
  getCanvas() {
    return this.canvas;
  }
  getNativeCanvasElement() {
    return this.canvas._canvas;
  }
  getHitCanvas() {
    return this.hitCanvas;
  }
  getContext() {
    return this.getCanvas().getContext();
  }
  clear(t) {
    return this.getContext().clear(t), this.getHitCanvas().getContext().clear(t), this;
  }
  setZIndex(t) {
    super.setZIndex(t);
    var e = this.getStage();
    return e && e.content && (e.content.removeChild(this.getNativeCanvasElement()), t < e.children.length - 1 ? e.content.insertBefore(this.getNativeCanvasElement(), e.children[t + 1].getCanvas()._canvas) : e.content.appendChild(this.getNativeCanvasElement())), this;
  }
  moveToTop() {
    Pi.Node.prototype.moveToTop.call(this);
    var t = this.getStage();
    return t && t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.appendChild(this.getNativeCanvasElement())), !0;
  }
  moveUp() {
    var t = Pi.Node.prototype.moveUp.call(this);
    if (!t)
      return !1;
    var e = this.getStage();
    return !e || !e.content ? !1 : (e.content.removeChild(this.getNativeCanvasElement()), this.index < e.children.length - 1 ? e.content.insertBefore(this.getNativeCanvasElement(), e.children[this.index + 1].getCanvas()._canvas) : e.content.appendChild(this.getNativeCanvasElement()), !0);
  }
  moveDown() {
    if (Pi.Node.prototype.moveDown.call(this)) {
      var t = this.getStage();
      if (t) {
        var e = t.children;
        t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), e[this.index + 1].getCanvas()._canvas));
      }
      return !0;
    }
    return !1;
  }
  moveToBottom() {
    if (Pi.Node.prototype.moveToBottom.call(this)) {
      var t = this.getStage();
      if (t) {
        var e = t.children;
        t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), e[1].getCanvas()._canvas));
      }
      return !0;
    }
    return !1;
  }
  getLayer() {
    return this;
  }
  remove() {
    var t = this.getNativeCanvasElement();
    return Pi.Node.prototype.remove.call(this), t && t.parentNode && Ms.Util._isInDocument(t) && t.parentNode.removeChild(t), this;
  }
  getStage() {
    return this.parent;
  }
  setSize({ width: t, height: e }) {
    return this.canvas.setSize(t, e), this.hitCanvas.setSize(t, e), this._setSmoothEnabled(), this;
  }
  _validateAdd(t) {
    var e = t.getType();
    e !== "Group" && e !== "Shape" && Ms.Util.throw("You may only add groups and shapes to a layer.");
  }
  _toKonvaCanvas(t) {
    return t = t || {}, t.width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = t.x !== void 0 ? t.x : this.x(), t.y = t.y !== void 0 ? t.y : this.y(), Pi.Node.prototype._toKonvaCanvas.call(this, t);
  }
  _checkVisibility() {
    this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none";
  }
  _setSmoothEnabled() {
    this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
  }
  getWidth() {
    if (this.parent)
      return this.parent.width();
  }
  setWidth() {
    Ms.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
  }
  getHeight() {
    if (this.parent)
      return this.parent.height();
  }
  setHeight() {
    Ms.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
  }
  batchDraw() {
    return this._waitingForDraw || (this._waitingForDraw = !0, Ms.Util.requestAnimFrame(() => {
      this.draw(), this._waitingForDraw = !1;
    })), this;
  }
  getIntersection(t) {
    if (!this.isListening() || !this.isVisible())
      return null;
    for (var e = 1, s = !1; ; ) {
      for (let i = 0; i < vS; i++) {
        const r = jm[i], o = this._getIntersection({
          x: t.x + r.x * e,
          y: t.y + r.y * e
        }), a = o.shape;
        if (a)
          return a;
        if (s = !!o.antialiased, !o.antialiased)
          break;
      }
      if (s)
        e += 1;
      else
        return null;
    }
  }
  _getIntersection(t) {
    const e = this.hitCanvas.pixelRatio, s = this.hitCanvas.context.getImageData(Math.round(t.x * e), Math.round(t.y * e), 1, 1).data, i = s[3];
    if (i === 255) {
      const r = Ms.Util._rgbToHex(s[0], s[1], s[2]), o = pS.shapes[mS + r];
      return o ? {
        shape: o
      } : {
        antialiased: !0
      };
    } else if (i > 0)
      return {
        antialiased: !0
      };
    return {};
  }
  drawScene(t, e) {
    var s = this.getLayer(), i = t || s && s.getCanvas();
    return this._fire(_S, {
      node: this
    }), this.clearBeforeDraw() && i.getContext().clear(), Eh.Container.prototype.drawScene.call(this, i, e), this._fire(yS, {
      node: this
    }), this;
  }
  drawHit(t, e) {
    var s = this.getLayer(), i = t || s && s.hitCanvas;
    return s && s.clearBeforeDraw() && s.getHitCanvas().getContext().clear(), Eh.Container.prototype.drawHit.call(this, i, e), this;
  }
  enableHitGraph() {
    return this.hitGraphEnabled(!0), this;
  }
  disableHitGraph() {
    return this.hitGraphEnabled(!1), this;
  }
  setHitGraphEnabled(t) {
    Ms.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t);
  }
  getHitGraphEnabled(t) {
    return Ms.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening();
  }
  toggleHitCanvas() {
    if (!(!this.parent || !this.parent.content)) {
      var t = this.parent, e = !!this.hitCanvas._canvas.parentNode;
      e ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas);
    }
  }
  destroy() {
    return Ms.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy();
  }
}
ta.Layer = kr;
kr.prototype.nodeType = "Layer";
(0, gS._registerNode)(kr);
rf.Factory.addGetterSetter(kr, "imageSmoothingEnabled", !0);
rf.Factory.addGetterSetter(kr, "clearBeforeDraw", !0);
rf.Factory.addGetterSetter(kr, "hitGraphEnabled", !0, (0, fS.getBooleanValidator)());
var al = {};
Object.defineProperty(al, "__esModule", { value: !0 });
al.FastLayer = void 0;
const bS = Vt, wS = ta, SS = ft;
class of extends wS.Layer {
  constructor(t) {
    super(t), this.listening(!1), bS.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
  }
}
al.FastLayer = of;
of.prototype.nodeType = "FastLayer";
(0, SS._registerNode)(of);
var xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.Group = void 0;
const CS = Vt, kS = bi, xS = ft;
class af extends kS.Container {
  _validateAdd(t) {
    var e = t.getType();
    e !== "Group" && e !== "Shape" && CS.Util.throw("You may only add groups and shapes to groups.");
  }
}
xr.Group = af;
af.prototype.nodeType = "Group";
(0, xS._registerNode)(af);
var Er = {};
Object.defineProperty(Er, "__esModule", { value: !0 });
Er.Animation = void 0;
const Th = ft, M0 = Vt, Ah = function() {
  return Th.glob.performance && Th.glob.performance.now ? function() {
    return Th.glob.performance.now();
  } : function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
}();
class vs {
  constructor(t, e) {
    this.id = vs.animIdCounter++, this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: Ah(),
      frameRate: 0
    }, this.func = t, this.setLayers(e);
  }
  setLayers(t) {
    let e = [];
    return t && (e = Array.isArray(t) ? t : [t]), this.layers = e, this;
  }
  getLayers() {
    return this.layers;
  }
  addLayer(t) {
    const e = this.layers, s = e.length;
    for (let i = 0; i < s; i++)
      if (e[i]._id === t._id)
        return !1;
    return this.layers.push(t), !0;
  }
  isRunning() {
    const e = vs.animations, s = e.length;
    for (let i = 0; i < s; i++)
      if (e[i].id === this.id)
        return !0;
    return !1;
  }
  start() {
    return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = Ah(), vs._addAnimation(this), this;
  }
  stop() {
    return vs._removeAnimation(this), this;
  }
  _updateFrameObject(t) {
    this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;
  }
  static _addAnimation(t) {
    this.animations.push(t), this._handleAnimation();
  }
  static _removeAnimation(t) {
    const e = t.id, s = this.animations, i = s.length;
    for (let r = 0; r < i; r++)
      if (s[r].id === e) {
        this.animations.splice(r, 1);
        break;
      }
  }
  static _runFrames() {
    const t = {}, e = this.animations;
    for (let s = 0; s < e.length; s++) {
      const i = e[s], r = i.layers, o = i.func;
      i._updateFrameObject(Ah());
      const a = r.length;
      let c;
      if (o ? c = o.call(i, i.frame) !== !1 : c = !0, !!c)
        for (let l = 0; l < a; l++) {
          const h = r[l];
          h._id !== void 0 && (t[h._id] = h);
        }
    }
    for (let s in t)
      t.hasOwnProperty(s) && t[s].batchDraw();
  }
  static _animationLoop() {
    const t = vs;
    t.animations.length ? (t._runFrames(), M0.Util.requestAnimFrame(t._animationLoop)) : t.animRunning = !1;
  }
  static _handleAnimation() {
    this.animRunning || (this.animRunning = !0, M0.Util.requestAnimFrame(this._animationLoop));
  }
}
Er.Animation = vs;
vs.animations = [];
vs.animIdCounter = 0;
vs.animRunning = !1;
var Gm = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Easings = n.Tween = void 0;
  const t = Vt, e = Er, s = Nt, i = ft;
  var r = {
    node: 1,
    duration: 1,
    easing: 1,
    onFinish: 1,
    yoyo: 1
  }, o = 1, a = 2, c = 3, l = 0, h = ["fill", "stroke", "shadowColor"];
  class d {
    constructor(p, m, _, v, b, g, y) {
      this.prop = p, this.propFunc = m, this.begin = v, this._pos = v, this.duration = g, this._change = 0, this.prevPos = 0, this.yoyo = y, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = _, this._change = b - this.begin, this.pause();
    }
    fire(p) {
      var m = this[p];
      m && m();
    }
    setTime(p) {
      p > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : p < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = p, this.update());
    }
    getTime() {
      return this._time;
    }
    setPosition(p) {
      this.prevPos = this._pos, this.propFunc(p), this._pos = p;
    }
    getPosition(p) {
      return p === void 0 && (p = this._time), this.func(p, this.begin, this._change, this.duration);
    }
    play() {
      this.state = a, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay");
    }
    reverse() {
      this.state = c, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse");
    }
    seek(p) {
      this.pause(), this._time = p, this.update(), this.fire("onSeek");
    }
    reset() {
      this.pause(), this._time = 0, this.update(), this.fire("onReset");
    }
    finish() {
      this.pause(), this._time = this.duration, this.update(), this.fire("onFinish");
    }
    update() {
      this.setPosition(this.getPosition(this._time)), this.fire("onUpdate");
    }
    onEnterFrame() {
      var p = this.getTimer() - this._startTime;
      this.state === a ? this.setTime(p) : this.state === c && this.setTime(this.duration - p);
    }
    pause() {
      this.state = o, this.fire("onPause");
    }
    getTimer() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
  class u {
    constructor(p) {
      var m = this, _ = p.node, v = _._id, b, g = p.easing || n.Easings.Linear, y = !!p.yoyo, S;
      typeof p.duration > "u" ? b = 0.3 : p.duration === 0 ? b = 1e-3 : b = p.duration, this.node = _, this._id = l++;
      var w = _.getLayer() || (_ instanceof i.Konva.Stage ? _.getLayers() : null);
      w || t.Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new e.Animation(function() {
        m.tween.onEnterFrame();
      }, w), this.tween = new d(S, function(k) {
        m._tweenFunc(k);
      }, g, 0, 1, b * 1e3, y), this._addListeners(), u.attrs[v] || (u.attrs[v] = {}), u.attrs[v][this._id] || (u.attrs[v][this._id] = {}), u.tweens[v] || (u.tweens[v] = {});
      for (S in p)
        r[S] === void 0 && this._addAttr(S, p[S]);
      this.reset(), this.onFinish = p.onFinish, this.onReset = p.onReset, this.onUpdate = p.onUpdate;
    }
    _addAttr(p, m) {
      var _ = this.node, v = _._id, b, g, y, S, w, k, C, A;
      if (y = u.tweens[v][p], y && delete u.attrs[v][y][p], b = _.getAttr(p), t.Util._isArray(m))
        if (g = [], w = Math.max(m.length, b.length), p === "points" && m.length !== b.length && (m.length > b.length ? (C = b, b = t.Util._prepareArrayForTween(b, m, _.closed())) : (k = m, m = t.Util._prepareArrayForTween(m, b, _.closed()))), p.indexOf("fill") === 0)
          for (S = 0; S < w; S++)
            if (S % 2 === 0)
              g.push(m[S] - b[S]);
            else {
              var E = t.Util.colorToRGBA(b[S]);
              A = t.Util.colorToRGBA(m[S]), b[S] = E, g.push({
                r: A.r - E.r,
                g: A.g - E.g,
                b: A.b - E.b,
                a: A.a - E.a
              });
            }
        else
          for (S = 0; S < w; S++)
            g.push(m[S] - b[S]);
      else
        h.indexOf(p) !== -1 ? (b = t.Util.colorToRGBA(b), A = t.Util.colorToRGBA(m), g = {
          r: A.r - b.r,
          g: A.g - b.g,
          b: A.b - b.b,
          a: A.a - b.a
        }) : g = m - b;
      u.attrs[v][this._id][p] = {
        start: b,
        diff: g,
        end: m,
        trueEnd: k,
        trueStart: C
      }, u.tweens[v][p] = this._id;
    }
    _tweenFunc(p) {
      var m = this.node, _ = u.attrs[m._id][this._id], v, b, g, y, S, w, k, C;
      for (v in _) {
        if (b = _[v], g = b.start, y = b.diff, C = b.end, t.Util._isArray(g))
          if (S = [], k = Math.max(g.length, C.length), v.indexOf("fill") === 0)
            for (w = 0; w < k; w++)
              w % 2 === 0 ? S.push((g[w] || 0) + y[w] * p) : S.push("rgba(" + Math.round(g[w].r + y[w].r * p) + "," + Math.round(g[w].g + y[w].g * p) + "," + Math.round(g[w].b + y[w].b * p) + "," + (g[w].a + y[w].a * p) + ")");
          else
            for (w = 0; w < k; w++)
              S.push((g[w] || 0) + y[w] * p);
        else
          h.indexOf(v) !== -1 ? S = "rgba(" + Math.round(g.r + y.r * p) + "," + Math.round(g.g + y.g * p) + "," + Math.round(g.b + y.b * p) + "," + (g.a + y.a * p) + ")" : S = g + y * p;
        m.setAttr(v, S);
      }
    }
    _addListeners() {
      this.tween.onPlay = () => {
        this.anim.start();
      }, this.tween.onReverse = () => {
        this.anim.start();
      }, this.tween.onPause = () => {
        this.anim.stop();
      }, this.tween.onFinish = () => {
        var p = this.node, m = u.attrs[p._id][this._id];
        m.points && m.points.trueEnd && p.setAttr("points", m.points.trueEnd), this.onFinish && this.onFinish.call(this);
      }, this.tween.onReset = () => {
        var p = this.node, m = u.attrs[p._id][this._id];
        m.points && m.points.trueStart && p.points(m.points.trueStart), this.onReset && this.onReset();
      }, this.tween.onUpdate = () => {
        this.onUpdate && this.onUpdate.call(this);
      };
    }
    play() {
      return this.tween.play(), this;
    }
    reverse() {
      return this.tween.reverse(), this;
    }
    reset() {
      return this.tween.reset(), this;
    }
    seek(p) {
      return this.tween.seek(p * 1e3), this;
    }
    pause() {
      return this.tween.pause(), this;
    }
    finish() {
      return this.tween.finish(), this;
    }
    destroy() {
      var p = this.node._id, m = this._id, _ = u.tweens[p], v;
      this.pause();
      for (v in _)
        delete u.tweens[p][v];
      delete u.attrs[p][m];
    }
  }
  n.Tween = u, u.attrs = {}, u.tweens = {}, s.Node.prototype.to = function(f) {
    var p = f.onFinish;
    f.node = this, f.onFinish = function() {
      this.destroy(), p && p();
    };
    var m = new u(f);
    m.play();
  }, n.Easings = {
    BackEaseIn(f, p, m, _) {
      var v = 1.70158;
      return m * (f /= _) * f * ((v + 1) * f - v) + p;
    },
    BackEaseOut(f, p, m, _) {
      var v = 1.70158;
      return m * ((f = f / _ - 1) * f * ((v + 1) * f + v) + 1) + p;
    },
    BackEaseInOut(f, p, m, _) {
      var v = 1.70158;
      return (f /= _ / 2) < 1 ? m / 2 * (f * f * (((v *= 1.525) + 1) * f - v)) + p : m / 2 * ((f -= 2) * f * (((v *= 1.525) + 1) * f + v) + 2) + p;
    },
    ElasticEaseIn(f, p, m, _, v, b) {
      var g = 0;
      return f === 0 ? p : (f /= _) === 1 ? p + m : (b || (b = _ * 0.3), !v || v < Math.abs(m) ? (v = m, g = b / 4) : g = b / (2 * Math.PI) * Math.asin(m / v), -(v * Math.pow(2, 10 * (f -= 1)) * Math.sin((f * _ - g) * (2 * Math.PI) / b)) + p);
    },
    ElasticEaseOut(f, p, m, _, v, b) {
      var g = 0;
      return f === 0 ? p : (f /= _) === 1 ? p + m : (b || (b = _ * 0.3), !v || v < Math.abs(m) ? (v = m, g = b / 4) : g = b / (2 * Math.PI) * Math.asin(m / v), v * Math.pow(2, -10 * f) * Math.sin((f * _ - g) * (2 * Math.PI) / b) + m + p);
    },
    ElasticEaseInOut(f, p, m, _, v, b) {
      var g = 0;
      return f === 0 ? p : (f /= _ / 2) === 2 ? p + m : (b || (b = _ * (0.3 * 1.5)), !v || v < Math.abs(m) ? (v = m, g = b / 4) : g = b / (2 * Math.PI) * Math.asin(m / v), f < 1 ? -0.5 * (v * Math.pow(2, 10 * (f -= 1)) * Math.sin((f * _ - g) * (2 * Math.PI) / b)) + p : v * Math.pow(2, -10 * (f -= 1)) * Math.sin((f * _ - g) * (2 * Math.PI) / b) * 0.5 + m + p);
    },
    BounceEaseOut(f, p, m, _) {
      return (f /= _) < 1 / 2.75 ? m * (7.5625 * f * f) + p : f < 2 / 2.75 ? m * (7.5625 * (f -= 1.5 / 2.75) * f + 0.75) + p : f < 2.5 / 2.75 ? m * (7.5625 * (f -= 2.25 / 2.75) * f + 0.9375) + p : m * (7.5625 * (f -= 2.625 / 2.75) * f + 0.984375) + p;
    },
    BounceEaseIn(f, p, m, _) {
      return m - n.Easings.BounceEaseOut(_ - f, 0, m, _) + p;
    },
    BounceEaseInOut(f, p, m, _) {
      return f < _ / 2 ? n.Easings.BounceEaseIn(f * 2, 0, m, _) * 0.5 + p : n.Easings.BounceEaseOut(f * 2 - _, 0, m, _) * 0.5 + m * 0.5 + p;
    },
    EaseIn(f, p, m, _) {
      return m * (f /= _) * f + p;
    },
    EaseOut(f, p, m, _) {
      return -m * (f /= _) * (f - 2) + p;
    },
    EaseInOut(f, p, m, _) {
      return (f /= _ / 2) < 1 ? m / 2 * f * f + p : -m / 2 * (--f * (f - 2) - 1) + p;
    },
    StrongEaseIn(f, p, m, _) {
      return m * (f /= _) * f * f * f * f + p;
    },
    StrongEaseOut(f, p, m, _) {
      return m * ((f = f / _ - 1) * f * f * f * f + 1) + p;
    },
    StrongEaseInOut(f, p, m, _) {
      return (f /= _ / 2) < 1 ? m / 2 * f * f * f * f * f + p : m / 2 * ((f -= 2) * f * f * f * f + 2) + p;
    },
    Linear(f, p, m, _) {
      return m * f / _ + p;
    }
  };
})(Gm);
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.Konva = void 0;
  const t = ft, e = Vt, s = Nt, i = bi, r = Fm, o = ta, a = al, c = xr, l = rl, h = ie, d = Er, u = Gm, f = Vs, p = rs;
  n.Konva = e.Util._assign(t.Konva, {
    Util: e.Util,
    Transform: e.Transform,
    Node: s.Node,
    Container: i.Container,
    Stage: r.Stage,
    stages: r.stages,
    Layer: o.Layer,
    FastLayer: a.FastLayer,
    Group: c.Group,
    DD: l.DD,
    Shape: h.Shape,
    shapes: h.shapes,
    Animation: d.Animation,
    Tween: u.Tween,
    Easings: u.Easings,
    Context: f.Context,
    Canvas: p.Canvas
  }), n.default = n.Konva;
})($m);
var cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
cl.Arc = void 0;
const ll = ut, ES = ie, R0 = ft, hl = z, TS = ft;
class Qs extends ES.Shape {
  _sceneFunc(t) {
    var e = R0.Konva.getAngle(this.angle()), s = this.clockwise();
    t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, e, s), t.arc(0, 0, this.innerRadius(), e, 0, !s), t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(t) {
    this.outerRadius(t / 2);
  }
  setHeight(t) {
    this.outerRadius(t / 2);
  }
  getSelfRect() {
    const t = this.innerRadius(), e = this.outerRadius(), s = this.clockwise(), i = R0.Konva.getAngle(s ? 360 - this.angle() : this.angle()), r = Math.cos(Math.min(i, Math.PI)), o = 1, a = Math.sin(Math.min(Math.max(Math.PI, i), 3 * Math.PI / 2)), c = Math.sin(Math.min(i, Math.PI / 2)), l = r * (r > 0 ? t : e), h = o * e, d = a * (a > 0 ? t : e), u = c * (c > 0 ? e : t);
    return {
      x: l,
      y: s ? -1 * u : d,
      width: h - l,
      height: u - d
    };
  }
}
cl.Arc = Qs;
Qs.prototype._centroid = !0;
Qs.prototype.className = "Arc";
Qs.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
(0, TS._registerNode)(Qs);
ll.Factory.addGetterSetter(Qs, "innerRadius", 0, (0, hl.getNumberValidator)());
ll.Factory.addGetterSetter(Qs, "outerRadius", 0, (0, hl.getNumberValidator)());
ll.Factory.addGetterSetter(Qs, "angle", 0, (0, hl.getNumberValidator)());
ll.Factory.addGetterSetter(Qs, "clockwise", !1, (0, hl.getBooleanValidator)());
var dl = {}, ea = {};
Object.defineProperty(ea, "__esModule", { value: !0 });
ea.Line = void 0;
const ul = ut, AS = ie, Hm = z, IS = ft;
function Ud(n, t, e, s, i, r, o) {
  var a = Math.sqrt(Math.pow(e - n, 2) + Math.pow(s - t, 2)), c = Math.sqrt(Math.pow(i - e, 2) + Math.pow(r - s, 2)), l = o * a / (a + c), h = o * c / (a + c), d = e - l * (i - n), u = s - l * (r - t), f = e + h * (i - n), p = s + h * (r - t);
  return [d, u, f, p];
}
function $0(n, t) {
  var e = n.length, s = [], i, r;
  for (i = 2; i < e - 2; i += 2)
    r = Ud(n[i - 2], n[i - 1], n[i], n[i + 1], n[i + 2], n[i + 3], t), !isNaN(r[0]) && (s.push(r[0]), s.push(r[1]), s.push(n[i]), s.push(n[i + 1]), s.push(r[2]), s.push(r[3]));
  return s;
}
class On extends AS.Shape {
  constructor(t) {
    super(t), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
      this._clearCache("tensionPoints");
    });
  }
  _sceneFunc(t) {
    var e = this.points(), s = e.length, i = this.tension(), r = this.closed(), o = this.bezier(), a, c, l;
    if (s) {
      if (t.beginPath(), t.moveTo(e[0], e[1]), i !== 0 && s > 4) {
        for (a = this.getTensionPoints(), c = a.length, l = r ? 0 : 4, r || t.quadraticCurveTo(a[0], a[1], a[2], a[3]); l < c - 2; )
          t.bezierCurveTo(a[l++], a[l++], a[l++], a[l++], a[l++], a[l++]);
        r || t.quadraticCurveTo(a[c - 2], a[c - 1], e[s - 2], e[s - 1]);
      } else if (o)
        for (l = 2; l < s; )
          t.bezierCurveTo(e[l++], e[l++], e[l++], e[l++], e[l++], e[l++]);
      else
        for (l = 2; l < s; l += 2)
          t.lineTo(e[l], e[l + 1]);
      r ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this);
    }
  }
  getTensionPoints() {
    return this._getCache("tensionPoints", this._getTensionPoints);
  }
  _getTensionPoints() {
    return this.closed() ? this._getTensionPointsClosed() : $0(this.points(), this.tension());
  }
  _getTensionPointsClosed() {
    var t = this.points(), e = t.length, s = this.tension(), i = Ud(t[e - 2], t[e - 1], t[0], t[1], t[2], t[3], s), r = Ud(t[e - 4], t[e - 3], t[e - 2], t[e - 1], t[0], t[1], s), o = $0(t, s), a = [i[2], i[3]].concat(o).concat([
      r[0],
      r[1],
      t[e - 2],
      t[e - 1],
      r[2],
      r[3],
      i[0],
      i[1],
      t[0],
      t[1]
    ]);
    return a;
  }
  getWidth() {
    return this.getSelfRect().width;
  }
  getHeight() {
    return this.getSelfRect().height;
  }
  getSelfRect() {
    var t = this.points();
    if (t.length < 4)
      return {
        x: t[0] || 0,
        y: t[1] || 0,
        width: 0,
        height: 0
      };
    this.tension() !== 0 ? t = [
      t[0],
      t[1],
      ...this._getTensionPoints(),
      t[t.length - 2],
      t[t.length - 1]
    ] : t = this.points();
    for (var e = t[0], s = t[0], i = t[1], r = t[1], o, a, c = 0; c < t.length / 2; c++)
      o = t[c * 2], a = t[c * 2 + 1], e = Math.min(e, o), s = Math.max(s, o), i = Math.min(i, a), r = Math.max(r, a);
    return {
      x: e,
      y: i,
      width: s - e,
      height: r - i
    };
  }
}
ea.Line = On;
On.prototype.className = "Line";
On.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
(0, IS._registerNode)(On);
ul.Factory.addGetterSetter(On, "closed", !1);
ul.Factory.addGetterSetter(On, "bezier", !1);
ul.Factory.addGetterSetter(On, "tension", 0, (0, Hm.getNumberValidator)());
ul.Factory.addGetterSetter(On, "points", [], (0, Hm.getNumberArrayValidator)());
var Tr = {}, zm = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.t2length = n.getQuadraticArcLength = n.getCubicArcLength = n.binomialCoefficients = n.cValues = n.tValues = void 0, n.tValues = [
    [],
    [],
    [
      -0.5773502691896257,
      0.5773502691896257
    ],
    [
      0,
      -0.7745966692414834,
      0.7745966692414834
    ],
    [
      -0.33998104358485626,
      0.33998104358485626,
      -0.8611363115940526,
      0.8611363115940526
    ],
    [
      0,
      -0.5384693101056831,
      0.5384693101056831,
      -0.906179845938664,
      0.906179845938664
    ],
    [
      0.6612093864662645,
      -0.6612093864662645,
      -0.2386191860831969,
      0.2386191860831969,
      -0.932469514203152,
      0.932469514203152
    ],
    [
      0,
      0.4058451513773972,
      -0.4058451513773972,
      -0.7415311855993945,
      0.7415311855993945,
      -0.9491079123427585,
      0.9491079123427585
    ],
    [
      -0.1834346424956498,
      0.1834346424956498,
      -0.525532409916329,
      0.525532409916329,
      -0.7966664774136267,
      0.7966664774136267,
      -0.9602898564975363,
      0.9602898564975363
    ],
    [
      0,
      -0.8360311073266358,
      0.8360311073266358,
      -0.9681602395076261,
      0.9681602395076261,
      -0.3242534234038089,
      0.3242534234038089,
      -0.6133714327005904,
      0.6133714327005904
    ],
    [
      -0.14887433898163122,
      0.14887433898163122,
      -0.4333953941292472,
      0.4333953941292472,
      -0.6794095682990244,
      0.6794095682990244,
      -0.8650633666889845,
      0.8650633666889845,
      -0.9739065285171717,
      0.9739065285171717
    ],
    [
      0,
      -0.26954315595234496,
      0.26954315595234496,
      -0.5190961292068118,
      0.5190961292068118,
      -0.7301520055740494,
      0.7301520055740494,
      -0.8870625997680953,
      0.8870625997680953,
      -0.978228658146057,
      0.978228658146057
    ],
    [
      -0.1252334085114689,
      0.1252334085114689,
      -0.3678314989981802,
      0.3678314989981802,
      -0.5873179542866175,
      0.5873179542866175,
      -0.7699026741943047,
      0.7699026741943047,
      -0.9041172563704749,
      0.9041172563704749,
      -0.9815606342467192,
      0.9815606342467192
    ],
    [
      0,
      -0.2304583159551348,
      0.2304583159551348,
      -0.44849275103644687,
      0.44849275103644687,
      -0.6423493394403402,
      0.6423493394403402,
      -0.8015780907333099,
      0.8015780907333099,
      -0.9175983992229779,
      0.9175983992229779,
      -0.9841830547185881,
      0.9841830547185881
    ],
    [
      -0.10805494870734367,
      0.10805494870734367,
      -0.31911236892788974,
      0.31911236892788974,
      -0.5152486363581541,
      0.5152486363581541,
      -0.6872929048116855,
      0.6872929048116855,
      -0.827201315069765,
      0.827201315069765,
      -0.9284348836635735,
      0.9284348836635735,
      -0.9862838086968123,
      0.9862838086968123
    ],
    [
      0,
      -0.20119409399743451,
      0.20119409399743451,
      -0.3941513470775634,
      0.3941513470775634,
      -0.5709721726085388,
      0.5709721726085388,
      -0.7244177313601701,
      0.7244177313601701,
      -0.8482065834104272,
      0.8482065834104272,
      -0.937273392400706,
      0.937273392400706,
      -0.9879925180204854,
      0.9879925180204854
    ],
    [
      -0.09501250983763744,
      0.09501250983763744,
      -0.2816035507792589,
      0.2816035507792589,
      -0.45801677765722737,
      0.45801677765722737,
      -0.6178762444026438,
      0.6178762444026438,
      -0.755404408355003,
      0.755404408355003,
      -0.8656312023878318,
      0.8656312023878318,
      -0.9445750230732326,
      0.9445750230732326,
      -0.9894009349916499,
      0.9894009349916499
    ],
    [
      0,
      -0.17848418149584785,
      0.17848418149584785,
      -0.3512317634538763,
      0.3512317634538763,
      -0.5126905370864769,
      0.5126905370864769,
      -0.6576711592166907,
      0.6576711592166907,
      -0.7815140038968014,
      0.7815140038968014,
      -0.8802391537269859,
      0.8802391537269859,
      -0.9506755217687678,
      0.9506755217687678,
      -0.9905754753144174,
      0.9905754753144174
    ],
    [
      -0.0847750130417353,
      0.0847750130417353,
      -0.2518862256915055,
      0.2518862256915055,
      -0.41175116146284263,
      0.41175116146284263,
      -0.5597708310739475,
      0.5597708310739475,
      -0.6916870430603532,
      0.6916870430603532,
      -0.8037049589725231,
      0.8037049589725231,
      -0.8926024664975557,
      0.8926024664975557,
      -0.9558239495713977,
      0.9558239495713977,
      -0.9915651684209309,
      0.9915651684209309
    ],
    [
      0,
      -0.16035864564022537,
      0.16035864564022537,
      -0.31656409996362983,
      0.31656409996362983,
      -0.46457074137596094,
      0.46457074137596094,
      -0.600545304661681,
      0.600545304661681,
      -0.7209661773352294,
      0.7209661773352294,
      -0.8227146565371428,
      0.8227146565371428,
      -0.9031559036148179,
      0.9031559036148179,
      -0.96020815213483,
      0.96020815213483,
      -0.9924068438435844,
      0.9924068438435844
    ],
    [
      -0.07652652113349734,
      0.07652652113349734,
      -0.22778585114164507,
      0.22778585114164507,
      -0.37370608871541955,
      0.37370608871541955,
      -0.5108670019508271,
      0.5108670019508271,
      -0.636053680726515,
      0.636053680726515,
      -0.7463319064601508,
      0.7463319064601508,
      -0.8391169718222188,
      0.8391169718222188,
      -0.912234428251326,
      0.912234428251326,
      -0.9639719272779138,
      0.9639719272779138,
      -0.9931285991850949,
      0.9931285991850949
    ],
    [
      0,
      -0.1455618541608951,
      0.1455618541608951,
      -0.2880213168024011,
      0.2880213168024011,
      -0.4243421202074388,
      0.4243421202074388,
      -0.5516188358872198,
      0.5516188358872198,
      -0.6671388041974123,
      0.6671388041974123,
      -0.7684399634756779,
      0.7684399634756779,
      -0.8533633645833173,
      0.8533633645833173,
      -0.9200993341504008,
      0.9200993341504008,
      -0.9672268385663063,
      0.9672268385663063,
      -0.9937521706203895,
      0.9937521706203895
    ],
    [
      -0.06973927331972223,
      0.06973927331972223,
      -0.20786042668822127,
      0.20786042668822127,
      -0.34193582089208424,
      0.34193582089208424,
      -0.469355837986757,
      0.469355837986757,
      -0.5876404035069116,
      0.5876404035069116,
      -0.6944872631866827,
      0.6944872631866827,
      -0.7878168059792081,
      0.7878168059792081,
      -0.8658125777203002,
      0.8658125777203002,
      -0.926956772187174,
      0.926956772187174,
      -0.9700604978354287,
      0.9700604978354287,
      -0.9942945854823992,
      0.9942945854823992
    ],
    [
      0,
      -0.1332568242984661,
      0.1332568242984661,
      -0.26413568097034495,
      0.26413568097034495,
      -0.3903010380302908,
      0.3903010380302908,
      -0.5095014778460075,
      0.5095014778460075,
      -0.6196098757636461,
      0.6196098757636461,
      -0.7186613631319502,
      0.7186613631319502,
      -0.8048884016188399,
      0.8048884016188399,
      -0.8767523582704416,
      0.8767523582704416,
      -0.9329710868260161,
      0.9329710868260161,
      -0.9725424712181152,
      0.9725424712181152,
      -0.9947693349975522,
      0.9947693349975522
    ],
    [
      -0.06405689286260563,
      0.06405689286260563,
      -0.1911188674736163,
      0.1911188674736163,
      -0.3150426796961634,
      0.3150426796961634,
      -0.4337935076260451,
      0.4337935076260451,
      -0.5454214713888396,
      0.5454214713888396,
      -0.6480936519369755,
      0.6480936519369755,
      -0.7401241915785544,
      0.7401241915785544,
      -0.820001985973903,
      0.820001985973903,
      -0.8864155270044011,
      0.8864155270044011,
      -0.9382745520027328,
      0.9382745520027328,
      -0.9747285559713095,
      0.9747285559713095,
      -0.9951872199970213,
      0.9951872199970213
    ]
  ], n.cValues = [
    [],
    [],
    [1, 1],
    [
      0.8888888888888888,
      0.5555555555555556,
      0.5555555555555556
    ],
    [
      0.6521451548625461,
      0.6521451548625461,
      0.34785484513745385,
      0.34785484513745385
    ],
    [
      0.5688888888888889,
      0.47862867049936647,
      0.47862867049936647,
      0.23692688505618908,
      0.23692688505618908
    ],
    [
      0.3607615730481386,
      0.3607615730481386,
      0.46791393457269104,
      0.46791393457269104,
      0.17132449237917036,
      0.17132449237917036
    ],
    [
      0.4179591836734694,
      0.3818300505051189,
      0.3818300505051189,
      0.27970539148927664,
      0.27970539148927664,
      0.1294849661688697,
      0.1294849661688697
    ],
    [
      0.362683783378362,
      0.362683783378362,
      0.31370664587788727,
      0.31370664587788727,
      0.22238103445337448,
      0.22238103445337448,
      0.10122853629037626,
      0.10122853629037626
    ],
    [
      0.3302393550012598,
      0.1806481606948574,
      0.1806481606948574,
      0.08127438836157441,
      0.08127438836157441,
      0.31234707704000286,
      0.31234707704000286,
      0.26061069640293544,
      0.26061069640293544
    ],
    [
      0.29552422471475287,
      0.29552422471475287,
      0.26926671930999635,
      0.26926671930999635,
      0.21908636251598204,
      0.21908636251598204,
      0.1494513491505806,
      0.1494513491505806,
      0.06667134430868814,
      0.06667134430868814
    ],
    [
      0.2729250867779006,
      0.26280454451024665,
      0.26280454451024665,
      0.23319376459199048,
      0.23319376459199048,
      0.18629021092773426,
      0.18629021092773426,
      0.1255803694649046,
      0.1255803694649046,
      0.05566856711617366,
      0.05566856711617366
    ],
    [
      0.24914704581340277,
      0.24914704581340277,
      0.2334925365383548,
      0.2334925365383548,
      0.20316742672306592,
      0.20316742672306592,
      0.16007832854334622,
      0.16007832854334622,
      0.10693932599531843,
      0.10693932599531843,
      0.04717533638651183,
      0.04717533638651183
    ],
    [
      0.2325515532308739,
      0.22628318026289723,
      0.22628318026289723,
      0.2078160475368885,
      0.2078160475368885,
      0.17814598076194574,
      0.17814598076194574,
      0.13887351021978725,
      0.13887351021978725,
      0.09212149983772845,
      0.09212149983772845,
      0.04048400476531588,
      0.04048400476531588
    ],
    [
      0.2152638534631578,
      0.2152638534631578,
      0.2051984637212956,
      0.2051984637212956,
      0.18553839747793782,
      0.18553839747793782,
      0.15720316715819355,
      0.15720316715819355,
      0.12151857068790319,
      0.12151857068790319,
      0.08015808715976021,
      0.08015808715976021,
      0.03511946033175186,
      0.03511946033175186
    ],
    [
      0.2025782419255613,
      0.19843148532711158,
      0.19843148532711158,
      0.1861610000155622,
      0.1861610000155622,
      0.16626920581699392,
      0.16626920581699392,
      0.13957067792615432,
      0.13957067792615432,
      0.10715922046717194,
      0.10715922046717194,
      0.07036604748810812,
      0.07036604748810812,
      0.03075324199611727,
      0.03075324199611727
    ],
    [
      0.1894506104550685,
      0.1894506104550685,
      0.18260341504492358,
      0.18260341504492358,
      0.16915651939500254,
      0.16915651939500254,
      0.14959598881657674,
      0.14959598881657674,
      0.12462897125553388,
      0.12462897125553388,
      0.09515851168249279,
      0.09515851168249279,
      0.062253523938647894,
      0.062253523938647894,
      0.027152459411754096,
      0.027152459411754096
    ],
    [
      0.17944647035620653,
      0.17656270536699264,
      0.17656270536699264,
      0.16800410215645004,
      0.16800410215645004,
      0.15404576107681028,
      0.15404576107681028,
      0.13513636846852548,
      0.13513636846852548,
      0.11188384719340397,
      0.11188384719340397,
      0.08503614831717918,
      0.08503614831717918,
      0.0554595293739872,
      0.0554595293739872,
      0.02414830286854793,
      0.02414830286854793
    ],
    [
      0.1691423829631436,
      0.1691423829631436,
      0.16427648374583273,
      0.16427648374583273,
      0.15468467512626524,
      0.15468467512626524,
      0.14064291467065065,
      0.14064291467065065,
      0.12255520671147846,
      0.12255520671147846,
      0.10094204410628717,
      0.10094204410628717,
      0.07642573025488905,
      0.07642573025488905,
      0.0497145488949698,
      0.0497145488949698,
      0.02161601352648331,
      0.02161601352648331
    ],
    [
      0.1610544498487837,
      0.15896884339395434,
      0.15896884339395434,
      0.15276604206585967,
      0.15276604206585967,
      0.1426067021736066,
      0.1426067021736066,
      0.12875396253933621,
      0.12875396253933621,
      0.11156664554733399,
      0.11156664554733399,
      0.09149002162245,
      0.09149002162245,
      0.06904454273764123,
      0.06904454273764123,
      0.0448142267656996,
      0.0448142267656996,
      0.019461788229726478,
      0.019461788229726478
    ],
    [
      0.15275338713072584,
      0.15275338713072584,
      0.14917298647260374,
      0.14917298647260374,
      0.14209610931838204,
      0.14209610931838204,
      0.13168863844917664,
      0.13168863844917664,
      0.11819453196151841,
      0.11819453196151841,
      0.10193011981724044,
      0.10193011981724044,
      0.08327674157670475,
      0.08327674157670475,
      0.06267204833410907,
      0.06267204833410907,
      0.04060142980038694,
      0.04060142980038694,
      0.017614007139152118,
      0.017614007139152118
    ],
    [
      0.14608113364969041,
      0.14452440398997005,
      0.14452440398997005,
      0.13988739479107315,
      0.13988739479107315,
      0.13226893863333747,
      0.13226893863333747,
      0.12183141605372853,
      0.12183141605372853,
      0.10879729916714838,
      0.10879729916714838,
      0.09344442345603386,
      0.09344442345603386,
      0.0761001136283793,
      0.0761001136283793,
      0.057134425426857205,
      0.057134425426857205,
      0.036953789770852494,
      0.036953789770852494,
      0.016017228257774335,
      0.016017228257774335
    ],
    [
      0.13925187285563198,
      0.13925187285563198,
      0.13654149834601517,
      0.13654149834601517,
      0.13117350478706238,
      0.13117350478706238,
      0.12325237681051242,
      0.12325237681051242,
      0.11293229608053922,
      0.11293229608053922,
      0.10041414444288096,
      0.10041414444288096,
      0.08594160621706773,
      0.08594160621706773,
      0.06979646842452049,
      0.06979646842452049,
      0.052293335152683286,
      0.052293335152683286,
      0.03377490158481415,
      0.03377490158481415,
      0.0146279952982722,
      0.0146279952982722
    ],
    [
      0.13365457218610619,
      0.1324620394046966,
      0.1324620394046966,
      0.12890572218808216,
      0.12890572218808216,
      0.12304908430672953,
      0.12304908430672953,
      0.11499664022241136,
      0.11499664022241136,
      0.10489209146454141,
      0.10489209146454141,
      0.09291576606003515,
      0.09291576606003515,
      0.07928141177671895,
      0.07928141177671895,
      0.06423242140852585,
      0.06423242140852585,
      0.04803767173108467,
      0.04803767173108467,
      0.030988005856979445,
      0.030988005856979445,
      0.013411859487141771,
      0.013411859487141771
    ],
    [
      0.12793819534675216,
      0.12793819534675216,
      0.1258374563468283,
      0.1258374563468283,
      0.12167047292780339,
      0.12167047292780339,
      0.1155056680537256,
      0.1155056680537256,
      0.10744427011596563,
      0.10744427011596563,
      0.09761865210411388,
      0.09761865210411388,
      0.08619016153195327,
      0.08619016153195327,
      0.0733464814110803,
      0.0733464814110803,
      0.05929858491543678,
      0.05929858491543678,
      0.04427743881741981,
      0.04427743881741981,
      0.028531388628933663,
      0.028531388628933663,
      0.0123412297999872,
      0.0123412297999872
    ]
  ], n.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
  const t = (o, a, c) => {
    let l, h, d;
    l = c / 2, h = 0;
    for (let f = 0; f < 20; f++)
      d = l * n.tValues[20][f] + l, h += n.cValues[20][f] * s(o, a, d);
    return l * h;
  };
  n.getCubicArcLength = t;
  const e = (o, a, c) => {
    c === void 0 && (c = 1);
    const l = o[0] - 2 * o[1] + o[2], h = a[0] - 2 * a[1] + a[2], d = 2 * o[1] - 2 * o[0], u = 2 * a[1] - 2 * a[0], f = 4 * (l * l + h * h), p = 4 * (l * d + h * u), m = d * d + u * u;
    if (f === 0)
      return c * Math.sqrt(Math.pow(o[2] - o[0], 2) + Math.pow(a[2] - a[0], 2));
    const _ = p / (2 * f), v = m / f, b = c + _, g = v - _ * _, y = b * b + g > 0 ? Math.sqrt(b * b + g) : 0, S = _ * _ + g > 0 ? Math.sqrt(_ * _ + g) : 0, w = _ + Math.sqrt(_ * _ + g) !== 0 ? g * Math.log(Math.abs((b + y) / (_ + S))) : 0;
    return Math.sqrt(f) / 2 * (b * y - _ * S + w);
  };
  n.getQuadraticArcLength = e;
  function s(o, a, c) {
    const l = i(1, c, o), h = i(1, c, a), d = l * l + h * h;
    return Math.sqrt(d);
  }
  const i = (o, a, c) => {
    const l = c.length - 1;
    let h, d;
    if (l === 0)
      return 0;
    if (o === 0) {
      d = 0;
      for (let u = 0; u <= l; u++)
        d += n.binomialCoefficients[l][u] * Math.pow(1 - a, l - u) * Math.pow(a, u) * c[u];
      return d;
    } else {
      h = new Array(l);
      for (let u = 0; u < l; u++)
        h[u] = l * (c[u + 1] - c[u]);
      return i(o - 1, a, h);
    }
  }, r = (o, a, c) => {
    let l = 1, h = o / a, d = (o - c(h)) / a, u = 0;
    for (; l > 1e-3; ) {
      const f = c(h + d), p = Math.abs(o - f) / a;
      if (p < l)
        l = p, h += d;
      else {
        const m = c(h - d), _ = Math.abs(o - m) / a;
        _ < l ? (l = _, h -= d) : d /= 2;
      }
      if (u++, u > 500)
        break;
    }
    return h;
  };
  n.t2length = r;
})(zm);
Object.defineProperty(Tr, "__esModule", { value: !0 });
Tr.Path = void 0;
const OS = ut, DS = ie, PS = ft, Mi = zm;
class ee extends DS.Shape {
  constructor(t) {
    super(t), this.dataArray = [], this.pathLength = 0, this._readDataAttribute(), this.on("dataChange.konva", function() {
      this._readDataAttribute();
    });
  }
  _readDataAttribute() {
    this.dataArray = ee.parsePathData(this.data()), this.pathLength = ee.getPathLength(this.dataArray);
  }
  _sceneFunc(t) {
    var e = this.dataArray;
    t.beginPath();
    for (var s = !1, i = 0; i < e.length; i++) {
      var r = e[i].command, o = e[i].points;
      switch (r) {
        case "L":
          t.lineTo(o[0], o[1]);
          break;
        case "M":
          t.moveTo(o[0], o[1]);
          break;
        case "C":
          t.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
          break;
        case "Q":
          t.quadraticCurveTo(o[0], o[1], o[2], o[3]);
          break;
        case "A":
          var a = o[0], c = o[1], l = o[2], h = o[3], d = o[4], u = o[5], f = o[6], p = o[7], m = l > h ? l : h, _ = l > h ? 1 : l / h, v = l > h ? h / l : 1;
          t.translate(a, c), t.rotate(f), t.scale(_, v), t.arc(0, 0, m, d, d + u, 1 - p), t.scale(1 / _, 1 / v), t.rotate(-f), t.translate(-a, -c);
          break;
        case "z":
          s = !0, t.closePath();
          break;
      }
    }
    !s && !this.hasFill() ? t.strokeShape(this) : t.fillStrokeShape(this);
  }
  getSelfRect() {
    var t = [];
    this.dataArray.forEach(function(l) {
      if (l.command === "A") {
        var h = l.points[4], d = l.points[5], u = l.points[4] + d, f = Math.PI / 180;
        if (Math.abs(h - u) < f && (f = Math.abs(h - u)), d < 0)
          for (let p = h - f; p > u; p -= f) {
            const m = ee.getPointOnEllipticalArc(l.points[0], l.points[1], l.points[2], l.points[3], p, 0);
            t.push(m.x, m.y);
          }
        else
          for (let p = h + f; p < u; p += f) {
            const m = ee.getPointOnEllipticalArc(l.points[0], l.points[1], l.points[2], l.points[3], p, 0);
            t.push(m.x, m.y);
          }
      } else if (l.command === "C")
        for (let p = 0; p <= 1; p += 0.01) {
          const m = ee.getPointOnCubicBezier(p, l.start.x, l.start.y, l.points[0], l.points[1], l.points[2], l.points[3], l.points[4], l.points[5]);
          t.push(m.x, m.y);
        }
      else
        t = t.concat(l.points);
    });
    for (var e = t[0], s = t[0], i = t[1], r = t[1], o, a, c = 0; c < t.length / 2; c++)
      o = t[c * 2], a = t[c * 2 + 1], isNaN(o) || (e = Math.min(e, o), s = Math.max(s, o)), isNaN(a) || (i = Math.min(i, a), r = Math.max(r, a));
    return {
      x: e,
      y: i,
      width: s - e,
      height: r - i
    };
  }
  getLength() {
    return this.pathLength;
  }
  getPointAtLength(t) {
    return ee.getPointAtLengthOfDataArray(t, this.dataArray);
  }
  static getLineLength(t, e, s, i) {
    return Math.sqrt((s - t) * (s - t) + (i - e) * (i - e));
  }
  static getPathLength(t) {
    let e = 0;
    for (var s = 0; s < t.length; ++s)
      e += t[s].pathLength;
    return e;
  }
  static getPointAtLengthOfDataArray(t, e) {
    var s, i = 0, r = e.length;
    if (!r)
      return null;
    for (; i < r && t > e[i].pathLength; )
      t -= e[i].pathLength, ++i;
    if (i === r)
      return s = e[i - 1].points.slice(-2), {
        x: s[0],
        y: s[1]
      };
    if (t < 0.01)
      return s = e[i].points.slice(0, 2), {
        x: s[0],
        y: s[1]
      };
    var o = e[i], a = o.points;
    switch (o.command) {
      case "L":
        return ee.getPointOnLine(t, o.start.x, o.start.y, a[0], a[1]);
      case "C":
        return ee.getPointOnCubicBezier((0, Mi.t2length)(t, ee.getPathLength(e), (m) => (0, Mi.getCubicArcLength)([o.start.x, a[0], a[2], a[4]], [o.start.y, a[1], a[3], a[5]], m)), o.start.x, o.start.y, a[0], a[1], a[2], a[3], a[4], a[5]);
      case "Q":
        return ee.getPointOnQuadraticBezier((0, Mi.t2length)(t, ee.getPathLength(e), (m) => (0, Mi.getQuadraticArcLength)([o.start.x, a[0], a[2]], [o.start.y, a[1], a[3]], m)), o.start.x, o.start.y, a[0], a[1], a[2], a[3]);
      case "A":
        var c = a[0], l = a[1], h = a[2], d = a[3], u = a[4], f = a[5], p = a[6];
        return u += f * t / o.pathLength, ee.getPointOnEllipticalArc(c, l, h, d, u, p);
    }
    return null;
  }
  static getPointOnLine(t, e, s, i, r, o, a) {
    o === void 0 && (o = e), a === void 0 && (a = s);
    var c = (r - s) / (i - e + 1e-8), l = Math.sqrt(t * t / (1 + c * c));
    i < e && (l *= -1);
    var h = c * l, d;
    if (i === e)
      d = {
        x: o,
        y: a + h
      };
    else if ((a - s) / (o - e + 1e-8) === c)
      d = {
        x: o + l,
        y: a + h
      };
    else {
      var u, f, p = this.getLineLength(e, s, i, r), m = (o - e) * (i - e) + (a - s) * (r - s);
      m = m / (p * p), u = e + m * (i - e), f = s + m * (r - s);
      var _ = this.getLineLength(o, a, u, f), v = Math.sqrt(t * t - _ * _);
      l = Math.sqrt(v * v / (1 + c * c)), i < e && (l *= -1), h = c * l, d = {
        x: u + l,
        y: f + h
      };
    }
    return d;
  }
  static getPointOnCubicBezier(t, e, s, i, r, o, a, c, l) {
    function h(_) {
      return _ * _ * _;
    }
    function d(_) {
      return 3 * _ * _ * (1 - _);
    }
    function u(_) {
      return 3 * _ * (1 - _) * (1 - _);
    }
    function f(_) {
      return (1 - _) * (1 - _) * (1 - _);
    }
    var p = c * h(t) + o * d(t) + i * u(t) + e * f(t), m = l * h(t) + a * d(t) + r * u(t) + s * f(t);
    return {
      x: p,
      y: m
    };
  }
  static getPointOnQuadraticBezier(t, e, s, i, r, o, a) {
    function c(f) {
      return f * f;
    }
    function l(f) {
      return 2 * f * (1 - f);
    }
    function h(f) {
      return (1 - f) * (1 - f);
    }
    var d = o * c(t) + i * l(t) + e * h(t), u = a * c(t) + r * l(t) + s * h(t);
    return {
      x: d,
      y: u
    };
  }
  static getPointOnEllipticalArc(t, e, s, i, r, o) {
    var a = Math.cos(o), c = Math.sin(o), l = {
      x: s * Math.cos(r),
      y: i * Math.sin(r)
    };
    return {
      x: t + (l.x * a - l.y * c),
      y: e + (l.x * c + l.y * a)
    };
  }
  static parsePathData(t) {
    if (!t)
      return [];
    var e = t, s = [
      "m",
      "M",
      "l",
      "L",
      "v",
      "V",
      "h",
      "H",
      "z",
      "Z",
      "c",
      "C",
      "q",
      "Q",
      "t",
      "T",
      "s",
      "S",
      "a",
      "A"
    ];
    e = e.replace(new RegExp(" ", "g"), ",");
    for (var i = 0; i < s.length; i++)
      e = e.replace(new RegExp(s[i], "g"), "|" + s[i]);
    var r = e.split("|"), o = [], a = [], c = 0, l = 0, h = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi, d;
    for (i = 1; i < r.length; i++) {
      var u = r[i], f = u.charAt(0);
      for (u = u.slice(1), a.length = 0; d = h.exec(u); )
        a.push(d[0]);
      for (var p = [], m = 0, _ = a.length; m < _; m++) {
        if (a[m] === "00") {
          p.push(0, 0);
          continue;
        }
        var v = parseFloat(a[m]);
        isNaN(v) ? p.push(0) : p.push(v);
      }
      for (; p.length > 0 && !isNaN(p[0]); ) {
        var b = "", g = [], y = c, S = l, w, k, C, A, E, I, P, M, F, V;
        switch (f) {
          case "l":
            c += p.shift(), l += p.shift(), b = "L", g.push(c, l);
            break;
          case "L":
            c = p.shift(), l = p.shift(), g.push(c, l);
            break;
          case "m":
            var q = p.shift(), ht = p.shift();
            if (c += q, l += ht, b = "M", o.length > 2 && o[o.length - 1].command === "z") {
              for (var rt = o.length - 2; rt >= 0; rt--)
                if (o[rt].command === "M") {
                  c = o[rt].points[0] + q, l = o[rt].points[1] + ht;
                  break;
                }
            }
            g.push(c, l), f = "l";
            break;
          case "M":
            c = p.shift(), l = p.shift(), b = "M", g.push(c, l), f = "L";
            break;
          case "h":
            c += p.shift(), b = "L", g.push(c, l);
            break;
          case "H":
            c = p.shift(), b = "L", g.push(c, l);
            break;
          case "v":
            l += p.shift(), b = "L", g.push(c, l);
            break;
          case "V":
            l = p.shift(), b = "L", g.push(c, l);
            break;
          case "C":
            g.push(p.shift(), p.shift(), p.shift(), p.shift()), c = p.shift(), l = p.shift(), g.push(c, l);
            break;
          case "c":
            g.push(c + p.shift(), l + p.shift(), c + p.shift(), l + p.shift()), c += p.shift(), l += p.shift(), b = "C", g.push(c, l);
            break;
          case "S":
            k = c, C = l, w = o[o.length - 1], w.command === "C" && (k = c + (c - w.points[2]), C = l + (l - w.points[3])), g.push(k, C, p.shift(), p.shift()), c = p.shift(), l = p.shift(), b = "C", g.push(c, l);
            break;
          case "s":
            k = c, C = l, w = o[o.length - 1], w.command === "C" && (k = c + (c - w.points[2]), C = l + (l - w.points[3])), g.push(k, C, c + p.shift(), l + p.shift()), c += p.shift(), l += p.shift(), b = "C", g.push(c, l);
            break;
          case "Q":
            g.push(p.shift(), p.shift()), c = p.shift(), l = p.shift(), g.push(c, l);
            break;
          case "q":
            g.push(c + p.shift(), l + p.shift()), c += p.shift(), l += p.shift(), b = "Q", g.push(c, l);
            break;
          case "T":
            k = c, C = l, w = o[o.length - 1], w.command === "Q" && (k = c + (c - w.points[0]), C = l + (l - w.points[1])), c = p.shift(), l = p.shift(), b = "Q", g.push(k, C, c, l);
            break;
          case "t":
            k = c, C = l, w = o[o.length - 1], w.command === "Q" && (k = c + (c - w.points[0]), C = l + (l - w.points[1])), c += p.shift(), l += p.shift(), b = "Q", g.push(k, C, c, l);
            break;
          case "A":
            A = p.shift(), E = p.shift(), I = p.shift(), P = p.shift(), M = p.shift(), F = c, V = l, c = p.shift(), l = p.shift(), b = "A", g = this.convertEndpointToCenterParameterization(F, V, c, l, P, M, A, E, I);
            break;
          case "a":
            A = p.shift(), E = p.shift(), I = p.shift(), P = p.shift(), M = p.shift(), F = c, V = l, c += p.shift(), l += p.shift(), b = "A", g = this.convertEndpointToCenterParameterization(F, V, c, l, P, M, A, E, I);
            break;
        }
        o.push({
          command: b || f,
          points: g,
          start: {
            x: y,
            y: S
          },
          pathLength: this.calcLength(y, S, b || f, g)
        });
      }
      (f === "z" || f === "Z") && o.push({
        command: "z",
        points: [],
        start: void 0,
        pathLength: 0
      });
    }
    return o;
  }
  static calcLength(t, e, s, i) {
    var r, o, a, c, l = ee;
    switch (s) {
      case "L":
        return l.getLineLength(t, e, i[0], i[1]);
      case "C":
        return (0, Mi.getCubicArcLength)([t, i[0], i[2], i[4]], [e, i[1], i[3], i[5]], 1);
      case "Q":
        return (0, Mi.getQuadraticArcLength)([t, i[0], i[2]], [e, i[1], i[3]], 1);
      case "A":
        r = 0;
        var h = i[4], d = i[5], u = i[4] + d, f = Math.PI / 180;
        if (Math.abs(h - u) < f && (f = Math.abs(h - u)), o = l.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], h, 0), d < 0)
          for (c = h - f; c > u; c -= f)
            a = l.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], c, 0), r += l.getLineLength(o.x, o.y, a.x, a.y), o = a;
        else
          for (c = h + f; c < u; c += f)
            a = l.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], c, 0), r += l.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return a = l.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], u, 0), r += l.getLineLength(o.x, o.y, a.x, a.y), r;
    }
    return 0;
  }
  static convertEndpointToCenterParameterization(t, e, s, i, r, o, a, c, l) {
    var h = l * (Math.PI / 180), d = Math.cos(h) * (t - s) / 2 + Math.sin(h) * (e - i) / 2, u = -1 * Math.sin(h) * (t - s) / 2 + Math.cos(h) * (e - i) / 2, f = d * d / (a * a) + u * u / (c * c);
    f > 1 && (a *= Math.sqrt(f), c *= Math.sqrt(f));
    var p = Math.sqrt((a * a * (c * c) - a * a * (u * u) - c * c * (d * d)) / (a * a * (u * u) + c * c * (d * d)));
    r === o && (p *= -1), isNaN(p) && (p = 0);
    var m = p * a * u / c, _ = p * -c * d / a, v = (t + s) / 2 + Math.cos(h) * m - Math.sin(h) * _, b = (e + i) / 2 + Math.sin(h) * m + Math.cos(h) * _, g = function(E) {
      return Math.sqrt(E[0] * E[0] + E[1] * E[1]);
    }, y = function(E, I) {
      return (E[0] * I[0] + E[1] * I[1]) / (g(E) * g(I));
    }, S = function(E, I) {
      return (E[0] * I[1] < E[1] * I[0] ? -1 : 1) * Math.acos(y(E, I));
    }, w = S([1, 0], [(d - m) / a, (u - _) / c]), k = [(d - m) / a, (u - _) / c], C = [(-1 * d - m) / a, (-1 * u - _) / c], A = S(k, C);
    return y(k, C) <= -1 && (A = Math.PI), y(k, C) >= 1 && (A = 0), o === 0 && A > 0 && (A = A - 2 * Math.PI), o === 1 && A < 0 && (A = A + 2 * Math.PI), [v, b, a, c, w, A, h, o];
  }
}
Tr.Path = ee;
ee.prototype.className = "Path";
ee.prototype._attrsAffectingSize = ["data"];
(0, PS._registerNode)(ee);
OS.Factory.addGetterSetter(ee, "data");
Object.defineProperty(dl, "__esModule", { value: !0 });
dl.Arrow = void 0;
const fl = ut, MS = ea, Wm = z, RS = ft, N0 = Tr;
class Si extends MS.Line {
  _sceneFunc(t) {
    super._sceneFunc(t);
    var e = Math.PI * 2, s = this.points(), i = s, r = this.tension() !== 0 && s.length > 4;
    r && (i = this.getTensionPoints());
    var o = this.pointerLength(), a = s.length, c, l;
    if (r) {
      const u = [
        i[i.length - 4],
        i[i.length - 3],
        i[i.length - 2],
        i[i.length - 1],
        s[a - 2],
        s[a - 1]
      ], f = N0.Path.calcLength(i[i.length - 4], i[i.length - 3], "C", u), p = N0.Path.getPointOnQuadraticBezier(Math.min(1, 1 - o / f), u[0], u[1], u[2], u[3], u[4], u[5]);
      c = s[a - 2] - p.x, l = s[a - 1] - p.y;
    } else
      c = s[a - 2] - s[a - 4], l = s[a - 1] - s[a - 3];
    var h = (Math.atan2(l, c) + e) % e, d = this.pointerWidth();
    this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(s[a - 2], s[a - 1]), t.rotate(h), t.moveTo(0, 0), t.lineTo(-o, d / 2), t.lineTo(-o, -d / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(s[0], s[1]), r ? (c = (i[0] + i[2]) / 2 - s[0], l = (i[1] + i[3]) / 2 - s[1]) : (c = s[2] - s[0], l = s[3] - s[1]), t.rotate((Math.atan2(-l, -c) + e) % e), t.moveTo(0, 0), t.lineTo(-o, d / 2), t.lineTo(-o, -d / 2), t.closePath(), t.restore(), this.__fillStroke(t));
  }
  __fillStroke(t) {
    var e = this.dashEnabled();
    e && (this.attrs.dashEnabled = !1, t.setLineDash([])), t.fillStrokeShape(this), e && (this.attrs.dashEnabled = !0);
  }
  getSelfRect() {
    const t = super.getSelfRect(), e = this.pointerWidth() / 2;
    return {
      x: t.x - e,
      y: t.y - e,
      width: t.width + e * 2,
      height: t.height + e * 2
    };
  }
}
dl.Arrow = Si;
Si.prototype.className = "Arrow";
(0, RS._registerNode)(Si);
fl.Factory.addGetterSetter(Si, "pointerLength", 10, (0, Wm.getNumberValidator)());
fl.Factory.addGetterSetter(Si, "pointerWidth", 10, (0, Wm.getNumberValidator)());
fl.Factory.addGetterSetter(Si, "pointerAtBeginning", !1);
fl.Factory.addGetterSetter(Si, "pointerAtEnding", !0);
var pl = {};
Object.defineProperty(pl, "__esModule", { value: !0 });
pl.Circle = void 0;
const $S = ut, NS = ie, LS = z, US = ft;
class Ar extends NS.Shape {
  _sceneFunc(t) {
    t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(t) {
    this.radius() !== t / 2 && this.radius(t / 2);
  }
  setHeight(t) {
    this.radius() !== t / 2 && this.radius(t / 2);
  }
}
pl.Circle = Ar;
Ar.prototype._centroid = !0;
Ar.prototype.className = "Circle";
Ar.prototype._attrsAffectingSize = ["radius"];
(0, US._registerNode)(Ar);
$S.Factory.addGetterSetter(Ar, "radius", 0, (0, LS.getNumberValidator)());
var gl = {};
Object.defineProperty(gl, "__esModule", { value: !0 });
gl.Ellipse = void 0;
const cf = ut, FS = ie, Km = z, BS = ft;
class Dn extends FS.Shape {
  _sceneFunc(t) {
    var e = this.radiusX(), s = this.radiusY();
    t.beginPath(), t.save(), e !== s && t.scale(1, s / e), t.arc(0, 0, e, 0, Math.PI * 2, !1), t.restore(), t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    return this.radiusX() * 2;
  }
  getHeight() {
    return this.radiusY() * 2;
  }
  setWidth(t) {
    this.radiusX(t / 2);
  }
  setHeight(t) {
    this.radiusY(t / 2);
  }
}
gl.Ellipse = Dn;
Dn.prototype.className = "Ellipse";
Dn.prototype._centroid = !0;
Dn.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
(0, BS._registerNode)(Dn);
cf.Factory.addComponentsGetterSetter(Dn, "radius", ["x", "y"]);
cf.Factory.addGetterSetter(Dn, "radiusX", 0, (0, Km.getNumberValidator)());
cf.Factory.addGetterSetter(Dn, "radiusY", 0, (0, Km.getNumberValidator)());
var ml = {};
Object.defineProperty(ml, "__esModule", { value: !0 });
ml.Image = void 0;
const Ih = Vt, Ci = ut, VS = ie, jS = ft, sa = z;
class Xe extends VS.Shape {
  constructor(t) {
    super(t), this.on("imageChange.konva", () => {
      this._setImageLoad();
    }), this._setImageLoad();
  }
  _setImageLoad() {
    const t = this.image();
    t && t.complete || t && t.readyState === 4 || t && t.addEventListener && t.addEventListener("load", () => {
      this._requestDraw();
    });
  }
  _useBufferCanvas() {
    return super._useBufferCanvas(!0);
  }
  _sceneFunc(t) {
    const e = this.getWidth(), s = this.getHeight(), i = this.cornerRadius(), r = this.attrs.image;
    let o;
    if (r) {
      const a = this.attrs.cropWidth, c = this.attrs.cropHeight;
      a && c ? o = [
        r,
        this.cropX(),
        this.cropY(),
        a,
        c,
        0,
        0,
        e,
        s
      ] : o = [r, 0, 0, e, s];
    }
    (this.hasFill() || this.hasStroke() || i) && (t.beginPath(), i ? Ih.Util.drawRoundedRectPath(t, e, s, i) : t.rect(0, 0, e, s), t.closePath(), t.fillStrokeShape(this)), r && (i && t.clip(), t.drawImage.apply(t, o));
  }
  _hitFunc(t) {
    var e = this.width(), s = this.height(), i = this.cornerRadius();
    t.beginPath(), i ? Ih.Util.drawRoundedRectPath(t, e, s, i) : t.rect(0, 0, e, s), t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    var t, e;
    return (t = this.attrs.width) !== null && t !== void 0 ? t : (e = this.image()) === null || e === void 0 ? void 0 : e.width;
  }
  getHeight() {
    var t, e;
    return (t = this.attrs.height) !== null && t !== void 0 ? t : (e = this.image()) === null || e === void 0 ? void 0 : e.height;
  }
  static fromURL(t, e, s = null) {
    var i = Ih.Util.createImageElement();
    i.onload = function() {
      var r = new Xe({
        image: i
      });
      e(r);
    }, i.onerror = s, i.crossOrigin = "Anonymous", i.src = t;
  }
}
ml.Image = Xe;
Xe.prototype.className = "Image";
(0, jS._registerNode)(Xe);
Ci.Factory.addGetterSetter(Xe, "cornerRadius", 0, (0, sa.getNumberOrArrayOfNumbersValidator)(4));
Ci.Factory.addGetterSetter(Xe, "image");
Ci.Factory.addComponentsGetterSetter(Xe, "crop", ["x", "y", "width", "height"]);
Ci.Factory.addGetterSetter(Xe, "cropX", 0, (0, sa.getNumberValidator)());
Ci.Factory.addGetterSetter(Xe, "cropY", 0, (0, sa.getNumberValidator)());
Ci.Factory.addGetterSetter(Xe, "cropWidth", 0, (0, sa.getNumberValidator)());
Ci.Factory.addGetterSetter(Xe, "cropHeight", 0, (0, sa.getNumberValidator)());
var hr = {};
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.Tag = hr.Label = void 0;
const _l = ut, GS = ie, HS = xr, lf = z, Ym = ft;
var Zm = [
  "fontFamily",
  "fontSize",
  "fontStyle",
  "padding",
  "lineHeight",
  "text",
  "width",
  "height",
  "pointerDirection",
  "pointerWidth",
  "pointerHeight"
], zS = "Change.konva", WS = "none", Fd = "up", Bd = "right", Vd = "down", jd = "left", KS = Zm.length;
class hf extends HS.Group {
  constructor(t) {
    super(t), this.on("add.konva", function(e) {
      this._addListeners(e.child), this._sync();
    });
  }
  getText() {
    return this.find("Text")[0];
  }
  getTag() {
    return this.find("Tag")[0];
  }
  _addListeners(t) {
    var e = this, s, i = function() {
      e._sync();
    };
    for (s = 0; s < KS; s++)
      t.on(Zm[s] + zS, i);
  }
  getWidth() {
    return this.getText().width();
  }
  getHeight() {
    return this.getText().height();
  }
  _sync() {
    var t = this.getText(), e = this.getTag(), s, i, r, o, a, c, l;
    if (t && e) {
      switch (s = t.width(), i = t.height(), r = e.pointerDirection(), o = e.pointerWidth(), l = e.pointerHeight(), a = 0, c = 0, r) {
        case Fd:
          a = s / 2, c = -1 * l;
          break;
        case Bd:
          a = s + o, c = i / 2;
          break;
        case Vd:
          a = s / 2, c = i + l;
          break;
        case jd:
          a = -1 * o, c = i / 2;
          break;
      }
      e.setAttrs({
        x: -1 * a,
        y: -1 * c,
        width: s,
        height: i
      }), t.setAttrs({
        x: -1 * a,
        y: -1 * c
      });
    }
  }
}
hr.Label = hf;
hf.prototype.className = "Label";
(0, Ym._registerNode)(hf);
class ki extends GS.Shape {
  _sceneFunc(t) {
    var e = this.width(), s = this.height(), i = this.pointerDirection(), r = this.pointerWidth(), o = this.pointerHeight(), a = this.cornerRadius();
    let c = 0, l = 0, h = 0, d = 0;
    typeof a == "number" ? c = l = h = d = Math.min(a, e / 2, s / 2) : (c = Math.min(a[0] || 0, e / 2, s / 2), l = Math.min(a[1] || 0, e / 2, s / 2), d = Math.min(a[2] || 0, e / 2, s / 2), h = Math.min(a[3] || 0, e / 2, s / 2)), t.beginPath(), t.moveTo(c, 0), i === Fd && (t.lineTo((e - r) / 2, 0), t.lineTo(e / 2, -1 * o), t.lineTo((e + r) / 2, 0)), t.lineTo(e - l, 0), t.arc(e - l, l, l, Math.PI * 3 / 2, 0, !1), i === Bd && (t.lineTo(e, (s - o) / 2), t.lineTo(e + r, s / 2), t.lineTo(e, (s + o) / 2)), t.lineTo(e, s - d), t.arc(e - d, s - d, d, 0, Math.PI / 2, !1), i === Vd && (t.lineTo((e + r) / 2, s), t.lineTo(e / 2, s + o), t.lineTo((e - r) / 2, s)), t.lineTo(h, s), t.arc(h, s - h, h, Math.PI / 2, Math.PI, !1), i === jd && (t.lineTo(0, (s + o) / 2), t.lineTo(-1 * r, s / 2), t.lineTo(0, (s - o) / 2)), t.lineTo(0, c), t.arc(c, c, c, Math.PI, Math.PI * 3 / 2, !1), t.closePath(), t.fillStrokeShape(this);
  }
  getSelfRect() {
    var t = 0, e = 0, s = this.pointerWidth(), i = this.pointerHeight(), r = this.pointerDirection(), o = this.width(), a = this.height();
    return r === Fd ? (e -= i, a += i) : r === Vd ? a += i : r === jd ? (t -= s * 1.5, o += s) : r === Bd && (o += s * 1.5), {
      x: t,
      y: e,
      width: o,
      height: a
    };
  }
}
hr.Tag = ki;
ki.prototype.className = "Tag";
(0, Ym._registerNode)(ki);
_l.Factory.addGetterSetter(ki, "pointerDirection", WS);
_l.Factory.addGetterSetter(ki, "pointerWidth", 0, (0, lf.getNumberValidator)());
_l.Factory.addGetterSetter(ki, "pointerHeight", 0, (0, lf.getNumberValidator)());
_l.Factory.addGetterSetter(ki, "cornerRadius", 0, (0, lf.getNumberOrArrayOfNumbersValidator)(4));
var na = {};
Object.defineProperty(na, "__esModule", { value: !0 });
na.Rect = void 0;
const YS = ut, ZS = ie, qS = ft, XS = Vt, JS = z;
class yl extends ZS.Shape {
  _sceneFunc(t) {
    var e = this.cornerRadius(), s = this.width(), i = this.height();
    t.beginPath(), e ? XS.Util.drawRoundedRectPath(t, s, i, e) : t.rect(0, 0, s, i), t.closePath(), t.fillStrokeShape(this);
  }
}
na.Rect = yl;
yl.prototype.className = "Rect";
(0, qS._registerNode)(yl);
YS.Factory.addGetterSetter(yl, "cornerRadius", 0, (0, JS.getNumberOrArrayOfNumbersValidator)(4));
var vl = {};
Object.defineProperty(vl, "__esModule", { value: !0 });
vl.RegularPolygon = void 0;
const qm = ut, QS = ie, Xm = z, tC = ft;
class xi extends QS.Shape {
  _sceneFunc(t) {
    const e = this._getPoints();
    t.beginPath(), t.moveTo(e[0].x, e[0].y);
    for (var s = 1; s < e.length; s++)
      t.lineTo(e[s].x, e[s].y);
    t.closePath(), t.fillStrokeShape(this);
  }
  _getPoints() {
    const t = this.attrs.sides, e = this.attrs.radius || 0, s = [];
    for (var i = 0; i < t; i++)
      s.push({
        x: e * Math.sin(i * 2 * Math.PI / t),
        y: -1 * e * Math.cos(i * 2 * Math.PI / t)
      });
    return s;
  }
  getSelfRect() {
    const t = this._getPoints();
    var e = t[0].x, s = t[0].y, i = t[0].x, r = t[0].y;
    return t.forEach((o) => {
      e = Math.min(e, o.x), s = Math.max(s, o.x), i = Math.min(i, o.y), r = Math.max(r, o.y);
    }), {
      x: e,
      y: i,
      width: s - e,
      height: r - i
    };
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(t) {
    this.radius(t / 2);
  }
  setHeight(t) {
    this.radius(t / 2);
  }
}
vl.RegularPolygon = xi;
xi.prototype.className = "RegularPolygon";
xi.prototype._centroid = !0;
xi.prototype._attrsAffectingSize = ["radius"];
(0, tC._registerNode)(xi);
qm.Factory.addGetterSetter(xi, "radius", 0, (0, Xm.getNumberValidator)());
qm.Factory.addGetterSetter(xi, "sides", 0, (0, Xm.getNumberValidator)());
var bl = {};
Object.defineProperty(bl, "__esModule", { value: !0 });
bl.Ring = void 0;
const Jm = ut, eC = ie, Qm = z, sC = ft;
var L0 = Math.PI * 2;
class Ei extends eC.Shape {
  _sceneFunc(t) {
    t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, L0, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), L0, 0, !0), t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(t) {
    this.outerRadius(t / 2);
  }
  setHeight(t) {
    this.outerRadius(t / 2);
  }
}
bl.Ring = Ei;
Ei.prototype.className = "Ring";
Ei.prototype._centroid = !0;
Ei.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
(0, sC._registerNode)(Ei);
Jm.Factory.addGetterSetter(Ei, "innerRadius", 0, (0, Qm.getNumberValidator)());
Jm.Factory.addGetterSetter(Ei, "outerRadius", 0, (0, Qm.getNumberValidator)());
var wl = {};
Object.defineProperty(wl, "__esModule", { value: !0 });
wl.Sprite = void 0;
const Ti = ut, nC = ie, iC = Er, t_ = z, rC = ft;
class Ts extends nC.Shape {
  constructor(t) {
    super(t), this._updated = !0, this.anim = new iC.Animation(() => {
      var e = this._updated;
      return this._updated = !1, e;
    }), this.on("animationChange.konva", function() {
      this.frameIndex(0);
    }), this.on("frameIndexChange.konva", function() {
      this._updated = !0;
    }), this.on("frameRateChange.konva", function() {
      this.anim.isRunning() && (clearInterval(this.interval), this._setInterval());
    });
  }
  _sceneFunc(t) {
    var e = this.animation(), s = this.frameIndex(), i = s * 4, r = this.animations()[e], o = this.frameOffsets(), a = r[i + 0], c = r[i + 1], l = r[i + 2], h = r[i + 3], d = this.image();
    if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, l, h), t.closePath(), t.fillStrokeShape(this)), d)
      if (o) {
        var u = o[e], f = s * 2;
        t.drawImage(d, a, c, l, h, u[f + 0], u[f + 1], l, h);
      } else
        t.drawImage(d, a, c, l, h, 0, 0, l, h);
  }
  _hitFunc(t) {
    var e = this.animation(), s = this.frameIndex(), i = s * 4, r = this.animations()[e], o = this.frameOffsets(), a = r[i + 2], c = r[i + 3];
    if (t.beginPath(), o) {
      var l = o[e], h = s * 2;
      t.rect(l[h + 0], l[h + 1], a, c);
    } else
      t.rect(0, 0, a, c);
    t.closePath(), t.fillShape(this);
  }
  _useBufferCanvas() {
    return super._useBufferCanvas(!0);
  }
  _setInterval() {
    var t = this;
    this.interval = setInterval(function() {
      t._updateIndex();
    }, 1e3 / this.frameRate());
  }
  start() {
    if (!this.isRunning()) {
      var t = this.getLayer();
      this.anim.setLayers(t), this._setInterval(), this.anim.start();
    }
  }
  stop() {
    this.anim.stop(), clearInterval(this.interval);
  }
  isRunning() {
    return this.anim.isRunning();
  }
  _updateIndex() {
    var t = this.frameIndex(), e = this.animation(), s = this.animations(), i = s[e], r = i.length / 4;
    t < r - 1 ? this.frameIndex(t + 1) : this.frameIndex(0);
  }
}
wl.Sprite = Ts;
Ts.prototype.className = "Sprite";
(0, rC._registerNode)(Ts);
Ti.Factory.addGetterSetter(Ts, "animation");
Ti.Factory.addGetterSetter(Ts, "animations");
Ti.Factory.addGetterSetter(Ts, "frameOffsets");
Ti.Factory.addGetterSetter(Ts, "image");
Ti.Factory.addGetterSetter(Ts, "frameIndex", 0, (0, t_.getNumberValidator)());
Ti.Factory.addGetterSetter(Ts, "frameRate", 17, (0, t_.getNumberValidator)());
Ti.Factory.backCompat(Ts, {
  index: "frameIndex",
  getIndex: "getFrameIndex",
  setIndex: "setFrameIndex"
});
var Sl = {};
Object.defineProperty(Sl, "__esModule", { value: !0 });
Sl.Star = void 0;
const df = ut, oC = ie, uf = z, aC = ft;
class Pn extends oC.Shape {
  _sceneFunc(t) {
    var e = this.innerRadius(), s = this.outerRadius(), i = this.numPoints();
    t.beginPath(), t.moveTo(0, 0 - s);
    for (var r = 1; r < i * 2; r++) {
      var o = r % 2 === 0 ? s : e, a = o * Math.sin(r * Math.PI / i), c = -1 * o * Math.cos(r * Math.PI / i);
      t.lineTo(a, c);
    }
    t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    return this.outerRadius() * 2;
  }
  getHeight() {
    return this.outerRadius() * 2;
  }
  setWidth(t) {
    this.outerRadius(t / 2);
  }
  setHeight(t) {
    this.outerRadius(t / 2);
  }
}
Sl.Star = Pn;
Pn.prototype.className = "Star";
Pn.prototype._centroid = !0;
Pn.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
(0, aC._registerNode)(Pn);
df.Factory.addGetterSetter(Pn, "numPoints", 5, (0, uf.getNumberValidator)());
df.Factory.addGetterSetter(Pn, "innerRadius", 0, (0, uf.getNumberValidator)());
df.Factory.addGetterSetter(Pn, "outerRadius", 0, (0, uf.getNumberValidator)());
var ci = {};
Object.defineProperty(ci, "__esModule", { value: !0 });
ci.Text = ci.stringToArray = void 0;
const Gd = Vt, Se = ut, cC = ie, Mn = z, lC = ft;
function e_(n) {
  return Array.from(n);
}
ci.stringToArray = e_;
var Ri = "auto", hC = "center", s_ = "inherit", Lr = "justify", dC = "Change.konva", uC = "2d", U0 = "-", n_ = "left", fC = "text", pC = "Text", gC = "top", mC = "bottom", F0 = "middle", i_ = "normal", _C = "px ", ka = " ", yC = "right", B0 = "rtl", vC = "word", bC = "char", V0 = "none", Oh = "", r_ = [
  "direction",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "padding",
  "align",
  "verticalAlign",
  "lineHeight",
  "text",
  "width",
  "height",
  "wrap",
  "ellipsis",
  "letterSpacing"
], wC = r_.length;
function SC(n) {
  return n.split(",").map((t) => {
    t = t.trim();
    const e = t.indexOf(" ") >= 0, s = t.indexOf('"') >= 0 || t.indexOf("'") >= 0;
    return e && !s && (t = `"${t}"`), t;
  }).join(", ");
}
var xa;
function Dh() {
  return xa || (xa = Gd.Util.createCanvasElement().getContext(uC), xa);
}
function CC(n) {
  n.fillText(this._partialText, this._partialTextX, this._partialTextY);
}
function kC(n) {
  n.setAttr("miterLimit", 2), n.strokeText(this._partialText, this._partialTextX, this._partialTextY);
}
function xC(n) {
  return n = n || {}, !n.fillLinearGradientColorStops && !n.fillRadialGradientColorStops && !n.fillPatternImage && (n.fill = n.fill || "black"), n;
}
class Ht extends cC.Shape {
  constructor(t) {
    super(xC(t)), this._partialTextX = 0, this._partialTextY = 0;
    for (var e = 0; e < wC; e++)
      this.on(r_[e] + dC, this._setTextData);
    this._setTextData();
  }
  _sceneFunc(t) {
    var e = this.textArr, s = e.length;
    if (this.text()) {
      var i = this.padding(), r = this.fontSize(), o = this.lineHeight() * r, a = this.verticalAlign(), c = this.direction(), l = 0, h = this.align(), d = this.getWidth(), u = this.letterSpacing(), f = this.fill(), p = this.textDecoration(), m = p.indexOf("underline") !== -1, _ = p.indexOf("line-through") !== -1, v;
      c = c === s_ ? t.direction : c;
      var b = 0, b = o / 2, g = 0, y = 0;
      for (c === B0 && t.setAttr("direction", c), t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", F0), t.setAttr("textAlign", n_), a === F0 ? l = (this.getHeight() - s * o - i * 2) / 2 : a === mC && (l = this.getHeight() - s * o - i * 2), t.translate(i, l + i), v = 0; v < s; v++) {
        var g = 0, y = 0, S = e[v], w = S.text, k = S.width, C = S.lastInParagraph, A, E, I;
        if (t.save(), h === yC ? g += d - k - i * 2 : h === hC && (g += (d - k - i * 2) / 2), m) {
          t.save(), t.beginPath(), t.moveTo(g, b + y + Math.round(r / 2)), A = w.split(" ").length - 1, E = A === 0, I = h === Lr && !C ? d - i * 2 : k, t.lineTo(g + Math.round(I), b + y + Math.round(r / 2)), t.lineWidth = r / 15;
          const ht = this._getLinearGradient();
          t.strokeStyle = ht || f, t.stroke(), t.restore();
        }
        if (_) {
          t.save(), t.beginPath(), t.moveTo(g, b + y), A = w.split(" ").length - 1, E = A === 0, I = h === Lr && C && !E ? d - i * 2 : k, t.lineTo(g + Math.round(I), b + y), t.lineWidth = r / 15;
          const ht = this._getLinearGradient();
          t.strokeStyle = ht || f, t.stroke(), t.restore();
        }
        if (c !== B0 && (u !== 0 || h === Lr)) {
          A = w.split(" ").length - 1;
          for (var P = e_(w), M = 0; M < P.length; M++) {
            var F = P[M];
            F === " " && !C && h === Lr && (g += (d - i * 2 - k) / A), this._partialTextX = g, this._partialTextY = b + y, this._partialText = F, t.fillStrokeShape(this), g += this.measureSize(F).width + u;
          }
        } else
          u !== 0 && t.setAttr("letterSpacing", `${u}px`), this._partialTextX = g, this._partialTextY = b + y, this._partialText = w, t.fillStrokeShape(this);
        t.restore(), s > 1 && (b += o);
      }
    }
  }
  _hitFunc(t) {
    var e = this.getWidth(), s = this.getHeight();
    t.beginPath(), t.rect(0, 0, e, s), t.closePath(), t.fillStrokeShape(this);
  }
  setText(t) {
    var e = Gd.Util._isString(t) ? t : t == null ? "" : t + "";
    return this._setAttr(fC, e), this;
  }
  getWidth() {
    var t = this.attrs.width === Ri || this.attrs.width === void 0;
    return t ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
  }
  getHeight() {
    var t = this.attrs.height === Ri || this.attrs.height === void 0;
    return t ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    return Gd.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
  }
  measureSize(t) {
    var e = Dh(), s = this.fontSize(), i;
    return e.save(), e.font = this._getContextFont(), i = e.measureText(t), e.restore(), {
      width: i.width,
      height: s
    };
  }
  _getContextFont() {
    return this.fontStyle() + ka + this.fontVariant() + ka + (this.fontSize() + _C) + SC(this.fontFamily());
  }
  _addTextLine(t) {
    this.align() === Lr && (t = t.trim());
    var s = this._getTextWidth(t);
    return this.textArr.push({
      text: t,
      width: s,
      lastInParagraph: !1
    });
  }
  _getTextWidth(t) {
    var e = this.letterSpacing(), s = t.length;
    return Dh().measureText(t).width + (s ? e * (s - 1) : 0);
  }
  _setTextData() {
    var t = this.text().split(`
`), e = +this.fontSize(), s = 0, i = this.lineHeight() * e, r = this.attrs.width, o = this.attrs.height, a = r !== Ri && r !== void 0, c = o !== Ri && o !== void 0, l = this.padding(), h = r - l * 2, d = o - l * 2, u = 0, f = this.wrap(), p = f !== V0, m = f !== bC && p, _ = this.ellipsis();
    this.textArr = [], Dh().font = this._getContextFont();
    for (var v = _ ? this._getTextWidth(Oh) : 0, b = 0, g = t.length; b < g; ++b) {
      var y = t[b], S = this._getTextWidth(y);
      if (a && S > h)
        for (; y.length > 0; ) {
          for (var w = 0, k = y.length, C = "", A = 0; w < k; ) {
            var E = w + k >>> 1, I = y.slice(0, E + 1), P = this._getTextWidth(I) + v;
            P <= h ? (w = E + 1, C = I, A = P) : k = E;
          }
          if (C) {
            if (m) {
              var M, F = y[C.length], V = F === ka || F === U0;
              V && A <= h ? M = C.length : M = Math.max(C.lastIndexOf(ka), C.lastIndexOf(U0)) + 1, M > 0 && (w = M, C = C.slice(0, w), A = this._getTextWidth(C));
            }
            C = C.trimRight(), this._addTextLine(C), s = Math.max(s, A), u += i;
            var q = this._shouldHandleEllipsis(u);
            if (q) {
              this._tryToAddEllipsisToLastLine();
              break;
            }
            if (y = y.slice(w), y = y.trimLeft(), y.length > 0 && (S = this._getTextWidth(y), S <= h)) {
              this._addTextLine(y), u += i, s = Math.max(s, S);
              break;
            }
          } else
            break;
        }
      else
        this._addTextLine(y), u += i, s = Math.max(s, S), this._shouldHandleEllipsis(u) && b < g - 1 && this._tryToAddEllipsisToLastLine();
      if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), c && u + i > d)
        break;
    }
    this.textHeight = e, this.textWidth = s;
  }
  _shouldHandleEllipsis(t) {
    var e = +this.fontSize(), s = this.lineHeight() * e, i = this.attrs.height, r = i !== Ri && i !== void 0, o = this.padding(), a = i - o * 2, c = this.wrap(), l = c !== V0;
    return !l || r && t + s > a;
  }
  _tryToAddEllipsisToLastLine() {
    var t = this.attrs.width, e = t !== Ri && t !== void 0, s = this.padding(), i = t - s * 2, r = this.ellipsis(), o = this.textArr[this.textArr.length - 1];
    if (!(!o || !r)) {
      if (e) {
        var a = this._getTextWidth(o.text + Oh) < i;
        a || (o.text = o.text.slice(0, o.text.length - 3));
      }
      this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(o.text + Oh);
    }
  }
  getStrokeScaleEnabled() {
    return !0;
  }
  _useBufferCanvas() {
    const t = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1, e = this.hasShadow();
    return t && e ? !0 : super._useBufferCanvas();
  }
}
ci.Text = Ht;
Ht.prototype._fillFunc = CC;
Ht.prototype._strokeFunc = kC;
Ht.prototype.className = pC;
Ht.prototype._attrsAffectingSize = [
  "text",
  "fontSize",
  "padding",
  "wrap",
  "lineHeight",
  "letterSpacing"
];
(0, lC._registerNode)(Ht);
Se.Factory.overWriteSetter(Ht, "width", (0, Mn.getNumberOrAutoValidator)());
Se.Factory.overWriteSetter(Ht, "height", (0, Mn.getNumberOrAutoValidator)());
Se.Factory.addGetterSetter(Ht, "direction", s_);
Se.Factory.addGetterSetter(Ht, "fontFamily", "Arial");
Se.Factory.addGetterSetter(Ht, "fontSize", 12, (0, Mn.getNumberValidator)());
Se.Factory.addGetterSetter(Ht, "fontStyle", i_);
Se.Factory.addGetterSetter(Ht, "fontVariant", i_);
Se.Factory.addGetterSetter(Ht, "padding", 0, (0, Mn.getNumberValidator)());
Se.Factory.addGetterSetter(Ht, "align", n_);
Se.Factory.addGetterSetter(Ht, "verticalAlign", gC);
Se.Factory.addGetterSetter(Ht, "lineHeight", 1, (0, Mn.getNumberValidator)());
Se.Factory.addGetterSetter(Ht, "wrap", vC);
Se.Factory.addGetterSetter(Ht, "ellipsis", !1, (0, Mn.getBooleanValidator)());
Se.Factory.addGetterSetter(Ht, "letterSpacing", 0, (0, Mn.getNumberValidator)());
Se.Factory.addGetterSetter(Ht, "text", "", (0, Mn.getStringValidator)());
Se.Factory.addGetterSetter(Ht, "textDecoration", "");
var Cl = {};
Object.defineProperty(Cl, "__esModule", { value: !0 });
Cl.TextPath = void 0;
const Ph = Vt, us = ut, EC = ie, Ur = Tr, Mh = ci, o_ = z, TC = ft;
var AC = "", a_ = "normal";
function c_(n) {
  n.fillText(this.partialText, 0, 0);
}
function l_(n) {
  n.strokeText(this.partialText, 0, 0);
}
class re extends EC.Shape {
  constructor(t) {
    super(t), this.dummyCanvas = Ph.Util.createCanvasElement(), this.dataArray = [], this._readDataAttribute(), this.on("dataChange.konva", function() {
      this._readDataAttribute(), this._setTextData();
    }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData();
  }
  _getTextPathLength() {
    return Ur.Path.getPathLength(this.dataArray);
  }
  _getPointAtLength(t) {
    if (!this.attrs.data)
      return null;
    const e = this.pathLength;
    return t - 1 > e ? null : Ur.Path.getPointAtLengthOfDataArray(t, this.dataArray);
  }
  _readDataAttribute() {
    this.dataArray = Ur.Path.parsePathData(this.attrs.data), this.pathLength = this._getTextPathLength();
  }
  _sceneFunc(t) {
    t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save();
    var e = this.textDecoration(), s = this.fill(), i = this.fontSize(), r = this.glyphInfo;
    e === "underline" && t.beginPath();
    for (var o = 0; o < r.length; o++) {
      t.save();
      var a = r[o].p0;
      t.translate(a.x, a.y), t.rotate(r[o].rotation), this.partialText = r[o].text, t.fillStrokeShape(this), e === "underline" && (o === 0 && t.moveTo(0, i / 2 + 1), t.lineTo(i, i / 2 + 1)), t.restore();
    }
    e === "underline" && (t.strokeStyle = s, t.lineWidth = i / 20, t.stroke()), t.restore();
  }
  _hitFunc(t) {
    t.beginPath();
    var e = this.glyphInfo;
    if (e.length >= 1) {
      var s = e[0].p0;
      t.moveTo(s.x, s.y);
    }
    for (var i = 0; i < e.length; i++) {
      var r = e[i].p1;
      t.lineTo(r.x, r.y);
    }
    t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke();
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    return Ph.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
  }
  setText(t) {
    return Mh.Text.prototype.setText.call(this, t);
  }
  _getContextFont() {
    return Mh.Text.prototype._getContextFont.call(this);
  }
  _getTextSize(t) {
    var e = this.dummyCanvas, s = e.getContext("2d");
    s.save(), s.font = this._getContextFont();
    var i = s.measureText(t);
    return s.restore(), {
      width: i.width,
      height: parseInt(`${this.fontSize()}`, 10)
    };
  }
  _setTextData() {
    const { width: t, height: e } = this._getTextSize(this.attrs.text);
    if (this.textWidth = t, this.textHeight = e, this.glyphInfo = [], !this.attrs.data)
      return null;
    const s = this.letterSpacing(), i = this.align(), r = this.kerningFunc(), o = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * s, 0);
    let a = 0;
    i === "center" && (a = Math.max(0, this.pathLength / 2 - o / 2)), i === "right" && (a = Math.max(0, this.pathLength - o));
    const c = (0, Mh.stringToArray)(this.text());
    let l = a;
    for (var h = 0; h < c.length; h++) {
      const d = this._getPointAtLength(l);
      if (!d)
        return;
      let u = this._getTextSize(c[h]).width + s;
      if (c[h] === " " && i === "justify") {
        const b = this.text().split(" ").length - 1;
        u += (this.pathLength - o) / b;
      }
      const f = this._getPointAtLength(l + u);
      if (!f)
        return;
      const p = Ur.Path.getLineLength(d.x, d.y, f.x, f.y);
      let m = 0;
      if (r)
        try {
          m = r(c[h - 1], c[h]) * this.fontSize();
        } catch {
          m = 0;
        }
      d.x += m, f.x += m, this.textWidth += m;
      const _ = Ur.Path.getPointOnLine(m + p / 2, d.x, d.y, f.x, f.y), v = Math.atan2(f.y - d.y, f.x - d.x);
      this.glyphInfo.push({
        transposeX: _.x,
        transposeY: _.y,
        text: c[h],
        rotation: v,
        p0: d,
        p1: f
      }), l += u;
    }
  }
  getSelfRect() {
    if (!this.glyphInfo.length)
      return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    var t = [];
    this.glyphInfo.forEach(function(h) {
      t.push(h.p0.x), t.push(h.p0.y), t.push(h.p1.x), t.push(h.p1.y);
    });
    for (var e = t[0] || 0, s = t[0] || 0, i = t[1] || 0, r = t[1] || 0, o, a, c = 0; c < t.length / 2; c++)
      o = t[c * 2], a = t[c * 2 + 1], e = Math.min(e, o), s = Math.max(s, o), i = Math.min(i, a), r = Math.max(r, a);
    var l = this.fontSize();
    return {
      x: e - l / 2,
      y: i - l / 2,
      width: s - e + l,
      height: r - i + l
    };
  }
  destroy() {
    return Ph.Util.releaseCanvas(this.dummyCanvas), super.destroy();
  }
}
Cl.TextPath = re;
re.prototype._fillFunc = c_;
re.prototype._strokeFunc = l_;
re.prototype._fillFuncHit = c_;
re.prototype._strokeFuncHit = l_;
re.prototype.className = "TextPath";
re.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
(0, TC._registerNode)(re);
us.Factory.addGetterSetter(re, "data");
us.Factory.addGetterSetter(re, "fontFamily", "Arial");
us.Factory.addGetterSetter(re, "fontSize", 12, (0, o_.getNumberValidator)());
us.Factory.addGetterSetter(re, "fontStyle", a_);
us.Factory.addGetterSetter(re, "align", "left");
us.Factory.addGetterSetter(re, "letterSpacing", 0, (0, o_.getNumberValidator)());
us.Factory.addGetterSetter(re, "textBaseline", "middle");
us.Factory.addGetterSetter(re, "fontVariant", a_);
us.Factory.addGetterSetter(re, "text", AC);
us.Factory.addGetterSetter(re, "textDecoration", null);
us.Factory.addGetterSetter(re, "kerningFunc", null);
var kl = {};
Object.defineProperty(kl, "__esModule", { value: !0 });
kl.Transformer = void 0;
const Et = Vt, wt = ut, j0 = Nt, IC = ie, OC = na, G0 = xr, ts = ft, Rn = z, DC = ft;
var h_ = "tr-konva", PC = [
  "resizeEnabledChange",
  "rotateAnchorOffsetChange",
  "rotateEnabledChange",
  "enabledAnchorsChange",
  "anchorSizeChange",
  "borderEnabledChange",
  "borderStrokeChange",
  "borderStrokeWidthChange",
  "borderDashChange",
  "anchorStrokeChange",
  "anchorStrokeWidthChange",
  "anchorFillChange",
  "anchorCornerRadiusChange",
  "ignoreStrokeChange",
  "anchorStyleFuncChange"
].map((n) => n + `.${h_}`).join(" "), H0 = "nodesRect", MC = [
  "widthChange",
  "heightChange",
  "scaleXChange",
  "scaleYChange",
  "skewXChange",
  "skewYChange",
  "rotationChange",
  "offsetXChange",
  "offsetYChange",
  "transformsEnabledChange",
  "strokeWidthChange"
], RC = {
  "top-left": -45,
  "top-center": 0,
  "top-right": 45,
  "middle-right": -90,
  "middle-left": 90,
  "bottom-left": -135,
  "bottom-center": 180,
  "bottom-right": 135
};
const $C = "ontouchstart" in ts.Konva._global;
function NC(n, t, e) {
  if (n === "rotater")
    return e;
  t += Et.Util.degToRad(RC[n] || 0);
  var s = (Et.Util.radToDeg(t) % 360 + 360) % 360;
  return Et.Util._inRange(s, 315 + 22.5, 360) || Et.Util._inRange(s, 0, 22.5) ? "ns-resize" : Et.Util._inRange(s, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : Et.Util._inRange(s, 90 - 22.5, 90 + 22.5) ? "ew-resize" : Et.Util._inRange(s, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : Et.Util._inRange(s, 180 - 22.5, 180 + 22.5) ? "ns-resize" : Et.Util._inRange(s, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : Et.Util._inRange(s, 270 - 22.5, 270 + 22.5) ? "ew-resize" : Et.Util._inRange(s, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (Et.Util.error("Transformer has unknown angle for cursor detection: " + s), "pointer");
}
var fc = [
  "top-left",
  "top-center",
  "top-right",
  "middle-right",
  "middle-left",
  "bottom-left",
  "bottom-center",
  "bottom-right"
], z0 = 1e8;
function LC(n) {
  return {
    x: n.x + n.width / 2 * Math.cos(n.rotation) + n.height / 2 * Math.sin(-n.rotation),
    y: n.y + n.height / 2 * Math.cos(n.rotation) + n.width / 2 * Math.sin(n.rotation)
  };
}
function d_(n, t, e) {
  const s = e.x + (n.x - e.x) * Math.cos(t) - (n.y - e.y) * Math.sin(t), i = e.y + (n.x - e.x) * Math.sin(t) + (n.y - e.y) * Math.cos(t);
  return {
    ...n,
    rotation: n.rotation + t,
    x: s,
    y: i
  };
}
function UC(n, t) {
  const e = LC(n);
  return d_(n, t, e);
}
function FC(n, t, e) {
  let s = t;
  for (let i = 0; i < n.length; i++) {
    const r = ts.Konva.getAngle(n[i]), o = Math.abs(r - t) % (Math.PI * 2);
    Math.min(o, Math.PI * 2 - o) < e && (s = r);
  }
  return s;
}
let Hd = 0;
class mt extends G0.Group {
  constructor(t) {
    super(t), this._movingAnchorName = null, this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(PC, this.update), this.getNode() && this.update();
  }
  attachTo(t) {
    return this.setNode(t), this;
  }
  setNode(t) {
    return Et.Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t]);
  }
  getNode() {
    return this._nodes && this._nodes[0];
  }
  _getEventNamespace() {
    return h_ + this._id;
  }
  setNodes(t = []) {
    this._nodes && this._nodes.length && this.detach();
    const e = t.filter((i) => i.isAncestorOf(this) ? (Et.Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
    this._nodes = t = e, t.length === 1 && this.useSingleNodeRotation() ? this.rotation(t[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach((i) => {
      const r = () => {
        this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update();
      }, o = i._attrsAffectingSize.map((a) => a + "Change." + this._getEventNamespace()).join(" ");
      i.on(o, r), i.on(MC.map((a) => a + `.${this._getEventNamespace()}`).join(" "), r), i.on(`absoluteTransformChange.${this._getEventNamespace()}`, r), this._proxyDrag(i);
    }), this._resetTransformCache();
    var s = !!this.findOne(".top-left");
    return s && this.update(), this;
  }
  _proxyDrag(t) {
    let e;
    t.on(`dragstart.${this._getEventNamespace()}`, (s) => {
      e = t.getAbsolutePosition(), !this.isDragging() && t !== this.findOne(".back") && this.startDrag(s, !1);
    }), t.on(`dragmove.${this._getEventNamespace()}`, (s) => {
      if (!e)
        return;
      const i = t.getAbsolutePosition(), r = i.x - e.x, o = i.y - e.y;
      this.nodes().forEach((a) => {
        if (a === t || a.isDragging())
          return;
        const c = a.getAbsolutePosition();
        a.setAbsolutePosition({
          x: c.x + r,
          y: c.y + o
        }), a.startDrag(s);
      }), e = null;
    });
  }
  getNodes() {
    return this._nodes || [];
  }
  getActiveAnchor() {
    return this._movingAnchorName;
  }
  detach() {
    this._nodes && this._nodes.forEach((t) => {
      t.off("." + this._getEventNamespace());
    }), this._nodes = [], this._resetTransformCache();
  }
  _resetTransformCache() {
    this._clearCache(H0), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform");
  }
  _getNodeRect() {
    return this._getCache(H0, this.__getNodeRect);
  }
  __getNodeShape(t, e = this.rotation(), s) {
    var i = t.getClientRect({
      skipTransform: !0,
      skipShadow: !0,
      skipStroke: this.ignoreStroke()
    }), r = t.getAbsoluteScale(s), o = t.getAbsolutePosition(s), a = i.x * r.x - t.offsetX() * r.x, c = i.y * r.y - t.offsetY() * r.y;
    const l = (ts.Konva.getAngle(t.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2), h = {
      x: o.x + a * Math.cos(l) + c * Math.sin(-l),
      y: o.y + c * Math.cos(l) + a * Math.sin(l),
      width: i.width * r.x,
      height: i.height * r.y,
      rotation: l
    };
    return d_(h, -ts.Konva.getAngle(e), {
      x: 0,
      y: 0
    });
  }
  __getNodeRect() {
    var t = this.getNode();
    if (!t)
      return {
        x: -z0,
        y: -z0,
        width: 0,
        height: 0,
        rotation: 0
      };
    const e = [];
    this.nodes().map((l) => {
      const h = l.getClientRect({
        skipTransform: !0,
        skipShadow: !0,
        skipStroke: this.ignoreStroke()
      });
      var d = [
        { x: h.x, y: h.y },
        { x: h.x + h.width, y: h.y },
        { x: h.x + h.width, y: h.y + h.height },
        { x: h.x, y: h.y + h.height }
      ], u = l.getAbsoluteTransform();
      d.forEach(function(f) {
        var p = u.point(f);
        e.push(p);
      });
    });
    const s = new Et.Transform();
    s.rotate(-ts.Konva.getAngle(this.rotation()));
    var i = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0;
    e.forEach(function(l) {
      var h = s.point(l);
      i === void 0 && (i = o = h.x, r = a = h.y), i = Math.min(i, h.x), r = Math.min(r, h.y), o = Math.max(o, h.x), a = Math.max(a, h.y);
    }), s.invert();
    const c = s.point({ x: i, y: r });
    return {
      x: c.x,
      y: c.y,
      width: o - i,
      height: a - r,
      rotation: ts.Konva.getAngle(this.rotation())
    };
  }
  getX() {
    return this._getNodeRect().x;
  }
  getY() {
    return this._getNodeRect().y;
  }
  getWidth() {
    return this._getNodeRect().width;
  }
  getHeight() {
    return this._getNodeRect().height;
  }
  _createElements() {
    this._createBack(), fc.forEach((t) => {
      this._createAnchor(t);
    }), this._createAnchor("rotater");
  }
  _createAnchor(t) {
    var e = new OC.Rect({
      stroke: "rgb(0, 161, 255)",
      fill: "white",
      strokeWidth: 1,
      name: t + " _anchor",
      dragDistance: 0,
      draggable: !0,
      hitStrokeWidth: $C ? 10 : "auto"
    }), s = this;
    e.on("mousedown touchstart", function(i) {
      s._handleMouseDown(i);
    }), e.on("dragstart", (i) => {
      e.stopDrag(), i.cancelBubble = !0;
    }), e.on("dragend", (i) => {
      i.cancelBubble = !0;
    }), e.on("mouseenter", () => {
      var i = ts.Konva.getAngle(this.rotation()), r = this.rotateAnchorCursor(), o = NC(t, i, r);
      e.getStage().content && (e.getStage().content.style.cursor = o), this._cursorChange = !0;
    }), e.on("mouseout", () => {
      e.getStage().content && (e.getStage().content.style.cursor = ""), this._cursorChange = !1;
    }), this.add(e);
  }
  _createBack() {
    var t = new IC.Shape({
      name: "back",
      width: 0,
      height: 0,
      draggable: !0,
      sceneFunc(e, s) {
        var i = s.getParent(), r = i.padding();
        e.beginPath(), e.rect(-r, -r, s.width() + r * 2, s.height() + r * 2), e.moveTo(s.width() / 2, -r), i.rotateEnabled() && i.rotateLineVisible() && e.lineTo(s.width() / 2, -i.rotateAnchorOffset() * Et.Util._sign(s.height()) - r), e.fillStrokeShape(s);
      },
      hitFunc: (e, s) => {
        if (this.shouldOverdrawWholeArea()) {
          var i = this.padding();
          e.beginPath(), e.rect(-i, -i, s.width() + i * 2, s.height() + i * 2), e.fillStrokeShape(s);
        }
      }
    });
    this.add(t), this._proxyDrag(t), t.on("dragstart", (e) => {
      e.cancelBubble = !0;
    }), t.on("dragmove", (e) => {
      e.cancelBubble = !0;
    }), t.on("dragend", (e) => {
      e.cancelBubble = !0;
    }), this.on("dragmove", (e) => {
      this.update();
    });
  }
  _handleMouseDown(t) {
    this._movingAnchorName = t.target.name().split(" ")[0];
    var e = this._getNodeRect(), s = e.width, i = e.height, r = Math.sqrt(Math.pow(s, 2) + Math.pow(i, 2));
    this.sin = Math.abs(i / r), this.cos = Math.abs(s / r), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
    var o = t.target.getAbsolutePosition(), a = t.target.getStage().getPointerPosition();
    this._anchorDragOffset = {
      x: a.x - o.x,
      y: a.y - o.y
    }, Hd++, this._fire("transformstart", { evt: t.evt, target: this.getNode() }), this._nodes.forEach((c) => {
      c._fire("transformstart", { evt: t.evt, target: c });
    });
  }
  _handleMouseMove(t) {
    var e, s, i, r = this.findOne("." + this._movingAnchorName), o = r.getStage();
    o.setPointersPositions(t);
    const a = o.getPointerPosition();
    let c = {
      x: a.x - this._anchorDragOffset.x,
      y: a.y - this._anchorDragOffset.y
    };
    const l = r.getAbsolutePosition();
    this.anchorDragBoundFunc() && (c = this.anchorDragBoundFunc()(l, c, t)), r.setAbsolutePosition(c);
    const h = r.getAbsolutePosition();
    if (!(l.x === h.x && l.y === h.y)) {
      if (this._movingAnchorName === "rotater") {
        var d = this._getNodeRect();
        e = r.x() - d.width / 2, s = -r.y() + d.height / 2;
        let M = Math.atan2(-s, e) + Math.PI / 2;
        d.height < 0 && (M -= Math.PI);
        var u = ts.Konva.getAngle(this.rotation());
        const F = u + M, V = ts.Konva.getAngle(this.rotationSnapTolerance()), ht = FC(this.rotationSnaps(), F, V) - d.rotation, rt = UC(d, ht);
        this._fitNodesInto(rt, t);
        return;
      }
      var f = this.shiftBehavior(), p;
      f === "inverted" ? p = this.keepRatio() && !t.shiftKey : f === "none" ? p = this.keepRatio() : p = this.keepRatio() || t.shiftKey;
      var g = this.centeredScaling() || t.altKey;
      if (this._movingAnchorName === "top-left") {
        if (p) {
          var m = g ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".bottom-right").x(),
            y: this.findOne(".bottom-right").y()
          };
          i = Math.sqrt(Math.pow(m.x - r.x(), 2) + Math.pow(m.y - r.y(), 2));
          var _ = this.findOne(".top-left").x() > m.x ? -1 : 1, v = this.findOne(".top-left").y() > m.y ? -1 : 1;
          e = i * this.cos * _, s = i * this.sin * v, this.findOne(".top-left").x(m.x - e), this.findOne(".top-left").y(m.y - s);
        }
      } else if (this._movingAnchorName === "top-center")
        this.findOne(".top-left").y(r.y());
      else if (this._movingAnchorName === "top-right") {
        if (p) {
          var m = g ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".bottom-left").x(),
            y: this.findOne(".bottom-left").y()
          };
          i = Math.sqrt(Math.pow(r.x() - m.x, 2) + Math.pow(m.y - r.y(), 2));
          var _ = this.findOne(".top-right").x() < m.x ? -1 : 1, v = this.findOne(".top-right").y() > m.y ? -1 : 1;
          e = i * this.cos * _, s = i * this.sin * v, this.findOne(".top-right").x(m.x + e), this.findOne(".top-right").y(m.y - s);
        }
        var b = r.position();
        this.findOne(".top-left").y(b.y), this.findOne(".bottom-right").x(b.x);
      } else if (this._movingAnchorName === "middle-left")
        this.findOne(".top-left").x(r.x());
      else if (this._movingAnchorName === "middle-right")
        this.findOne(".bottom-right").x(r.x());
      else if (this._movingAnchorName === "bottom-left") {
        if (p) {
          var m = g ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".top-right").x(),
            y: this.findOne(".top-right").y()
          };
          i = Math.sqrt(Math.pow(m.x - r.x(), 2) + Math.pow(r.y() - m.y, 2));
          var _ = m.x < r.x() ? -1 : 1, v = r.y() < m.y ? -1 : 1;
          e = i * this.cos * _, s = i * this.sin * v, r.x(m.x - e), r.y(m.y + s);
        }
        b = r.position(), this.findOne(".top-left").x(b.x), this.findOne(".bottom-right").y(b.y);
      } else if (this._movingAnchorName === "bottom-center")
        this.findOne(".bottom-right").y(r.y());
      else if (this._movingAnchorName === "bottom-right") {
        if (p) {
          var m = g ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".top-left").x(),
            y: this.findOne(".top-left").y()
          };
          i = Math.sqrt(Math.pow(r.x() - m.x, 2) + Math.pow(r.y() - m.y, 2));
          var _ = this.findOne(".bottom-right").x() < m.x ? -1 : 1, v = this.findOne(".bottom-right").y() < m.y ? -1 : 1;
          e = i * this.cos * _, s = i * this.sin * v, this.findOne(".bottom-right").x(m.x + e), this.findOne(".bottom-right").y(m.y + s);
        }
      } else
        console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
      var g = this.centeredScaling() || t.altKey;
      if (g) {
        var y = this.findOne(".top-left"), S = this.findOne(".bottom-right"), w = y.x(), k = y.y(), C = this.getWidth() - S.x(), A = this.getHeight() - S.y();
        S.move({
          x: -w,
          y: -k
        }), y.move({
          x: C,
          y: A
        });
      }
      var E = this.findOne(".top-left").getAbsolutePosition();
      e = E.x, s = E.y;
      var I = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(), P = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
      this._fitNodesInto({
        x: e,
        y: s,
        width: I,
        height: P,
        rotation: ts.Konva.getAngle(this.rotation())
      }, t);
    }
  }
  _handleMouseUp(t) {
    this._removeEvents(t);
  }
  getAbsoluteTransform() {
    return this.getTransform();
  }
  _removeEvents(t) {
    var e;
    if (this._transforming) {
      this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0));
      var s = this.getNode();
      Hd--, this._fire("transformend", { evt: t, target: s }), (e = this.getLayer()) === null || e === void 0 || e.batchDraw(), s && this._nodes.forEach((i) => {
        var r;
        i._fire("transformend", { evt: t, target: i }), (r = i.getLayer()) === null || r === void 0 || r.batchDraw();
      }), this._movingAnchorName = null;
    }
  }
  _fitNodesInto(t, e) {
    var s = this._getNodeRect();
    const i = 1;
    if (Et.Util._inRange(t.width, -this.padding() * 2 - i, i)) {
      this.update();
      return;
    }
    if (Et.Util._inRange(t.height, -this.padding() * 2 - i, i)) {
      this.update();
      return;
    }
    var r = new Et.Transform();
    if (r.rotate(ts.Konva.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
      const u = r.point({
        x: -this.padding() * 2,
        y: 0
      });
      t.x += u.x, t.y += u.y, t.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= u.x, this._anchorDragOffset.y -= u.y;
    } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
      const u = r.point({
        x: this.padding() * 2,
        y: 0
      });
      this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= u.x, this._anchorDragOffset.y -= u.y, t.width += this.padding() * 2;
    }
    if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
      const u = r.point({
        x: 0,
        y: -this.padding() * 2
      });
      t.x += u.x, t.y += u.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= u.x, this._anchorDragOffset.y -= u.y, t.height += this.padding() * 2;
    } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
      const u = r.point({
        x: 0,
        y: this.padding() * 2
      });
      this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= u.x, this._anchorDragOffset.y -= u.y, t.height += this.padding() * 2;
    }
    if (this.boundBoxFunc()) {
      const u = this.boundBoxFunc()(s, t);
      u ? t = u : Et.Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
    }
    const o = 1e7, a = new Et.Transform();
    a.translate(s.x, s.y), a.rotate(s.rotation), a.scale(s.width / o, s.height / o);
    const c = new Et.Transform(), l = t.width / o, h = t.height / o;
    this.flipEnabled() === !1 ? (c.translate(t.x, t.y), c.rotate(t.rotation), c.translate(t.width < 0 ? t.width : 0, t.height < 0 ? t.height : 0), c.scale(Math.abs(l), Math.abs(h))) : (c.translate(t.x, t.y), c.rotate(t.rotation), c.scale(l, h));
    const d = c.multiply(a.invert());
    this._nodes.forEach((u) => {
      var f;
      const p = u.getParent().getAbsoluteTransform(), m = u.getTransform().copy();
      m.translate(u.offsetX(), u.offsetY());
      const _ = new Et.Transform();
      _.multiply(p.copy().invert()).multiply(d).multiply(p).multiply(m);
      const v = _.decompose();
      u.setAttrs(v), (f = u.getLayer()) === null || f === void 0 || f.batchDraw();
    }), this.rotation(Et.Util._getRotation(t.rotation)), this._nodes.forEach((u) => {
      this._fire("transform", { evt: e, target: u }), u._fire("transform", { evt: e, target: u });
    }), this._resetTransformCache(), this.update(), this.getLayer().batchDraw();
  }
  forceUpdate() {
    this._resetTransformCache(), this.update();
  }
  _batchChangeChild(t, e) {
    this.findOne(t).setAttrs(e);
  }
  update() {
    var t, e = this._getNodeRect();
    this.rotation(Et.Util._getRotation(e.rotation));
    var s = e.width, i = e.height, r = this.enabledAnchors(), o = this.resizeEnabled(), a = this.padding(), c = this.anchorSize();
    const l = this.find("._anchor");
    l.forEach((d) => {
      d.setAttrs({
        width: c,
        height: c,
        offsetX: c / 2,
        offsetY: c / 2,
        stroke: this.anchorStroke(),
        strokeWidth: this.anchorStrokeWidth(),
        fill: this.anchorFill(),
        cornerRadius: this.anchorCornerRadius()
      });
    }), this._batchChangeChild(".top-left", {
      x: 0,
      y: 0,
      offsetX: c / 2 + a,
      offsetY: c / 2 + a,
      visible: o && r.indexOf("top-left") >= 0
    }), this._batchChangeChild(".top-center", {
      x: s / 2,
      y: 0,
      offsetY: c / 2 + a,
      visible: o && r.indexOf("top-center") >= 0
    }), this._batchChangeChild(".top-right", {
      x: s,
      y: 0,
      offsetX: c / 2 - a,
      offsetY: c / 2 + a,
      visible: o && r.indexOf("top-right") >= 0
    }), this._batchChangeChild(".middle-left", {
      x: 0,
      y: i / 2,
      offsetX: c / 2 + a,
      visible: o && r.indexOf("middle-left") >= 0
    }), this._batchChangeChild(".middle-right", {
      x: s,
      y: i / 2,
      offsetX: c / 2 - a,
      visible: o && r.indexOf("middle-right") >= 0
    }), this._batchChangeChild(".bottom-left", {
      x: 0,
      y: i,
      offsetX: c / 2 + a,
      offsetY: c / 2 - a,
      visible: o && r.indexOf("bottom-left") >= 0
    }), this._batchChangeChild(".bottom-center", {
      x: s / 2,
      y: i,
      offsetY: c / 2 - a,
      visible: o && r.indexOf("bottom-center") >= 0
    }), this._batchChangeChild(".bottom-right", {
      x: s,
      y: i,
      offsetX: c / 2 - a,
      offsetY: c / 2 - a,
      visible: o && r.indexOf("bottom-right") >= 0
    }), this._batchChangeChild(".rotater", {
      x: s / 2,
      y: -this.rotateAnchorOffset() * Et.Util._sign(i) - a,
      visible: this.rotateEnabled()
    }), this._batchChangeChild(".back", {
      width: s,
      height: i,
      visible: this.borderEnabled(),
      stroke: this.borderStroke(),
      strokeWidth: this.borderStrokeWidth(),
      dash: this.borderDash(),
      x: 0,
      y: 0
    });
    const h = this.anchorStyleFunc();
    h && l.forEach((d) => {
      h(d);
    }), (t = this.getLayer()) === null || t === void 0 || t.batchDraw();
  }
  isTransforming() {
    return this._transforming;
  }
  stopTransform() {
    if (this._transforming) {
      this._removeEvents();
      var t = this.findOne("." + this._movingAnchorName);
      t && t.stopDrag();
    }
  }
  destroy() {
    return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), G0.Group.prototype.destroy.call(this), this.detach(), this._removeEvents(), this;
  }
  toObject() {
    return j0.Node.prototype.toObject.call(this);
  }
  clone(t) {
    var e = j0.Node.prototype.clone.call(this, t);
    return e;
  }
  getClientRect() {
    return this.nodes().length > 0 ? super.getClientRect() : { x: 0, y: 0, width: 0, height: 0 };
  }
}
kl.Transformer = mt;
mt.isTransforming = () => Hd > 0;
function BC(n) {
  return n instanceof Array || Et.Util.warn("enabledAnchors value should be an array"), n instanceof Array && n.forEach(function(t) {
    fc.indexOf(t) === -1 && Et.Util.warn("Unknown anchor name: " + t + ". Available names are: " + fc.join(", "));
  }), n || [];
}
mt.prototype.className = "Transformer";
(0, DC._registerNode)(mt);
wt.Factory.addGetterSetter(mt, "enabledAnchors", fc, BC);
wt.Factory.addGetterSetter(mt, "flipEnabled", !0, (0, Rn.getBooleanValidator)());
wt.Factory.addGetterSetter(mt, "resizeEnabled", !0);
wt.Factory.addGetterSetter(mt, "anchorSize", 10, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "rotateEnabled", !0);
wt.Factory.addGetterSetter(mt, "rotateLineVisible", !0);
wt.Factory.addGetterSetter(mt, "rotationSnaps", []);
wt.Factory.addGetterSetter(mt, "rotateAnchorOffset", 50, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "rotateAnchorCursor", "crosshair");
wt.Factory.addGetterSetter(mt, "rotationSnapTolerance", 5, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "borderEnabled", !0);
wt.Factory.addGetterSetter(mt, "anchorStroke", "rgb(0, 161, 255)");
wt.Factory.addGetterSetter(mt, "anchorStrokeWidth", 1, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "anchorFill", "white");
wt.Factory.addGetterSetter(mt, "anchorCornerRadius", 0, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "borderStroke", "rgb(0, 161, 255)");
wt.Factory.addGetterSetter(mt, "borderStrokeWidth", 1, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "borderDash");
wt.Factory.addGetterSetter(mt, "keepRatio", !0);
wt.Factory.addGetterSetter(mt, "shiftBehavior", "default");
wt.Factory.addGetterSetter(mt, "centeredScaling", !1);
wt.Factory.addGetterSetter(mt, "ignoreStroke", !1);
wt.Factory.addGetterSetter(mt, "padding", 0, (0, Rn.getNumberValidator)());
wt.Factory.addGetterSetter(mt, "node");
wt.Factory.addGetterSetter(mt, "nodes");
wt.Factory.addGetterSetter(mt, "boundBoxFunc");
wt.Factory.addGetterSetter(mt, "anchorDragBoundFunc");
wt.Factory.addGetterSetter(mt, "anchorStyleFunc");
wt.Factory.addGetterSetter(mt, "shouldOverdrawWholeArea", !1);
wt.Factory.addGetterSetter(mt, "useSingleNodeRotation", !0);
wt.Factory.backCompat(mt, {
  lineEnabled: "borderEnabled",
  rotateHandlerOffset: "rotateAnchorOffset",
  enabledHandlers: "enabledAnchors"
});
var xl = {};
Object.defineProperty(xl, "__esModule", { value: !0 });
xl.Wedge = void 0;
const El = ut, VC = ie, jC = ft, u_ = z, GC = ft;
class tn extends VC.Shape {
  _sceneFunc(t) {
    t.beginPath(), t.arc(0, 0, this.radius(), 0, jC.Konva.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this);
  }
  getWidth() {
    return this.radius() * 2;
  }
  getHeight() {
    return this.radius() * 2;
  }
  setWidth(t) {
    this.radius(t / 2);
  }
  setHeight(t) {
    this.radius(t / 2);
  }
}
xl.Wedge = tn;
tn.prototype.className = "Wedge";
tn.prototype._centroid = !0;
tn.prototype._attrsAffectingSize = ["radius"];
(0, GC._registerNode)(tn);
El.Factory.addGetterSetter(tn, "radius", 0, (0, u_.getNumberValidator)());
El.Factory.addGetterSetter(tn, "angle", 0, (0, u_.getNumberValidator)());
El.Factory.addGetterSetter(tn, "clockwise", !1);
El.Factory.backCompat(tn, {
  angleDeg: "angle",
  getAngleDeg: "getAngle",
  setAngleDeg: "setAngle"
});
var Tl = {};
Object.defineProperty(Tl, "__esModule", { value: !0 });
Tl.Blur = void 0;
const W0 = ut, HC = Nt, zC = z;
function K0() {
  this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
}
var WC = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], KC = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function YC(n, t) {
  var e = n.data, s = n.width, i = n.height, r, o, a, c, l, h, d, u, f, p, m, _, v, b, g, y, S, w, k, C, A, E, I, P, M = t + t + 1, F = s - 1, V = i - 1, q = t + 1, ht = q * (q + 1) / 2, rt = new K0(), Dt = null, K = rt, X = null, vt = null, Tt = WC[t], Ct = KC[t];
  for (a = 1; a < M; a++)
    K = K.next = new K0(), a === q && (Dt = K);
  for (K.next = rt, d = h = 0, o = 0; o < i; o++) {
    for (y = S = w = k = u = f = p = m = 0, _ = q * (C = e[h]), v = q * (A = e[h + 1]), b = q * (E = e[h + 2]), g = q * (I = e[h + 3]), u += ht * C, f += ht * A, p += ht * E, m += ht * I, K = rt, a = 0; a < q; a++)
      K.r = C, K.g = A, K.b = E, K.a = I, K = K.next;
    for (a = 1; a < q; a++)
      c = h + ((F < a ? F : a) << 2), u += (K.r = C = e[c]) * (P = q - a), f += (K.g = A = e[c + 1]) * P, p += (K.b = E = e[c + 2]) * P, m += (K.a = I = e[c + 3]) * P, y += C, S += A, w += E, k += I, K = K.next;
    for (X = rt, vt = Dt, r = 0; r < s; r++)
      e[h + 3] = I = m * Tt >> Ct, I !== 0 ? (I = 255 / I, e[h] = (u * Tt >> Ct) * I, e[h + 1] = (f * Tt >> Ct) * I, e[h + 2] = (p * Tt >> Ct) * I) : e[h] = e[h + 1] = e[h + 2] = 0, u -= _, f -= v, p -= b, m -= g, _ -= X.r, v -= X.g, b -= X.b, g -= X.a, c = d + ((c = r + t + 1) < F ? c : F) << 2, y += X.r = e[c], S += X.g = e[c + 1], w += X.b = e[c + 2], k += X.a = e[c + 3], u += y, f += S, p += w, m += k, X = X.next, _ += C = vt.r, v += A = vt.g, b += E = vt.b, g += I = vt.a, y -= C, S -= A, w -= E, k -= I, vt = vt.next, h += 4;
    d += s;
  }
  for (r = 0; r < s; r++) {
    for (S = w = k = y = f = p = m = u = 0, h = r << 2, _ = q * (C = e[h]), v = q * (A = e[h + 1]), b = q * (E = e[h + 2]), g = q * (I = e[h + 3]), u += ht * C, f += ht * A, p += ht * E, m += ht * I, K = rt, a = 0; a < q; a++)
      K.r = C, K.g = A, K.b = E, K.a = I, K = K.next;
    for (l = s, a = 1; a <= t; a++)
      h = l + r << 2, u += (K.r = C = e[h]) * (P = q - a), f += (K.g = A = e[h + 1]) * P, p += (K.b = E = e[h + 2]) * P, m += (K.a = I = e[h + 3]) * P, y += C, S += A, w += E, k += I, K = K.next, a < V && (l += s);
    for (h = r, X = rt, vt = Dt, o = 0; o < i; o++)
      c = h << 2, e[c + 3] = I = m * Tt >> Ct, I > 0 ? (I = 255 / I, e[c] = (u * Tt >> Ct) * I, e[c + 1] = (f * Tt >> Ct) * I, e[c + 2] = (p * Tt >> Ct) * I) : e[c] = e[c + 1] = e[c + 2] = 0, u -= _, f -= v, p -= b, m -= g, _ -= X.r, v -= X.g, b -= X.b, g -= X.a, c = r + ((c = o + q) < V ? c : V) * s << 2, u += y += X.r = e[c], f += S += X.g = e[c + 1], p += w += X.b = e[c + 2], m += k += X.a = e[c + 3], X = X.next, _ += C = vt.r, v += A = vt.g, b += E = vt.b, g += I = vt.a, y -= C, S -= A, w -= E, k -= I, vt = vt.next, h += s;
  }
}
const ZC = function(t) {
  var e = Math.round(this.blurRadius());
  e > 0 && YC(t, e);
};
Tl.Blur = ZC;
W0.Factory.addGetterSetter(HC.Node, "blurRadius", 0, (0, zC.getNumberValidator)(), W0.Factory.afterSetFilter);
var Al = {};
Object.defineProperty(Al, "__esModule", { value: !0 });
Al.Brighten = void 0;
const Y0 = ut, qC = Nt, XC = z, JC = function(n) {
  var t = this.brightness() * 255, e = n.data, s = e.length, i;
  for (i = 0; i < s; i += 4)
    e[i] += t, e[i + 1] += t, e[i + 2] += t;
};
Al.Brighten = JC;
Y0.Factory.addGetterSetter(qC.Node, "brightness", 0, (0, XC.getNumberValidator)(), Y0.Factory.afterSetFilter);
var Il = {};
Object.defineProperty(Il, "__esModule", { value: !0 });
Il.Contrast = void 0;
const Z0 = ut, QC = Nt, tk = z, ek = function(n) {
  var t = Math.pow((this.contrast() + 100) / 100, 2), e = n.data, s = e.length, i = 150, r = 150, o = 150, a;
  for (a = 0; a < s; a += 4)
    i = e[a], r = e[a + 1], o = e[a + 2], i /= 255, i -= 0.5, i *= t, i += 0.5, i *= 255, r /= 255, r -= 0.5, r *= t, r += 0.5, r *= 255, o /= 255, o -= 0.5, o *= t, o += 0.5, o *= 255, i = i < 0 ? 0 : i > 255 ? 255 : i, r = r < 0 ? 0 : r > 255 ? 255 : r, o = o < 0 ? 0 : o > 255 ? 255 : o, e[a] = i, e[a + 1] = r, e[a + 2] = o;
};
Il.Contrast = ek;
Z0.Factory.addGetterSetter(QC.Node, "contrast", 0, (0, tk.getNumberValidator)(), Z0.Factory.afterSetFilter);
var Ol = {};
Object.defineProperty(Ol, "__esModule", { value: !0 });
Ol.Emboss = void 0;
const kn = ut, Dl = Nt, sk = Vt, f_ = z, nk = function(n) {
  var t = this.embossStrength() * 10, e = this.embossWhiteLevel() * 255, s = this.embossDirection(), i = this.embossBlend(), r = 0, o = 0, a = n.data, c = n.width, l = n.height, h = c * 4, d = l;
  switch (s) {
    case "top-left":
      r = -1, o = -1;
      break;
    case "top":
      r = -1, o = 0;
      break;
    case "top-right":
      r = -1, o = 1;
      break;
    case "right":
      r = 0, o = 1;
      break;
    case "bottom-right":
      r = 1, o = 1;
      break;
    case "bottom":
      r = 1, o = 0;
      break;
    case "bottom-left":
      r = 1, o = -1;
      break;
    case "left":
      r = 0, o = -1;
      break;
    default:
      sk.Util.error("Unknown emboss direction: " + s);
  }
  do {
    var u = (d - 1) * h, f = r;
    d + f < 1 && (f = 0), d + f > l && (f = 0);
    var p = (d - 1 + f) * c * 4, m = c;
    do {
      var _ = u + (m - 1) * 4, v = o;
      m + v < 1 && (v = 0), m + v > c && (v = 0);
      var b = p + (m - 1 + v) * 4, g = a[_] - a[b], y = a[_ + 1] - a[b + 1], S = a[_ + 2] - a[b + 2], w = g, k = w > 0 ? w : -w, C = y > 0 ? y : -y, A = S > 0 ? S : -S;
      if (C > k && (w = y), A > k && (w = S), w *= t, i) {
        var E = a[_] + w, I = a[_ + 1] + w, P = a[_ + 2] + w;
        a[_] = E > 255 ? 255 : E < 0 ? 0 : E, a[_ + 1] = I > 255 ? 255 : I < 0 ? 0 : I, a[_ + 2] = P > 255 ? 255 : P < 0 ? 0 : P;
      } else {
        var M = e - w;
        M < 0 ? M = 0 : M > 255 && (M = 255), a[_] = a[_ + 1] = a[_ + 2] = M;
      }
    } while (--m);
  } while (--d);
};
Ol.Emboss = nk;
kn.Factory.addGetterSetter(Dl.Node, "embossStrength", 0.5, (0, f_.getNumberValidator)(), kn.Factory.afterSetFilter);
kn.Factory.addGetterSetter(Dl.Node, "embossWhiteLevel", 0.5, (0, f_.getNumberValidator)(), kn.Factory.afterSetFilter);
kn.Factory.addGetterSetter(Dl.Node, "embossDirection", "top-left", null, kn.Factory.afterSetFilter);
kn.Factory.addGetterSetter(Dl.Node, "embossBlend", !1, null, kn.Factory.afterSetFilter);
var Pl = {};
Object.defineProperty(Pl, "__esModule", { value: !0 });
Pl.Enhance = void 0;
const q0 = ut, ik = Nt, rk = z;
function Rh(n, t, e, s, i) {
  var r = e - t, o = i - s, a;
  return r === 0 ? s + o / 2 : o === 0 ? s : (a = (n - t) / r, a = o * a + s, a);
}
const ok = function(n) {
  var t = n.data, e = t.length, s = t[0], i = s, r, o = t[1], a = o, c, l = t[2], h = l, d, u, f = this.enhance();
  if (f !== 0) {
    for (u = 0; u < e; u += 4)
      r = t[u + 0], r < s ? s = r : r > i && (i = r), c = t[u + 1], c < o ? o = c : c > a && (a = c), d = t[u + 2], d < l ? l = d : d > h && (h = d);
    i === s && (i = 255, s = 0), a === o && (a = 255, o = 0), h === l && (h = 255, l = 0);
    var p, m, _, v, b, g, y, S, w;
    for (f > 0 ? (m = i + f * (255 - i), _ = s - f * (s - 0), b = a + f * (255 - a), g = o - f * (o - 0), S = h + f * (255 - h), w = l - f * (l - 0)) : (p = (i + s) * 0.5, m = i + f * (i - p), _ = s + f * (s - p), v = (a + o) * 0.5, b = a + f * (a - v), g = o + f * (o - v), y = (h + l) * 0.5, S = h + f * (h - y), w = l + f * (l - y)), u = 0; u < e; u += 4)
      t[u + 0] = Rh(t[u + 0], s, i, _, m), t[u + 1] = Rh(t[u + 1], o, a, g, b), t[u + 2] = Rh(t[u + 2], l, h, w, S);
  }
};
Pl.Enhance = ok;
q0.Factory.addGetterSetter(ik.Node, "enhance", 0, (0, rk.getNumberValidator)(), q0.Factory.afterSetFilter);
var Ml = {};
Object.defineProperty(Ml, "__esModule", { value: !0 });
Ml.Grayscale = void 0;
const ak = function(n) {
  var t = n.data, e = t.length, s, i;
  for (s = 0; s < e; s += 4)
    i = 0.34 * t[s] + 0.5 * t[s + 1] + 0.16 * t[s + 2], t[s] = i, t[s + 1] = i, t[s + 2] = i;
};
Ml.Grayscale = ak;
var Rl = {};
Object.defineProperty(Rl, "__esModule", { value: !0 });
Rl.HSL = void 0;
const dr = ut, ff = Nt, pf = z;
dr.Factory.addGetterSetter(ff.Node, "hue", 0, (0, pf.getNumberValidator)(), dr.Factory.afterSetFilter);
dr.Factory.addGetterSetter(ff.Node, "saturation", 0, (0, pf.getNumberValidator)(), dr.Factory.afterSetFilter);
dr.Factory.addGetterSetter(ff.Node, "luminance", 0, (0, pf.getNumberValidator)(), dr.Factory.afterSetFilter);
const ck = function(n) {
  var t = n.data, e = t.length, s = 1, i = Math.pow(2, this.saturation()), r = Math.abs(this.hue() + 360) % 360, o = this.luminance() * 127, a, c = s * i * Math.cos(r * Math.PI / 180), l = s * i * Math.sin(r * Math.PI / 180), h = 0.299 * s + 0.701 * c + 0.167 * l, d = 0.587 * s - 0.587 * c + 0.33 * l, u = 0.114 * s - 0.114 * c - 0.497 * l, f = 0.299 * s - 0.299 * c - 0.328 * l, p = 0.587 * s + 0.413 * c + 0.035 * l, m = 0.114 * s - 0.114 * c + 0.293 * l, _ = 0.299 * s - 0.3 * c + 1.25 * l, v = 0.587 * s - 0.586 * c - 1.05 * l, b = 0.114 * s + 0.886 * c - 0.2 * l, g, y, S, w;
  for (a = 0; a < e; a += 4)
    g = t[a + 0], y = t[a + 1], S = t[a + 2], w = t[a + 3], t[a + 0] = h * g + d * y + u * S + o, t[a + 1] = f * g + p * y + m * S + o, t[a + 2] = _ * g + v * y + b * S + o, t[a + 3] = w;
};
Rl.HSL = ck;
var $l = {};
Object.defineProperty($l, "__esModule", { value: !0 });
$l.HSV = void 0;
const ur = ut, gf = Nt, mf = z, lk = function(n) {
  var t = n.data, e = t.length, s = Math.pow(2, this.value()), i = Math.pow(2, this.saturation()), r = Math.abs(this.hue() + 360) % 360, o, a = s * i * Math.cos(r * Math.PI / 180), c = s * i * Math.sin(r * Math.PI / 180), l = 0.299 * s + 0.701 * a + 0.167 * c, h = 0.587 * s - 0.587 * a + 0.33 * c, d = 0.114 * s - 0.114 * a - 0.497 * c, u = 0.299 * s - 0.299 * a - 0.328 * c, f = 0.587 * s + 0.413 * a + 0.035 * c, p = 0.114 * s - 0.114 * a + 0.293 * c, m = 0.299 * s - 0.3 * a + 1.25 * c, _ = 0.587 * s - 0.586 * a - 1.05 * c, v = 0.114 * s + 0.886 * a - 0.2 * c, b, g, y, S;
  for (o = 0; o < e; o += 4)
    b = t[o + 0], g = t[o + 1], y = t[o + 2], S = t[o + 3], t[o + 0] = l * b + h * g + d * y, t[o + 1] = u * b + f * g + p * y, t[o + 2] = m * b + _ * g + v * y, t[o + 3] = S;
};
$l.HSV = lk;
ur.Factory.addGetterSetter(gf.Node, "hue", 0, (0, mf.getNumberValidator)(), ur.Factory.afterSetFilter);
ur.Factory.addGetterSetter(gf.Node, "saturation", 0, (0, mf.getNumberValidator)(), ur.Factory.afterSetFilter);
ur.Factory.addGetterSetter(gf.Node, "value", 0, (0, mf.getNumberValidator)(), ur.Factory.afterSetFilter);
var Nl = {};
Object.defineProperty(Nl, "__esModule", { value: !0 });
Nl.Invert = void 0;
const hk = function(n) {
  var t = n.data, e = t.length, s;
  for (s = 0; s < e; s += 4)
    t[s] = 255 - t[s], t[s + 1] = 255 - t[s + 1], t[s + 2] = 255 - t[s + 2];
};
Nl.Invert = hk;
var Ll = {};
Object.defineProperty(Ll, "__esModule", { value: !0 });
Ll.Kaleidoscope = void 0;
const pc = ut, p_ = Nt, X0 = Vt, g_ = z;
var dk = function(n, t, e) {
  var s = n.data, i = t.data, r = n.width, o = n.height, a = e.polarCenterX || r / 2, c = e.polarCenterY || o / 2, l, h, d, u = 0, f = 0, p = 0, m = 0, _, v = Math.sqrt(a * a + c * c);
  h = r - a, d = o - c, _ = Math.sqrt(h * h + d * d), v = _ > v ? _ : v;
  var b = o, g = r, y, S, w = 360 / g * Math.PI / 180, k, C;
  for (S = 0; S < g; S += 1)
    for (k = Math.sin(S * w), C = Math.cos(S * w), y = 0; y < b; y += 1)
      h = Math.floor(a + v * y / b * C), d = Math.floor(c + v * y / b * k), l = (d * r + h) * 4, u = s[l + 0], f = s[l + 1], p = s[l + 2], m = s[l + 3], l = (S + y * r) * 4, i[l + 0] = u, i[l + 1] = f, i[l + 2] = p, i[l + 3] = m;
}, uk = function(n, t, e) {
  var s = n.data, i = t.data, r = n.width, o = n.height, a = e.polarCenterX || r / 2, c = e.polarCenterY || o / 2, l, h, d, u, f, p = 0, m = 0, _ = 0, v = 0, b, g = Math.sqrt(a * a + c * c);
  h = r - a, d = o - c, b = Math.sqrt(h * h + d * d), g = b > g ? b : g;
  var y = o, S = r, w, k, C = e.polarRotation || 0, A, E;
  for (h = 0; h < r; h += 1)
    for (d = 0; d < o; d += 1)
      u = h - a, f = d - c, w = Math.sqrt(u * u + f * f) * y / g, k = (Math.atan2(f, u) * 180 / Math.PI + 360 + C) % 360, k = k * S / 360, A = Math.floor(k), E = Math.floor(w), l = (E * r + A) * 4, p = s[l + 0], m = s[l + 1], _ = s[l + 2], v = s[l + 3], l = (d * r + h) * 4, i[l + 0] = p, i[l + 1] = m, i[l + 2] = _, i[l + 3] = v;
};
const fk = function(n) {
  var t = n.width, e = n.height, s, i, r, o, a, c, l, h, d, u, f = Math.round(this.kaleidoscopePower()), p = Math.round(this.kaleidoscopeAngle()), m = Math.floor(t * (p % 360) / 360);
  if (!(f < 1)) {
    var _ = X0.Util.createCanvasElement();
    _.width = t, _.height = e;
    var v = _.getContext("2d").getImageData(0, 0, t, e);
    X0.Util.releaseCanvas(_), dk(n, v, {
      polarCenterX: t / 2,
      polarCenterY: e / 2
    });
    for (var b = t / Math.pow(2, f); b <= 8; )
      b = b * 2, f -= 1;
    b = Math.ceil(b);
    var g = b, y = 0, S = g, w = 1;
    for (m + b > t && (y = g, S = 0, w = -1), i = 0; i < e; i += 1)
      for (s = y; s !== S; s += w)
        r = Math.round(s + m) % t, d = (t * i + r) * 4, a = v.data[d + 0], c = v.data[d + 1], l = v.data[d + 2], h = v.data[d + 3], u = (t * i + s) * 4, v.data[u + 0] = a, v.data[u + 1] = c, v.data[u + 2] = l, v.data[u + 3] = h;
    for (i = 0; i < e; i += 1)
      for (g = Math.floor(b), o = 0; o < f; o += 1) {
        for (s = 0; s < g + 1; s += 1)
          d = (t * i + s) * 4, a = v.data[d + 0], c = v.data[d + 1], l = v.data[d + 2], h = v.data[d + 3], u = (t * i + g * 2 - s - 1) * 4, v.data[u + 0] = a, v.data[u + 1] = c, v.data[u + 2] = l, v.data[u + 3] = h;
        g *= 2;
      }
    uk(v, n, { polarRotation: 0 });
  }
};
Ll.Kaleidoscope = fk;
pc.Factory.addGetterSetter(p_.Node, "kaleidoscopePower", 2, (0, g_.getNumberValidator)(), pc.Factory.afterSetFilter);
pc.Factory.addGetterSetter(p_.Node, "kaleidoscopeAngle", 0, (0, g_.getNumberValidator)(), pc.Factory.afterSetFilter);
var Ul = {};
Object.defineProperty(Ul, "__esModule", { value: !0 });
Ul.Mask = void 0;
const J0 = ut, pk = Nt, gk = z;
function Ea(n, t, e) {
  var s = (e * n.width + t) * 4, i = [];
  return i.push(n.data[s++], n.data[s++], n.data[s++], n.data[s++]), i;
}
function Fr(n, t) {
  return Math.sqrt(Math.pow(n[0] - t[0], 2) + Math.pow(n[1] - t[1], 2) + Math.pow(n[2] - t[2], 2));
}
function mk(n) {
  for (var t = [0, 0, 0], e = 0; e < n.length; e++)
    t[0] += n[e][0], t[1] += n[e][1], t[2] += n[e][2];
  return t[0] /= n.length, t[1] /= n.length, t[2] /= n.length, t;
}
function _k(n, t) {
  var e = Ea(n, 0, 0), s = Ea(n, n.width - 1, 0), i = Ea(n, 0, n.height - 1), r = Ea(n, n.width - 1, n.height - 1), o = t || 10;
  if (Fr(e, s) < o && Fr(s, r) < o && Fr(r, i) < o && Fr(i, e) < o) {
    for (var a = mk([s, e, r, i]), c = [], l = 0; l < n.width * n.height; l++) {
      var h = Fr(a, [
        n.data[l * 4],
        n.data[l * 4 + 1],
        n.data[l * 4 + 2]
      ]);
      c[l] = h < o ? 0 : 255;
    }
    return c;
  }
}
function yk(n, t) {
  for (var e = 0; e < n.width * n.height; e++)
    n.data[4 * e + 3] = t[e];
}
function vk(n, t, e) {
  for (var s = [1, 1, 1, 1, 0, 1, 1, 1, 1], i = Math.round(Math.sqrt(s.length)), r = Math.floor(i / 2), o = [], a = 0; a < e; a++)
    for (var c = 0; c < t; c++) {
      for (var l = a * t + c, h = 0, d = 0; d < i; d++)
        for (var u = 0; u < i; u++) {
          var f = a + d - r, p = c + u - r;
          if (f >= 0 && f < e && p >= 0 && p < t) {
            var m = f * t + p, _ = s[d * i + u];
            h += n[m] * _;
          }
        }
      o[l] = h === 255 * 8 ? 255 : 0;
    }
  return o;
}
function bk(n, t, e) {
  for (var s = [1, 1, 1, 1, 1, 1, 1, 1, 1], i = Math.round(Math.sqrt(s.length)), r = Math.floor(i / 2), o = [], a = 0; a < e; a++)
    for (var c = 0; c < t; c++) {
      for (var l = a * t + c, h = 0, d = 0; d < i; d++)
        for (var u = 0; u < i; u++) {
          var f = a + d - r, p = c + u - r;
          if (f >= 0 && f < e && p >= 0 && p < t) {
            var m = f * t + p, _ = s[d * i + u];
            h += n[m] * _;
          }
        }
      o[l] = h >= 255 * 4 ? 255 : 0;
    }
  return o;
}
function wk(n, t, e) {
  for (var s = [0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111], i = Math.round(Math.sqrt(s.length)), r = Math.floor(i / 2), o = [], a = 0; a < e; a++)
    for (var c = 0; c < t; c++) {
      for (var l = a * t + c, h = 0, d = 0; d < i; d++)
        for (var u = 0; u < i; u++) {
          var f = a + d - r, p = c + u - r;
          if (f >= 0 && f < e && p >= 0 && p < t) {
            var m = f * t + p, _ = s[d * i + u];
            h += n[m] * _;
          }
        }
      o[l] = h;
    }
  return o;
}
const Sk = function(n) {
  var t = this.threshold(), e = _k(n, t);
  return e && (e = vk(e, n.width, n.height), e = bk(e, n.width, n.height), e = wk(e, n.width, n.height), yk(n, e)), n;
};
Ul.Mask = Sk;
J0.Factory.addGetterSetter(pk.Node, "threshold", 0, (0, gk.getNumberValidator)(), J0.Factory.afterSetFilter);
var Fl = {};
Object.defineProperty(Fl, "__esModule", { value: !0 });
Fl.Noise = void 0;
const Q0 = ut, Ck = Nt, kk = z, xk = function(n) {
  var t = this.noise() * 255, e = n.data, s = e.length, i = t / 2, r;
  for (r = 0; r < s; r += 4)
    e[r + 0] += i - 2 * i * Math.random(), e[r + 1] += i - 2 * i * Math.random(), e[r + 2] += i - 2 * i * Math.random();
};
Fl.Noise = xk;
Q0.Factory.addGetterSetter(Ck.Node, "noise", 0.2, (0, kk.getNumberValidator)(), Q0.Factory.afterSetFilter);
var Bl = {};
Object.defineProperty(Bl, "__esModule", { value: !0 });
Bl.Pixelate = void 0;
const t1 = ut, Ek = Vt, Tk = Nt, Ak = z, Ik = function(n) {
  var t = Math.ceil(this.pixelSize()), e = n.width, s = n.height, i, r, o, a, c, l, h, d = Math.ceil(e / t), u = Math.ceil(s / t), f, p, m, _, v, b, g, y = n.data;
  if (t <= 0) {
    Ek.Util.error("pixelSize value can not be <= 0");
    return;
  }
  for (v = 0; v < d; v += 1)
    for (b = 0; b < u; b += 1) {
      for (a = 0, c = 0, l = 0, h = 0, f = v * t, p = f + t, m = b * t, _ = m + t, g = 0, i = f; i < p; i += 1)
        if (!(i >= e))
          for (r = m; r < _; r += 1)
            r >= s || (o = (e * r + i) * 4, a += y[o + 0], c += y[o + 1], l += y[o + 2], h += y[o + 3], g += 1);
      for (a = a / g, c = c / g, l = l / g, h = h / g, i = f; i < p; i += 1)
        if (!(i >= e))
          for (r = m; r < _; r += 1)
            r >= s || (o = (e * r + i) * 4, y[o + 0] = a, y[o + 1] = c, y[o + 2] = l, y[o + 3] = h);
    }
};
Bl.Pixelate = Ik;
t1.Factory.addGetterSetter(Tk.Node, "pixelSize", 8, (0, Ak.getNumberValidator)(), t1.Factory.afterSetFilter);
var Vl = {};
Object.defineProperty(Vl, "__esModule", { value: !0 });
Vl.Posterize = void 0;
const e1 = ut, Ok = Nt, Dk = z, Pk = function(n) {
  var t = Math.round(this.levels() * 254) + 1, e = n.data, s = e.length, i = 255 / t, r;
  for (r = 0; r < s; r += 1)
    e[r] = Math.floor(e[r] / i) * i;
};
Vl.Posterize = Pk;
e1.Factory.addGetterSetter(Ok.Node, "levels", 0.5, (0, Dk.getNumberValidator)(), e1.Factory.afterSetFilter);
var jl = {};
Object.defineProperty(jl, "__esModule", { value: !0 });
jl.RGB = void 0;
const gc = ut, _f = Nt, Mk = z, Rk = function(n) {
  var t = n.data, e = t.length, s = this.red(), i = this.green(), r = this.blue(), o, a;
  for (o = 0; o < e; o += 4)
    a = (0.34 * t[o] + 0.5 * t[o + 1] + 0.16 * t[o + 2]) / 255, t[o] = a * s, t[o + 1] = a * i, t[o + 2] = a * r, t[o + 3] = t[o + 3];
};
jl.RGB = Rk;
gc.Factory.addGetterSetter(_f.Node, "red", 0, function(n) {
  return this._filterUpToDate = !1, n > 255 ? 255 : n < 0 ? 0 : Math.round(n);
});
gc.Factory.addGetterSetter(_f.Node, "green", 0, function(n) {
  return this._filterUpToDate = !1, n > 255 ? 255 : n < 0 ? 0 : Math.round(n);
});
gc.Factory.addGetterSetter(_f.Node, "blue", 0, Mk.RGBComponent, gc.Factory.afterSetFilter);
var Gl = {};
Object.defineProperty(Gl, "__esModule", { value: !0 });
Gl.RGBA = void 0;
const $o = ut, Hl = Nt, $k = z, Nk = function(n) {
  var t = n.data, e = t.length, s = this.red(), i = this.green(), r = this.blue(), o = this.alpha(), a, c;
  for (a = 0; a < e; a += 4)
    c = 1 - o, t[a] = s * o + t[a] * c, t[a + 1] = i * o + t[a + 1] * c, t[a + 2] = r * o + t[a + 2] * c;
};
Gl.RGBA = Nk;
$o.Factory.addGetterSetter(Hl.Node, "red", 0, function(n) {
  return this._filterUpToDate = !1, n > 255 ? 255 : n < 0 ? 0 : Math.round(n);
});
$o.Factory.addGetterSetter(Hl.Node, "green", 0, function(n) {
  return this._filterUpToDate = !1, n > 255 ? 255 : n < 0 ? 0 : Math.round(n);
});
$o.Factory.addGetterSetter(Hl.Node, "blue", 0, $k.RGBComponent, $o.Factory.afterSetFilter);
$o.Factory.addGetterSetter(Hl.Node, "alpha", 1, function(n) {
  return this._filterUpToDate = !1, n > 1 ? 1 : n < 0 ? 0 : n;
});
var zl = {};
Object.defineProperty(zl, "__esModule", { value: !0 });
zl.Sepia = void 0;
const Lk = function(n) {
  var t = n.data, e = t.length, s, i, r, o;
  for (s = 0; s < e; s += 4)
    i = t[s + 0], r = t[s + 1], o = t[s + 2], t[s + 0] = Math.min(255, i * 0.393 + r * 0.769 + o * 0.189), t[s + 1] = Math.min(255, i * 0.349 + r * 0.686 + o * 0.168), t[s + 2] = Math.min(255, i * 0.272 + r * 0.534 + o * 0.131);
};
zl.Sepia = Lk;
var Wl = {};
Object.defineProperty(Wl, "__esModule", { value: !0 });
Wl.Solarize = void 0;
const Uk = function(n) {
  var t = n.data, e = n.width, s = n.height, i = e * 4, r = s;
  do {
    var o = (r - 1) * i, a = e;
    do {
      var c = o + (a - 1) * 4, l = t[c], h = t[c + 1], d = t[c + 2];
      l > 127 && (l = 255 - l), h > 127 && (h = 255 - h), d > 127 && (d = 255 - d), t[c] = l, t[c + 1] = h, t[c + 2] = d;
    } while (--a);
  } while (--r);
};
Wl.Solarize = Uk;
var Kl = {};
Object.defineProperty(Kl, "__esModule", { value: !0 });
Kl.Threshold = void 0;
const s1 = ut, Fk = Nt, Bk = z, Vk = function(n) {
  var t = this.threshold() * 255, e = n.data, s = e.length, i;
  for (i = 0; i < s; i += 1)
    e[i] = e[i] < t ? 0 : 255;
};
Kl.Threshold = Vk;
s1.Factory.addGetterSetter(Fk.Node, "threshold", 0.5, (0, Bk.getNumberValidator)(), s1.Factory.afterSetFilter);
Object.defineProperty(sl, "__esModule", { value: !0 });
sl.Konva = void 0;
const n1 = $m, jk = cl, Gk = dl, Hk = pl, zk = gl, Wk = ml, i1 = hr, Kk = ea, Yk = Tr, Zk = na, qk = vl, Xk = bl, Jk = wl, Qk = Sl, tx = ci, ex = Cl, sx = kl, nx = xl, ix = Tl, rx = Al, ox = Il, ax = Ol, cx = Pl, lx = Ml, hx = Rl, dx = $l, ux = Nl, fx = Ll, px = Ul, gx = Fl, mx = Bl, _x = Vl, yx = jl, vx = Gl, bx = zl, wx = Wl, Sx = Kl;
sl.Konva = n1.Konva.Util._assign(n1.Konva, {
  Arc: jk.Arc,
  Arrow: Gk.Arrow,
  Circle: Hk.Circle,
  Ellipse: zk.Ellipse,
  Image: Wk.Image,
  Label: i1.Label,
  Tag: i1.Tag,
  Line: Kk.Line,
  Path: Yk.Path,
  Rect: Zk.Rect,
  RegularPolygon: qk.RegularPolygon,
  Ring: Xk.Ring,
  Sprite: Jk.Sprite,
  Star: Qk.Star,
  Text: tx.Text,
  TextPath: ex.TextPath,
  Transformer: sx.Transformer,
  Wedge: nx.Wedge,
  Filters: {
    Blur: ix.Blur,
    Brighten: rx.Brighten,
    Contrast: ox.Contrast,
    Emboss: ax.Emboss,
    Enhance: cx.Enhance,
    Grayscale: lx.Grayscale,
    HSL: hx.HSL,
    HSV: dx.HSV,
    Invert: ux.Invert,
    Kaleidoscope: fx.Kaleidoscope,
    Mask: px.Mask,
    Noise: gx.Noise,
    Pixelate: mx.Pixelate,
    Posterize: _x.Posterize,
    RGB: yx.RGB,
    RGBA: vx.RGBA,
    Sepia: bx.Sepia,
    Solarize: wx.Solarize,
    Threshold: Sx.Threshold
  }
});
var Cx = sf.exports;
Object.defineProperty(Cx, "__esModule", { value: !0 });
const kx = sl;
sf.exports = kx.Konva;
var xx = sf.exports;
const Me = /* @__PURE__ */ ou(xx), Ex = Rm.props(), $h = Object.keys(Ex).filter((n) => n !== "width" && n !== "height"), Tc = class Tc extends Me.Group {
  static pickModelProps(t, e) {
    const {
      afterPick: s = void 0,
      keys: i = void 0,
      initProps: r = {}
    } = e || {}, a = ((i ?? t.keys) || []).reduce((c, l) => (t[l] !== void 0 && (c[l] = t[l]), c), r);
    return s && s(a), a;
  }
  constructor(t) {
    const e = t.model;
    super(t), this.std = t.std, this.model = e, this.setAttrs({
      modelId: e.id,
      id: e.getFullId(),
      name: `xpix:node ${e.flavour}`,
      // TODO: Remove draggable to one-way data flow
      draggable: !0
      // TODO: Add shadow support
      // shadowColor: 'rgba(0,0,0,0.2)',
      // shadowOffset: { x: 1, y: 1 }
      // shadowBlur: 15
    }), this.created();
  }
  // Lifecycle events
  // beforeCreate() {}
  created() {
  }
  // beforeMount() {}
  mounted() {
  }
  // beforeUnmount() {}
  unmounted() {
  }
  onUpdate(t) {
    const e = t.props, s = this._mainNode;
    if (!e || !s)
      return;
    const i = $h.reduce((c, l) => (e[l] !== void 0 && (c[l] = e[l]), c), {});
    let r = 0;
    const a = Object.keys(e).reduce((c, l) => ($h.includes(l) || (c[l] = e[l], r++), c), {});
    r > 0 && s.setAttrs(a), this.setAttrs(i);
  }
  onDestroy() {
  }
  mount(t) {
    const e = this.getParentNode(t);
    if (!e)
      throw new Error("Parent node not found");
    this.buildNode(), e.add(this), this.mounted();
  }
  update(t) {
    t.props && this.onUpdate(t);
  }
  getMainKeys() {
    return this.model.keys.filter((e) => !$h.includes(e));
  }
  buildNode() {
    throw new Error("Block.buildNode not implemented: " + this.model.flavour);
  }
  getParentNode(t) {
    const e = t.stage, s = this.model, i = s.doc.getParent(s);
    return i ? e.findOne("#" + i.getFullId()) : void 0;
  }
  centerModel(t, e) {
    const s = e.getClientRect(), i = Math.max(e.width(), s.width), r = Math.max(e.height(), s.height), o = r1(t.height, r), a = r1(t.width, i);
    this.setAttrs({ x: a, y: o }), t.doc.updateBlock(t, { x: a, y: o });
  }
  pickModelProps(t) {
    return Tc.pickModelProps(this.model, t);
  }
  destroy() {
    return this.unmounted(), this.onDestroy(), super.destroy();
  }
};
Tc.Model = Rm;
let fr = Tc;
function r1(n, t) {
  return n = n ?? 0, t = t ?? 0, t / 2 - n / 2;
}
const Ac = class Ac extends ai {
  constructor() {
    super();
  }
  static props() {
    return {
      ...super.props(),
      mode: "board"
    };
  }
};
Ac.flavour = "xpix:page", Ac.metadata = {
  version: 1,
  role: "root",
  children: [
    "xpix:frame"
  ]
};
let zd = Ac;
const Rf = class Rf extends fr {
  buildNode() {
    console.log("PageBlock.buildNode:", this.model);
  }
};
Rf.Model = zd;
let Wd = Rf;
const Ic = class Ic extends ai {
  constructor() {
    super();
  }
  static props() {
    return {
      ...super.props(),
      background: "#FFF",
      width: 666,
      height: 666
    };
  }
};
Ic.flavour = "xpix:frame", Ic.metadata = {
  version: 1,
  role: "hub",
  parent: ["xpix:page"]
};
let Kd = Ic;
const $f = class $f extends fr {
  constructor(t) {
    super(t), this.std.editor.on("frame:switch", () => {
      this.fitViewMode();
    });
  }
  fitViewMode() {
    const t = this.std.editor;
    if (t.viewMode !== "board")
      return;
    const { width: e, height: s, id: i } = this.model;
    this.setAttrs({
      visible: i === t.viewState.currentFrameId,
      y: -s / 2,
      x: -e / 2
    });
  }
  mounted() {
    this.fitViewMode();
  }
  onUpdate(t) {
    var s;
    super.onUpdate(t);
    const e = t.props || {};
    e.background && ((s = this._mainNode) == null || s.setAttrs({
      fill: e.background
    }));
  }
  buildNode() {
    const { width: t, height: e, background: s } = this.model, i = this._mainNode = new Me.Rect(this.pickModelProps({
      // keys: ['width', 'height' ],
      keys: this.getMainKeys(),
      initProps: {
        fill: s
      }
    }));
    this.setAttrs({
      clipX: 0,
      clipY: 0,
      clipWidth: t,
      clipHeight: e,
      draggable: !1
    }), this.add(i);
  }
};
$f.Model = Kd;
let Yd = $f;
const Oc = class Oc extends ai {
  constructor() {
    super();
  }
  static props() {
    return {
      ...super.props(),
      type: "shape",
      fill: "#080",
      radius: 0
    };
  }
};
Oc.flavour = "xpix:shape", Oc.metadata = {
  version: 1,
  role: "content",
  parent: ["xpix:page", "xpix:frame", "xpix:group"]
};
let Zd = Oc;
const Tx = {
  shape: Me.Shape,
  circle: Me.Circle,
  rect: Me.Rect
}, Nf = class Nf extends fr {
  onUpdate(t) {
    const e = this.model, s = t.props || {};
    e.type === "circle" && (delete s.height, delete s.width), super.onUpdate(t);
  }
  buildNode() {
    const t = this.model, e = Tx[t.type];
    if (!e)
      throw new Error("ShapeClass not found");
    const s = this._mainNode = new e(this.pickModelProps({
      // keys: ['width', 'height', 'fill', 'stroke', 'strokeWidth', 'radius'],
      keys: this.getMainKeys(),
      initProps: {
        fill: "#FFF"
      }
    }));
    this.add(s);
  }
};
Nf.Model = Zd;
let qd = Nf;
const Dc = class Dc extends ai {
  constructor() {
    super();
  }
  static props() {
    return {
      ...super.props(),
      caption: "",
      assetId: ""
    };
  }
};
Dc.flavour = "xpix:image", Dc.metadata = {
  version: 1,
  role: "content",
  parent: ["xpix:page", "xpix:frame", "xpix:group"]
};
let Xd = Dc;
async function Ax(n) {
  return n instanceof Blob ? m_(n) : Ix(n);
}
async function Ix(n) {
  const e = await (await fetch(n)).blob();
  return m_(e);
}
async function m_(n) {
  return n instanceof File || (n = new File([n], "unknown.ext", {
    type: "application/octet-stream"
  })), n;
}
async function __(n) {
  return n instanceof Blob ? Ox(n) : y_(n);
}
async function Ox(n, t = !0) {
  const e = URL.createObjectURL(n);
  return t && setTimeout(() => {
    URL.revokeObjectURL(e);
  }, 6400), y_(e);
}
async function y_(n) {
  return new Promise((t, e) => {
    const s = document.createElement("img");
    s.onload = () => {
      s.height = s.naturalHeight, s.width = s.naturalWidth, t(s);
    }, s.onerror = () => {
      e(new Error("Image load error: " + n));
    }, s.crossOrigin = "Anonymous", s.src = n;
  });
}
const o1 = document.createElement("canvas"), Lf = class Lf extends fr {
  constructor() {
    super(...arguments), this.assetId = "", this.assetURL = "";
  }
  mounted() {
    this.updateImage();
  }
  onUpdate(t) {
    super.onUpdate(t), this.updateImage();
  }
  async updateImage() {
    const t = this.model, e = t.assetId, s = this._mainNode;
    if (!e) {
      s == null || s.setAttr("image", o1);
      return;
    }
    if (e === this.assetId)
      return;
    this.assetId = e, this.assetURL && URL.revokeObjectURL(this.assetURL);
    const i = await t.doc.blob.get(e);
    if (i && s) {
      const r = this.assetURL = URL.createObjectURL(i), o = this.assetImage = await __(r);
      s.setAttr("image", o), s.cache();
    }
  }
  buildNode() {
    const t = this._mainNode = new Me.Image({
      ...this.pickModelProps({
        // keys: ['width', 'height' ]
        keys: this.getMainKeys()
      }),
      image: o1
    });
    this.add(t);
  }
};
Lf.Model = Xd;
let Jd = Lf;
const Dx = [
  Wd,
  Yd,
  qd,
  Jd
], v_ = Dx.map((n) => ({
  schema: n.Model.defineSchema(),
  view: {
    component: new Tw(n)
  }
})), Px = v_.map((n) => n.schema), Mx = new c9().register(Px), yf = new yd({
  schema: Mx,
  id: "xpix.collection.default",
  // TODO: Support blob upload
  blobStorages: [
    // createSimpleServerStorage,
    s3
  ]
});
function vf(n) {
  return yf.createDoc({ id: n });
}
function Rx() {
  const n = vf();
  return b_(n);
}
function b_(n) {
  return n.load(() => {
    if (!n.isEmpty)
      return;
    const t = n.addBlock("xpix:page");
    n.addBlock(
      "xpix:frame",
      {
        // background: '#F00',
        height: 400,
        width: 600
      },
      t
    ), n.resetHistory();
  }), n;
}
async function $x(n) {
  let t = yf.getDoc(n || "");
  return t || (t = vf(n || void 0)), Promise.race([
    // IndexeddbPersistence
    new Promise((e, s) => {
      new H8(t.id, t.spaceDoc).once("synced", e), setTimeout(() => {
        s(new Error("Load doc timeout."));
      }, 10 * 1e3);
    }),
    // LiveblocksProvider
    new Promise((e, s) => {
      const i = Qb({
        publicApiKey: "pk_dev_7Ta2cDWPZ42VDVOgmYY6c-cS3NBdf-6FCOazyRwA_Z7BGB2e1nuLFD-b64-XcFbs"
      }), { room: r } = i.enterRoom(t.id, {
        initialPresence: {}
      });
      new Ew(r, t.spaceDoc).once("synced", e), setTimeout(() => {
        s(new Error("Load doc timeout by liveblocks."));
      }, 10 * 1e3);
    })
  ]).then(() => b_(t));
}
async function Nx(n) {
  return await new Gu({ collection: yf }).snapshotToDoc(n);
}
async function Lx(n) {
  return n ? await new Gu({ collection: n.collection }).docToSnapshot(n) : null;
}
function Ux(n, t) {
  return {
    ...t,
    doc: n
  };
}
var bf = { exports: {} };
bf.exports;
(function(n) {
  var t = function() {
    var e = String.fromCharCode, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", r = {};
    function o(c, l) {
      if (!r[c]) {
        r[c] = {};
        for (var h = 0; h < c.length; h++)
          r[c][c.charAt(h)] = h;
      }
      return r[c][l];
    }
    var a = {
      compressToBase64: function(c) {
        if (c == null)
          return "";
        var l = a._compress(c, 6, function(h) {
          return s.charAt(h);
        });
        switch (l.length % 4) {
          default:
          case 0:
            return l;
          case 1:
            return l + "===";
          case 2:
            return l + "==";
          case 3:
            return l + "=";
        }
      },
      decompressFromBase64: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 32, function(l) {
          return o(s, c.charAt(l));
        });
      },
      compressToUTF16: function(c) {
        return c == null ? "" : a._compress(c, 15, function(l) {
          return e(l + 32);
        }) + " ";
      },
      decompressFromUTF16: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 16384, function(l) {
          return c.charCodeAt(l) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(c) {
        for (var l = a.compress(c), h = new Uint8Array(l.length * 2), d = 0, u = l.length; d < u; d++) {
          var f = l.charCodeAt(d);
          h[d * 2] = f >>> 8, h[d * 2 + 1] = f % 256;
        }
        return h;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(c) {
        if (c == null)
          return a.decompress(c);
        for (var l = new Array(c.length / 2), h = 0, d = l.length; h < d; h++)
          l[h] = c[h * 2] * 256 + c[h * 2 + 1];
        var u = [];
        return l.forEach(function(f) {
          u.push(e(f));
        }), a.decompress(u.join(""));
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(c) {
        return c == null ? "" : a._compress(c, 6, function(l) {
          return i.charAt(l);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(c) {
        return c == null ? "" : c == "" ? null : (c = c.replace(/ /g, "+"), a._decompress(c.length, 32, function(l) {
          return o(i, c.charAt(l));
        }));
      },
      compress: function(c) {
        return a._compress(c, 16, function(l) {
          return e(l);
        });
      },
      _compress: function(c, l, h) {
        if (c == null)
          return "";
        var d, u, f = {}, p = {}, m = "", _ = "", v = "", b = 2, g = 3, y = 2, S = [], w = 0, k = 0, C;
        for (C = 0; C < c.length; C += 1)
          if (m = c.charAt(C), Object.prototype.hasOwnProperty.call(f, m) || (f[m] = g++, p[m] = !0), _ = v + m, Object.prototype.hasOwnProperty.call(f, _))
            v = _;
          else {
            if (Object.prototype.hasOwnProperty.call(p, v)) {
              if (v.charCodeAt(0) < 256) {
                for (d = 0; d < y; d++)
                  w = w << 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++;
                for (u = v.charCodeAt(0), d = 0; d < 8; d++)
                  w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
              } else {
                for (u = 1, d = 0; d < y; d++)
                  w = w << 1 | u, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = 0;
                for (u = v.charCodeAt(0), d = 0; d < 16; d++)
                  w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
              }
              b--, b == 0 && (b = Math.pow(2, y), y++), delete p[v];
            } else
              for (u = f[v], d = 0; d < y; d++)
                w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
            b--, b == 0 && (b = Math.pow(2, y), y++), f[_] = g++, v = String(m);
          }
        if (v !== "") {
          if (Object.prototype.hasOwnProperty.call(p, v)) {
            if (v.charCodeAt(0) < 256) {
              for (d = 0; d < y; d++)
                w = w << 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++;
              for (u = v.charCodeAt(0), d = 0; d < 8; d++)
                w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
            } else {
              for (u = 1, d = 0; d < y; d++)
                w = w << 1 | u, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = 0;
              for (u = v.charCodeAt(0), d = 0; d < 16; d++)
                w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
            }
            b--, b == 0 && (b = Math.pow(2, y), y++), delete p[v];
          } else
            for (u = f[v], d = 0; d < y; d++)
              w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
          b--, b == 0 && (b = Math.pow(2, y), y++);
        }
        for (u = 2, d = 0; d < y; d++)
          w = w << 1 | u & 1, k == l - 1 ? (k = 0, S.push(h(w)), w = 0) : k++, u = u >> 1;
        for (; ; )
          if (w = w << 1, k == l - 1) {
            S.push(h(w));
            break;
          } else
            k++;
        return S.join("");
      },
      decompress: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 32768, function(l) {
          return c.charCodeAt(l);
        });
      },
      _decompress: function(c, l, h) {
        var d = [], u = 4, f = 4, p = 3, m = "", _ = [], v, b, g, y, S, w, k, C = { val: h(0), position: l, index: 1 };
        for (v = 0; v < 3; v += 1)
          d[v] = v;
        for (g = 0, S = Math.pow(2, 2), w = 1; w != S; )
          y = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = h(C.index++)), g |= (y > 0 ? 1 : 0) * w, w <<= 1;
        switch (g) {
          case 0:
            for (g = 0, S = Math.pow(2, 8), w = 1; w != S; )
              y = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = h(C.index++)), g |= (y > 0 ? 1 : 0) * w, w <<= 1;
            k = e(g);
            break;
          case 1:
            for (g = 0, S = Math.pow(2, 16), w = 1; w != S; )
              y = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = h(C.index++)), g |= (y > 0 ? 1 : 0) * w, w <<= 1;
            k = e(g);
            break;
          case 2:
            return "";
        }
        for (d[3] = k, b = k, _.push(k); ; ) {
          if (C.index > c)
            return "";
          for (g = 0, S = Math.pow(2, p), w = 1; w != S; )
            y = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = h(C.index++)), g |= (y > 0 ? 1 : 0) * w, w <<= 1;
          switch (k = g) {
            case 0:
              for (g = 0, S = Math.pow(2, 8), w = 1; w != S; )
                y = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = h(C.index++)), g |= (y > 0 ? 1 : 0) * w, w <<= 1;
              d[f++] = e(g), k = f - 1, u--;
              break;
            case 1:
              for (g = 0, S = Math.pow(2, 16), w = 1; w != S; )
                y = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = h(C.index++)), g |= (y > 0 ? 1 : 0) * w, w <<= 1;
              d[f++] = e(g), k = f - 1, u--;
              break;
            case 2:
              return _.join("");
          }
          if (u == 0 && (u = Math.pow(2, p), p++), d[k])
            m = d[k];
          else if (k === f)
            m = b + b.charAt(0);
          else
            return null;
          _.push(m), d[f++] = b + m.charAt(0), u--, b = m, u == 0 && (u = Math.pow(2, p), p++);
        }
      }
    };
    return a;
  }();
  n != null ? n.exports = t : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return t;
  });
})(bf);
var a1 = bf.exports;
class Fx {
  constructor(t) {
    this.std = t, this._jobMiddlewares = [], this._adapterMap = /* @__PURE__ */ new Map(), this.use = (e) => {
      this._jobMiddlewares.push(e);
    }, this.unuse = (e) => {
      this._jobMiddlewares = this._jobMiddlewares.filter((s) => s !== e);
    }, this.registerAdapter = (e, s, i = 0) => {
      this._adapterMap.set(e, { adapter: s, priority: i });
    }, this.unregisterAdapter = (e) => {
      this._adapterMap.delete(e);
    }, this._getDataByType = (e) => {
      const s = /* @__PURE__ */ new Map();
      for (const i of e.types)
        i === "Files" ? s.set(i, Array.from(e.files)) : s.set(i, e.getData(i));
      return (i) => {
        const r = s.get(i);
        if (r)
          return r;
        const o = s.get("Files") ?? [];
        return o.length > 0 ? o : "";
      };
    }, this._getSnapshotByPriority = async (e, s, i, r) => {
      const o = Array.from(this._adapterMap.entries()).sort((a, c) => c[1].priority - a[1].priority);
      for (const [a, { adapter: c }] of o) {
        const l = e(a);
        if (!(Array.isArray(l) && (l.length === 0 || // if all files are not the same target type, fallback to */*
        !l.map((h) => h.type === a || a === "*/*").reduce((h, d) => h && d, !0))) && l) {
          const h = this._getJob();
          c.applyConfigs(h.adapterConfigs);
          const d = {
            file: l,
            assets: h.assetsManager,
            blockVersions: s.collection.meta.blockVersions,
            pageVersion: s.collection.meta.pageVersion,
            workspaceVersion: s.collection.meta.workspaceVersion,
            workspaceId: s.collection.id,
            pageId: s.id
          }, u = await c.toSliceSnapshot(d);
          if (u)
            return h.snapshotToSlice(u, s, i, r);
        }
      }
      return null;
    }, this.copy = async (e) => this.copySlice(e), this.paste = async (e, s, i, r) => {
      const o = e.clipboardData;
      if (o)
        try {
          const a = this.readFromClipboard(o), c = await this._getSnapshotByPriority((l) => a[l], s, i, r);
          return B(c), c;
        } catch {
          const a = this._getDataByType(o);
          return await this._getSnapshotByPriority((l) => a(l), s, i, r);
        }
    }, this.pasteBlockSnapshot = async (e, s, i, r) => this._getJob().snapshotToBlock(e, s, i, r), this.copySlice = async (e) => {
      const s = Array.from(this._adapterMap.keys());
      await this.writeToClipboard(async (i) => {
        const r = { ...i };
        return await Promise.all(s.map(async (o) => {
          const a = await this._getClipboardItem(e, o);
          typeof a == "string" && (r[o] = a);
        })), r;
      });
    };
  }
  get configs() {
    return this._getJob().adapterConfigs;
  }
  _getJob() {
    return new Gu({
      middlewares: this._jobMiddlewares,
      collection: this.std.collection
    });
  }
  async _getClipboardItem(t, e) {
    const s = this._getJob(), i = this._adapterMap.get(e);
    B(i);
    const { adapter: r } = i, o = await s.sliceToSnapshot(t);
    return r.applyConfigs(s.adapterConfigs), (await r.fromSliceSnapshot({ snapshot: o, assets: s.assetsManager })).file;
  }
  async writeToClipboard(t) {
    const s = await t({
      "text/plain": "",
      "text/html": "",
      "image/png": ""
    }), i = s["text/plain"], r = s["text/html"], o = s["image/png"];
    delete s["text/plain"], delete s["text/html"], delete s["image/png"];
    const c = `<div data-blocksuite-snapshot=${a1.compressToEncodedURIComponent(JSON.stringify(s))}>${r}</div>`, h = {
      "text/html": new Blob([c], {
        type: "text/html"
      })
    };
    if (i.length > 0) {
      const d = new Blob([i], {
        type: "text/plain"
      });
      h["text/plain"] = d;
    }
    if (o instanceof Blob)
      h["image/png"] = o;
    else if (o.length > 0) {
      const d = new Blob([o], {
        type: "image/png"
      });
      h["image/png"] = d;
    }
    await navigator.clipboard.write([new ClipboardItem(h)]);
  }
  readFromClipboard(t) {
    const e = t.getData("text/html"), r = new DOMParser().parseFromString(e, "text/html").querySelector("[data-blocksuite-snapshot]");
    return B(r), JSON.parse(a1.decompressFromEncodedURIComponent(r.dataset.blocksuiteSnapshot));
  }
}
const Qe = Symbol("cmds");
class Bx {
  constructor(t) {
    this.std = t, this._commands = /* @__PURE__ */ new Map(), this._getCommandCtx = () => ({
      std: this.std
    }), this._createChain = (e, s) => {
      const i = this._getCommandCtx, r = this._createChain, o = this.chain;
      return {
        [Qe]: s,
        run: function() {
          let a = i(), c = !1;
          try {
            const l = this[Qe];
            a = w_(a, [
              ...l,
              (h, d) => {
                c = !0, d();
              }
            ]);
          } catch (l) {
            console.error(l);
          }
          return [c, a];
        },
        with: function(a) {
          const c = this[Qe];
          return r(e, [
            ...c,
            (l, h) => h(a)
          ]);
        },
        inline: function(a) {
          const c = this[Qe];
          return r(e, [...c, a]);
        },
        try: function(a) {
          const c = this[Qe];
          return r(e, [
            ...c,
            (l, h) => {
              let d = l;
              a(o()).some((f) => {
                f[Qe] = [
                  (m, _) => {
                    _(d);
                  },
                  ...f[Qe]
                ];
                const [p] = f.inline((m, _) => {
                  d = { ...d, ...m }, _();
                }).run();
                return p ? (h(d), !0) : !1;
              });
            }
          ]);
        },
        tryAll: function(a) {
          const c = this[Qe];
          return r(e, [
            ...c,
            (l, h) => {
              let d = l;
              const u = a(o());
              let f = !0;
              u.forEach((p) => {
                p[Qe] = [
                  (_, v) => {
                    v(d);
                  },
                  ...p[Qe]
                ];
                const [m] = p.inline((_, v) => {
                  d = { ...d, ..._ }, v();
                }).run();
                m && (f = !1);
              }), f || h(d);
            }
          ]);
        },
        ...e
      };
    }, this.chain = () => {
      const e = {}, s = this._createChain;
      for (const [i, r] of this._commands.entries())
        e[i] = function(o) {
          const a = this[Qe];
          return s(e, [
            ...a,
            (c, l) => r({ ...c, ...o }, l)
          ]);
        };
      return s(e, []);
    };
  }
  add(t, e) {
    return this._commands.set(t, e), this;
  }
}
function w_(n, [t, ...e]) {
  let s = n;
  return t && t(n, (i) => {
    s = w_({ ...n, ...i }, e);
  }), s;
}
class en {
  constructor(t) {
    this.event = t, this.type = "defaultState";
  }
}
class Ai {
  constructor() {
    this._map = {}, this.add = (t) => {
      const e = t.type;
      this._map[e] && console.warn("UIEventStateContext: state name duplicated", e), this._map[e] = t;
    }, this.has = (t) => !!this._map[t], this.get = (t) => {
      const e = this._map[t];
      return B(e, `UIEventStateContext: state ${t} not found`), e;
    };
  }
  static from(...t) {
    const e = new Ai();
    return t.forEach((s) => {
      e.add(s);
    }), e;
  }
}
const ze = class ze {
  constructor() {
  }
};
ze.id = (t) => t[t.length - 1], ze.parent = (t) => t.slice(0, t.length - 1), ze.pathToKey = (t) => t.join("|"), ze.keyToPath = (t) => t.split("|"), ze.equals = (t, e) => ze.pathToKey(t) === ze.pathToKey(e), ze.includes = (t, e) => ze.pathToKey(t).startsWith(ze.pathToKey(e));
let os = ze;
class Nh extends en {
  constructor({ event: t }) {
    super(t), this.type = "clipboardState", this.raw = t;
  }
}
var js;
(function(n) {
  n.Selection = "selection", n.Target = "target";
})(js || (js = {}));
class ia extends en {
  constructor({ event: t, sourceType: e }) {
    super(t), this.type = "sourceState", this.sourceType = e;
  }
}
class Vx {
  constructor(t) {
    this._dispatcher = t, this._cut = (e) => {
      const s = new Nh({
        event: e
      });
      this._dispatcher.run("cut", this._createContext(e, s));
    }, this._copy = (e) => {
      const s = new Nh({
        event: e
      });
      this._dispatcher.run("copy", this._createContext(e, s));
    }, this._paste = (e) => {
      const s = new Nh({
        event: e
      });
      this._dispatcher.run("paste", this._createContext(e, s));
    };
  }
  _createContext(t, e) {
    return Ai.from(new en(t), new ia({
      event: t,
      sourceType: js.Selection
    }), e);
  }
  listen() {
    this._dispatcher.disposables.addFromEvent(document, "cut", this._cut), this._dispatcher.disposables.addFromEvent(document, "copy", this._copy), this._dispatcher.disposables.addFromEvent(document, "paste", this._paste);
  }
}
var xn = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, mc = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, jx = typeof navigator < "u" && /Mac/.test(navigator.platform), Gx = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ge = 0; ge < 10; ge++)
  xn[48 + ge] = xn[96 + ge] = String(ge);
for (var ge = 1; ge <= 24; ge++)
  xn[ge + 111] = "F" + ge;
for (var ge = 65; ge <= 90; ge++)
  xn[ge] = String.fromCharCode(ge + 32), mc[ge] = String.fromCharCode(ge);
for (var Lh in xn)
  mc.hasOwnProperty(Lh) || (mc[Lh] = xn[Lh]);
function Hx(n) {
  var t = jx && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || Gx && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", e = !t && n.key || (n.shiftKey ? mc : xn)[n.keyCode] || n.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
const zx = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function Wx(n) {
  const t = n.split(/-(?!$)/);
  let e = t.at(-1);
  e === "Space" && (e = " ");
  let s, i, r, o;
  return t.slice(0, -1).forEach((a) => {
    if (/^(cmd|meta|m)$/i.test(a)) {
      o = !0;
      return;
    }
    if (/^a(lt)?$/i.test(a)) {
      s = !0;
      return;
    }
    if (/^(c|ctrl|control)$/i.test(a)) {
      i = !0;
      return;
    }
    if (/^s(hift)?$/i.test(a)) {
      r = !0;
      return;
    }
    if (/^mod$/i.test(a)) {
      zx ? o = !0 : i = !0;
      return;
    }
    throw new Error("Unrecognized modifier name: " + a);
  }), s && (e = "Alt-" + e), i && (e = "Ctrl-" + e), o && (e = "Meta-" + e), r && (e = "Shift-" + e), e;
}
function Uh(n, t, e = !0) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e && t.shiftKey && (n = "Shift-" + n), n;
}
function Kx(n) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const e in n)
    t[Wx(e)] = n[e];
  return t;
}
function Yx(n) {
  const t = Kx(n);
  return (e) => {
    const i = e.get("keyboardState").raw, r = Hx(i), o = t[Uh(r, i)];
    if (o && o(e))
      return !0;
    if (r.length !== 1 || r === " ")
      return !1;
    if (i.shiftKey) {
      const l = t[Uh(r, i, !1)];
      if (l && l(e))
        return !0;
    }
    const a = i.shiftKey || i.altKey || i.metaKey || r.charCodeAt(0) > 127, c = xn[i.keyCode];
    if (a && c && c !== r) {
      const l = t[Uh(c, i)];
      if (l && l(e))
        return !0;
    }
    return !1;
  };
}
class c1 extends en {
  constructor({ event: t, composing: e }) {
    super(t), this.type = "keyboardState", this.raw = t, this.composing = e;
  }
}
class Br extends en {
  get x() {
    return this.point.x;
  }
  get y() {
    return this.point.y;
  }
  constructor({ event: t, rect: e, startX: s, startY: i, last: r, cumulativeParentScale: o }) {
    super(t), this.type = "pointerState";
    const a = (t.clientX - e.left) / o, c = (t.clientY - e.top) / o;
    this.raw = t, this.point = { x: a, y: c }, this.containerOffset = { x: e.left, y: e.top }, this.start = { x: s, y: i }, this.delta = r ? { x: a - r.point.x, y: c - r.point.y } : { x: 0, y: 0 }, this.keys = {
      shift: t.shiftKey,
      cmd: t.metaKey || t.ctrlKey,
      alt: t.altKey
    }, this.button = (r == null ? void 0 : r.button) || t.button, this.dragging = !!r, this.pressure = t.pressure, this.cumulativeParentScale = o;
  }
}
class Zx {
  constructor(t) {
    this._dispatcher = t, this.composition = !1, this._down = (e) => {
      const s = new c1({
        event: e,
        composing: this.composition
      });
      this._dispatcher.run("keyDown", this._createContext(e, s));
    }, this._up = (e) => {
      const s = new c1({
        event: e,
        composing: this.composition
      });
      this._dispatcher.run("keyUp", this._createContext(e, s));
    };
  }
  _createContext(t, e) {
    return Ai.from(new en(t), new ia({
      event: t,
      sourceType: js.Selection
    }), e);
  }
  listen() {
    this._dispatcher.disposables.addFromEvent(document, "keydown", this._down), this._dispatcher.disposables.addFromEvent(document, "keyup", this._up), this._dispatcher.disposables.addFromEvent(document, "compositionstart", () => {
      this.composition = !0;
    }), this._dispatcher.disposables.addFromEvent(document, "compositionend", () => {
      this.composition = !1;
    });
  }
  bindHotkey(t, e) {
    return this._dispatcher.add("keyDown", (s) => this.composition ? !1 : Yx(t)(s), e);
  }
}
function l1(n, t) {
  const e = n.x - t.x, s = n.y - t.y;
  return Math.pow(e, 2) + Math.pow(s, 2) > 4;
}
const qx = (n) => n.toLowerCase();
class Xx {
  constructor(t) {
    this._dispatcher = t, this._lastPointerDownEvent = null, this._startDragState = null, this._lastDragState = null, this._pointerDownCount = 0, this._dragging = !1, this._startX = -1 / 0, this._startY = -1 / 0, this._cumulativeParentScale = 1, this._reset = () => {
      this._startX = -1 / 0, this._startY = -1 / 0, this._lastDragState = null, this._dragging = !1;
    }, this._down = (e) => {
      this._lastPointerDownEvent && e.timeStamp - this._lastPointerDownEvent.timeStamp < 500 && !l1(e, this._lastPointerDownEvent) ? this._pointerDownCount++ : this._pointerDownCount = 1;
      const s = new Br({
        event: e,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: null,
        cumulativeParentScale: this._cumulativeParentScale
      });
      this._startX = s.point.x, this._startY = s.point.y, this._startDragState = s, this._lastDragState = s, this._lastPointerDownEvent = e, this._dispatcher.run("pointerDown", this._createContext(e, s)), this._dispatcher.disposables.addFromEvent(document, "pointermove", this._move), this._dispatcher.disposables.addFromEvent(document, "pointerup", this._up);
    }, this._up = (e) => {
      const s = new Br({
        event: e,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: this._lastDragState,
        cumulativeParentScale: this._cumulativeParentScale
      }), i = this._createContext(e, s);
      (() => {
        if (this._dragging) {
          this._dispatcher.run("dragEnd", i);
          return;
        }
        this._dispatcher.run("click", i), this._pointerDownCount === 2 && this._dispatcher.run("doubleClick", i), this._pointerDownCount === 3 && this._dispatcher.run("tripleClick", i);
      })(), this._dispatcher.run("pointerUp", i), this._reset(), document.removeEventListener("pointermove", this._move), document.removeEventListener("pointerup", this._up);
    }, this._move = (e) => {
      const s = this._lastDragState, i = new Br({
        event: e,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: s,
        cumulativeParentScale: this._cumulativeParentScale
      });
      this._lastDragState = i, B(this._startDragState), !this._dragging && l1(this._startDragState.raw, i.raw) && (this._dragging = !0, this._dispatcher.run("dragStart", this._createContext(e, this._startDragState))), this._dragging && this._dispatcher.run("dragMove", this._createContext(e, i));
    }, this._moveOn = (e) => {
      const s = new Br({
        event: e,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: this._lastDragState,
        cumulativeParentScale: this._cumulativeParentScale
      });
      this._dispatcher.run("pointerMove", this._createContext(e, s));
    }, this._out = (e) => {
      const s = new Br({
        event: e,
        rect: this._rect,
        startX: -1 / 0,
        startY: -1 / 0,
        last: null,
        cumulativeParentScale: this._cumulativeParentScale
      });
      this._dispatcher.run("pointerOut", this._createContext(e, s));
    };
  }
  listen() {
    this._dispatcher.disposables.addFromEvent(this._dispatcher.host, "pointerdown", this._down), this._dispatcher.disposables.addFromEvent(this._dispatcher.host, "pointermove", this._moveOn), this._dispatcher.disposables.addFromEvent(this._dispatcher.host, "pointerout", this._out), this._initScaleObserver(), this._initPanObserver();
  }
  /**
   * @deprecated
   * This method is deprecated and will be removed in the future.
   */
  get cumulativeParentScale() {
    return this._cumulativeParentScale;
  }
  get _rect() {
    return this._dispatcher.host.getBoundingClientRect();
  }
  _createContext(t, e) {
    return Ai.from(new en(t), new ia({
      event: t,
      sourceType: js.Target
    }), e);
  }
  /**
   * @deprecated
   * This method is deprecated and will be removed in the future.
   *
   * Required for nested editors
   * Observe the scale of the parent elements and update the cumulative scale
   * This is required to calculate the correct pointer position when the parent elements are scaled
   */
  _initScaleObserver() {
    const t = [];
    let e = this._dispatcher.host;
    for (; e; ) {
      if (Object.hasOwn(e.dataset, "scale")) {
        const s = parseFloat(e.dataset.scale);
        this._cumulativeParentScale *= s, t.push(e);
      }
      e = e.parentElement;
    }
    t.forEach((s) => {
      const i = new MutationObserver((r) => {
        const o = parseFloat(r[0].oldValue), a = parseFloat(s.dataset.scale);
        this._cumulativeParentScale *= a / o, this._dispatcher.slots.parentScaleChanged.emit(this._cumulativeParentScale);
      });
      i.observe(s, {
        attributes: !0,
        attributeFilter: ["data-scale"],
        attributeOldValue: !0
      }), this._dispatcher.disposables.add(() => i.disconnect());
    });
  }
  /**
   * @deprecated
   * This method is deprecated and will be removed in the future.
   *
   * Required for nested editors
   * Observe the position of the parent elements and update the viewport position
   * This is required when parent elements are translated and the viewport should be updated accordingly
   */
  _initPanObserver() {
    const t = [];
    let e = this._dispatcher.host;
    for (; e; )
      Object.hasOwn(e.dataset, "translate") && t.push(e), e = e.parentElement;
    t.forEach((s) => {
      const i = new MutationObserver(() => {
        this._dispatcher.slots.editorHostPanned.emit();
      });
      i.observe(s, {
        attributes: !0,
        attributeFilter: ["style"]
      }), this._dispatcher.disposables.add(() => i.disconnect());
    });
  }
}
class Jx {
  constructor(t) {
    this._dispatcher = t, this._prev = null, this._compositionUpdate = (e) => {
      const s = this._buildScope("compositionUpdate");
      this._dispatcher.run("compositionUpdate", this._createContext(e), s);
    }, this._compositionStart = (e) => {
      const s = this._buildScope("compositionStart");
      this._dispatcher.run("compositionStart", this._createContext(e), s);
    }, this._compositionEnd = (e) => {
      const s = this._buildScope("compositionEnd");
      this._dispatcher.run("compositionEnd", this._createContext(e), s);
    }, this._selectionChange = (e) => {
      const s = document.getSelection();
      if (!s || !s.containsNode(this._dispatcher.host, !0) || s.containsNode(this._dispatcher.host))
        return;
      const i = this._buildScope("selectionChange");
      this._dispatcher.run("selectionChange", this._createContext(e), i);
    }, this._buildScope = (e) => {
      let s;
      const i = document.getSelection();
      if (i && i.rangeCount > 0) {
        const r = i.getRangeAt(0);
        s = this._buildEventScopeByNativeRange(e, r), this._prev = r;
      } else
        this._prev !== null && (s = this._buildEventScopeByNativeRange(e, this._prev), this._prev = null);
      return s;
    };
  }
  listen() {
    this._dispatcher.disposables.addFromEvent(document, "selectionchange", this._selectionChange), this._dispatcher.disposables.addFromEvent(this._dispatcher.host, "compositionstart", this._compositionStart), this._dispatcher.disposables.addFromEvent(this._dispatcher.host, "compositionend", this._compositionEnd), this._dispatcher.disposables.addFromEvent(this._dispatcher.host, "compositionupdate", this._compositionUpdate);
  }
  _createContext(t) {
    return Ai.from(new en(t), new ia({
      event: t,
      sourceType: js.Selection
    }));
  }
  _buildEventScopeByNativeRange(t, e) {
    const i = this._findBlockElementPath(e).map((o) => o).filter((o) => !!o), r = Array.from(new Set(i.flatMap((o) => o.map((a) => {
      var c;
      return (c = this._dispatcher.std.doc.getBlockById(a)) == null ? void 0 : c.flavour;
    })).filter((o) => !!o))).reverse();
    return this._dispatcher.buildEventScope(t, r, i);
  }
  _findBlockElementPath(t) {
    const e = t.startContainer, s = t.endContainer, i = t.commonAncestorContainer, r = (h) => {
      const d = h instanceof Element ? h : h.parentElement;
      return d == null ? void 0 : d.closest("[data-block-id]");
    };
    if (i.nodeType === Node.TEXT_NODE) {
      const h = r(i);
      if (h)
        return [h.path];
    }
    const o = /* @__PURE__ */ new Set();
    let a = !1;
    const c = (h, d) => {
      if (h && h !== d) {
        if (h === s) {
          o.add(h), a = !1;
          return;
        }
        h === e && (a = !0), a && (h.nodeType === Node.TEXT_NODE || h.nodeType === Node.ELEMENT_NODE) && o.add(h), c(h.firstChild, d), c(h.nextSibling, d);
      }
    };
    c(i.firstChild, i);
    const l = /* @__PURE__ */ new Set();
    return o.forEach((h) => {
      const d = r(h);
      d && (l.has(d.path) || l.add(d.path));
    }), Array.from(l);
  }
}
const S_ = [
  "beforeInput",
  "blur",
  "focus",
  "drop",
  "contextMenu",
  "wheel"
], Qx = [
  "click",
  "doubleClick",
  "tripleClick",
  "pointerDown",
  "pointerMove",
  "pointerUp",
  "pointerOut",
  "dragStart",
  "dragMove",
  "dragEnd",
  "keyDown",
  "keyUp",
  "selectionChange",
  "compositionStart",
  "compositionUpdate",
  "compositionEnd",
  "cut",
  "copy",
  "paste",
  ...S_
];
class tE {
  get active() {
    return this._active;
  }
  constructor(t) {
    this.std = t, this.disposables = new as(), this.slots = {
      parentScaleChanged: new lt(),
      editorHostPanned: new lt()
    }, this._handlersMap = Object.fromEntries(Qx.map((e) => [e, []])), this._active = !1, this.bindHotkey = (...e) => this._keyboardControl.bindHotkey(...e), this._pointerControl = new Xx(this), this._keyboardControl = new Zx(this), this._rangeControl = new Jx(this), this._clipboardControl = new Vx(this);
  }
  /**
   * @deprecated
   * This method is deprecated and will be removed in the future.
   */
  get cumulativeParentScale() {
    return this._pointerControl.cumulativeParentScale;
  }
  mount() {
    this.disposables.disposed && (this.disposables = new as()), this._bindEvents();
  }
  unmount() {
    this.disposables.dispose();
  }
  get host() {
    return this.std.host;
  }
  run(t, e, s) {
    if (!this.active)
      return;
    const i = e.get("sourceState");
    if (!(!s && (s = this._getEventScope(t, i), !s)))
      for (const r of s.runners) {
        const { fn: o } = r;
        if (o(e))
          return;
      }
  }
  add(t, e, s) {
    const i = {
      fn: e,
      flavour: s == null ? void 0 : s.flavour,
      path: s == null ? void 0 : s.path
    };
    return this._handlersMap[t].unshift(i), () => {
      this._handlersMap[t].includes(i) && (this._handlersMap[t] = this._handlersMap[t].filter((r) => r !== i));
    };
  }
  get _currentSelections() {
    return this.std.selection.value;
  }
  _getEventScope(t, e) {
    if (!this._handlersMap[t])
      return;
    let i;
    switch (e.sourceType) {
      case js.Selection: {
        i = this._buildEventScopeBySelection(t);
        break;
      }
      case js.Target: {
        i = this._buildEventScopeByTarget(t, e.event.target);
        break;
      }
      default:
        throw new Error(`Unknown event scope source: ${e.sourceType}`);
    }
    return i;
  }
  buildEventScope(t, e, s) {
    const i = this._handlersMap[t];
    if (!i)
      return;
    const r = i.filter((c) => c.flavour === void 0 && c.path === void 0), o = i.filter((c) => {
      const l = c.path;
      return l === void 0 ? !1 : s.some((h) => os.includes(h, l));
    }), a = i.filter((c) => c.flavour && e.includes(c.flavour));
    return {
      runners: o.concat(a).concat(r),
      flavours: e,
      paths: s
    };
  }
  _buildEventScopeByTarget(t, e) {
    if (!this._handlersMap[t])
      return;
    const i = e instanceof Element ? e : e.parentElement, r = i == null ? void 0 : i.closest("[data-block-id]"), o = r == null ? void 0 : r.path;
    if (!o)
      return this._buildEventScopeBySelection(t);
    const a = o.map((c) => {
      var l;
      return (l = this.std.doc.getBlockById(c)) == null ? void 0 : l.flavour;
    }).filter((c) => !!c).reverse();
    return this.buildEventScope(t, a, [o]);
  }
  _buildEventScopeBySelection(t) {
    if (!this._handlersMap[t])
      return;
    const s = this._currentSelections, i = {}, r = s.map((a) => a.path).flatMap((a) => a.map((c) => {
      var l;
      return (l = this.std.doc.getBlockById(c)) == null ? void 0 : l.flavour;
    })).filter((a) => !a || i[a] ? !1 : (i[a] = !0, !0)).reverse(), o = s.map((a) => a.path);
    return this.buildEventScope(t, r, o);
  }
  _bindEvents() {
    S_.forEach((e) => {
      this.disposables.addFromEvent(this.host, qx(e), (s) => {
        this.run(e, Ai.from(new en(s), new ia({
          event: s,
          sourceType: js.Selection
        })));
      });
    }), this._pointerControl.listen(), this._keyboardControl.listen(), this._rangeControl.listen(), this._clipboardControl.listen();
    let t = !1;
    this.disposables.addFromEvent(this.host, "pointerdown", () => {
      t = !0, this._active = !0;
    }), this.disposables.addFromEvent(this.host, "pointerup", () => {
      t = !1;
    }), this.disposables.addFromEvent(this.host, "click", () => {
      this._active = !0;
    }), this.disposables.addFromEvent(this.host, "focusin", () => {
      this._active = !0;
    }), this.disposables.addFromEvent(this.host, "focusout", (e) => {
      e.relatedTarget && !this.host.contains(e.relatedTarget) && (this._active = !1);
    }), this.disposables.addFromEvent(this.host, "pointerenter", () => {
      this._active = !0;
    }), this.disposables.addFromEvent(this.host, "pointerleave", () => {
      (!document.activeElement || !this.host.contains(document.activeElement)) && !t && (this._active = !1);
    });
  }
}
class Yl {
  constructor({ path: t }) {
    this.path = t;
  }
  get blockId() {
    return os.id(this.path);
  }
  is(t) {
    return this.type === t;
  }
  get type() {
    return this.constructor.type;
  }
  get group() {
    return this.constructor.group;
  }
  static fromJSON(t) {
    throw new Error("You must override this method");
  }
}
const eE = U.object({
  path: U.array(U.string())
}), Gi = class Gi extends Yl {
  equals(t) {
    return t instanceof Gi ? os.equals(this.path, t.path) : !1;
  }
  toJSON() {
    return {
      type: "block",
      path: this.path
    };
  }
  static fromJSON(t) {
    return eE.parse(t), new Gi({
      path: t.path
    });
  }
};
Gi.type = "block", Gi.group = "note";
let Qd = Gi;
const sE = U.object({
  x: U.number(),
  y: U.number()
}), Hi = class Hi extends Yl {
  constructor(t, e) {
    super({ path: [] }), this.x = t, this.y = e;
  }
  equals(t) {
    return t instanceof Hi ? this.x === t.x && this.y === t.y : !1;
  }
  toJSON() {
    return {
      type: "cursor",
      x: this.x,
      y: this.y
    };
  }
  static fromJSON(t) {
    return sE.parse(t), new Hi(t.x, t.y);
  }
};
Hi.type = "cursor", Hi.group = "edgeless";
let tu = Hi;
const nE = U.object({
  elements: U.array(U.string()),
  editing: U.boolean(),
  inoperable: U.boolean().optional()
}), zi = class zi extends Yl {
  constructor(t, e, s, i = !1) {
    super({ path: t }), this.elements = e, this.editing = s, this.inoperable = i;
  }
  isEmpty() {
    return this.elements.length === 0 && !this.editing;
  }
  equals(t) {
    return t instanceof zi ? this.blockId === t.blockId && this.elements.length === t.elements.length && this.elements.every((e, s) => e === t.elements[s]) && this.editing === t.editing && this.inoperable === t.inoperable : !1;
  }
  toJSON() {
    return {
      type: "surface",
      path: this.path,
      elements: this.elements,
      editing: this.editing,
      inoperable: this.inoperable
    };
  }
  static fromJSON(t) {
    return nE.parse(t), new zi(t.path, t.elements, t.editing, t.inoperable || !1);
  }
};
zi.type = "surface", zi.group = "edgeless";
let eu = zi;
const iE = U.object({
  from: U.object({
    path: U.array(U.string()),
    index: U.number(),
    length: U.number()
  }),
  to: U.object({
    path: U.array(U.string()),
    index: U.number(),
    length: U.number()
  }).nullable(),
  // The `optional()` is for backward compatibility,
  // since `reverse` may not exist in remote selection.
  reverse: U.boolean().optional()
}), Wi = class Wi extends Yl {
  constructor({ from: t, to: e, reverse: s }) {
    super({
      path: t.path
    }), this.from = t, this.to = this._equalPoint(t, e) ? null : e, this.reverse = !!s;
  }
  get start() {
    return this.reverse ? this.to ?? this.from : this.from;
  }
  get end() {
    return this.reverse ? this.from : this.to ?? this.from;
  }
  empty() {
    return !!this.to;
  }
  _equalPoint(t, e) {
    return t && e ? os.equals(t.path, e.path) && t.index === e.index && t.length === e.length : t === e;
  }
  equals(t) {
    return t instanceof Wi ? os.equals(this.path, t.path) && this._equalPoint(t.from, this.from) && this._equalPoint(t.to, this.to) : !1;
  }
  toJSON() {
    return {
      type: "text",
      from: this.from,
      to: this.to,
      reverse: this.reverse
    };
  }
  static fromJSON(t) {
    return iE.parse(t), new Wi({
      from: t.from,
      to: t.to,
      reverse: !!t.reverse
    });
  }
  isCollapsed() {
    return this.to === null && this.from.length === 0;
  }
  isInSameBlock() {
    return this.to === null || os.equals(this.from.path, this.to.path);
  }
};
Wi.type = "text", Wi.group = "note";
let su = Wi;
class rE {
  constructor(t) {
    this.std = t, this.disposables = new as(), this._selectionConstructors = {}, this.slots = {
      changed: new lt(),
      remoteChanged: new lt()
    }, this._jsonToSelection = (e) => {
      const s = this._selectionConstructors[e.type];
      if (!s)
        throw new Error(`Unknown selection type: ${e.type}`);
      return s.fromJSON(e);
    }, this._itemAdded = (e) => {
      e.stackItem.meta.set("selection-state", this.value);
    }, this._itemPopped = (e) => {
      const s = e.stackItem.meta.get("selection-state");
      s && this.set(s);
    }, this._setupDefaultSelections();
  }
  register(t) {
    return [t].flat().forEach((e) => {
      this._selectionConstructors[e.type] = e;
    }), this;
  }
  get _store() {
    return this.std.collection.awarenessStore;
  }
  _setupDefaultSelections() {
    this.register([
      su,
      Qd,
      eu,
      tu
    ]);
  }
  create(t, ...e) {
    const s = this._selectionConstructors[t];
    if (!s)
      throw new Error(`Unknown selection type: ${t}`);
    return new s(...e);
  }
  get value() {
    return this._store.getLocalSelection(this.std.doc.blockCollection).map((t) => this._jsonToSelection(t));
  }
  fromJSON(t) {
    const e = t.map((s) => this._jsonToSelection(s));
    return this.set(e);
  }
  set(t) {
    this._store.setLocalSelection(this.std.doc.blockCollection, t.map((e) => e.toJSON())), this.slots.changed.emit(t);
  }
  setGroup(t, e) {
    const s = this.value.filter((i) => i.group !== t);
    this.set([...s, ...e]);
  }
  getGroup(t) {
    return this.value.filter((e) => e.group === t);
  }
  update(t) {
    const e = t(this.value);
    this.set(e);
  }
  clear(t) {
    if (t) {
      const e = this.value.filter((s) => !t.includes(s.type));
      this.set(e);
    } else
      this.set([]);
  }
  find(t) {
    return this.value.find((e) => e.is(t));
  }
  filter(t) {
    return this.value.filter((e) => e.is(t));
  }
  get remoteSelections() {
    const t = /* @__PURE__ */ new Map();
    return this._store.getStates().forEach((e, s) => {
      if (s === this._store.awareness.clientID)
        return;
      const r = Object.entries(e.selectionV2).filter(([o]) => o === this.std.doc.id).flatMap(([o, a]) => a).map((o) => {
        try {
          return this._jsonToSelection(o);
        } catch (a) {
          return console.error("Parse remote selection failed:", s, o, a), null;
        }
      }).filter((o) => !!o);
      t.set(s, r);
    }), t;
  }
  mount() {
    this.disposables.disposed && (this.disposables = new as()), this.std.doc.history.on("stack-item-added", this._itemAdded), this.std.doc.history.on("stack-item-popped", this._itemPopped), this.disposables.add(this._store.slots.update.on(({ id: t }) => {
      t !== this._store.awareness.clientID && this.slots.remoteChanged.emit(this.remoteSelections);
    }));
  }
  unmount() {
    this.std.doc.history.off("stack-item-added", this._itemAdded), this.std.doc.history.off("stack-item-popped", this._itemPopped), this.slots.changed.dispose(), this.disposables.dispose(), this.clear();
  }
  dispose() {
    Object.values(this.slots).forEach((t) => t.dispose()), this.disposables.dispose();
  }
}
const oE = () => ({
  mounted: new lt(),
  unmounted: new lt(),
  viewConnected: new lt(),
  viewDisconnected: new lt(),
  widgetConnected: new lt(),
  widgetDisconnected: new lt()
});
class aE {
  constructor(t) {
    this.disposables = new as(), this.flavour = t.flavour, this.std = t.std, this.specSlots = t.slots;
  }
  get collection() {
    return this.std.collection;
  }
  get doc() {
    return this.std.doc;
  }
  get host() {
    return this.std.host;
  }
  get selectionManager() {
    return this.std.selection;
  }
  get uiEventDispatcher() {
    return this.std.event;
  }
  // life cycle start
  dispose() {
    this.disposables.dispose();
  }
  mounted() {
    this.specSlots.mounted.emit({ service: this });
  }
  unmounted() {
    this.specSlots.unmounted.emit({ service: this });
  }
  // life cycle end
  // event handlers start
  handleEvent(t, e, s) {
    this.disposables.add(this.uiEventDispatcher.add(t, e, {
      flavour: s != null && s.global ? void 0 : this.flavour
    }));
  }
  bindHotKey(t, e) {
    this.disposables.add(this.uiEventDispatcher.bindHotkey(t, {
      flavour: e != null && e.global ? void 0 : this.flavour
    }));
  }
}
class cE {
  constructor(t) {
    this.std = t, this._specs = /* @__PURE__ */ new Map(), this._services = /* @__PURE__ */ new Map(), this._disposables = new as();
  }
  mount() {
    this._disposables.disposed && (this._disposables = new as());
  }
  unmount() {
    this._services.forEach((t) => {
      t.dispose(), t.unmounted();
    }), this._services.clear(), this._disposables.dispose();
  }
  applySpecs(t) {
    const e = this._specs, s = this._buildSpecMap(t);
    this._diffServices(e, s), this._specs = s;
  }
  getView(t) {
    const e = this._specs.get(t);
    return e ? e.view : null;
  }
  getService(t) {
    return this._services.get(t);
  }
  _diffServices(t, e) {
    t.forEach((s, i) => {
      var o;
      if (e.has(i) && ((o = e.get(i)) == null ? void 0 : o.service) === s.service)
        return;
      const r = this._services.get(i);
      r && (r.dispose(), r.unmounted()), this._services.delete(i);
    }), e.forEach((s, i) => {
      var c;
      if (this._services.has(i))
        return;
      const r = s.service ?? aE, o = oE(), a = new r({
        flavour: i,
        std: this.std,
        slots: o
      });
      (c = s.setup) == null || c.call(s, o, this._disposables), this._services.set(i, a), a.mounted();
    });
  }
  _buildSpecMap(t) {
    const e = /* @__PURE__ */ new Map();
    return t.forEach((s) => {
      e.set(s.schema.model.flavour, s);
    }), e;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ja = globalThis, wf = ja.ShadowRoot && (ja.ShadyCSS === void 0 || ja.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, C_ = Symbol(), h1 = /* @__PURE__ */ new WeakMap();
let k_ = class {
  constructor(t, e, s) {
    if (this._$cssResult$ = !0, s !== C_)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (wf && t === void 0) {
      const s = e !== void 0 && e.length === 1;
      s && (t = h1.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && h1.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const lE = (n) => new k_(typeof n == "string" ? n : n + "", void 0, C_), hE = (n, t) => {
  if (wf)
    n.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), i = ja.litNonce;
      i !== void 0 && s.setAttribute("nonce", i), s.textContent = e.cssText, n.appendChild(s);
    }
}, d1 = wf ? (n) => n : (n) => n instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return lE(e);
})(n) : n;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: dE, defineProperty: uE, getOwnPropertyDescriptor: fE, getOwnPropertyNames: pE, getOwnPropertySymbols: gE, getPrototypeOf: mE } = Object, fn = globalThis, u1 = fn.trustedTypes, _E = u1 ? u1.emptyScript : "", Fh = fn.reactiveElementPolyfillSupport, Qr = (n, t) => n, _c = { toAttribute(n, t) {
  switch (t) {
    case Boolean:
      n = n ? _E : null;
      break;
    case Object:
    case Array:
      n = n == null ? n : JSON.stringify(n);
  }
  return n;
}, fromAttribute(n, t) {
  let e = n;
  switch (t) {
    case Boolean:
      e = n !== null;
      break;
    case Number:
      e = n === null ? null : Number(n);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(n);
      } catch {
        e = null;
      }
  }
  return e;
} }, Sf = (n, t) => !dE(n, t), f1 = { attribute: !0, type: String, converter: _c, reflect: !1, hasChanged: Sf };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), fn.litPropertyMetadata ?? (fn.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class Fi extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = f1) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), i = this.getPropertyDescriptor(t, s, e);
      i !== void 0 && uE(this.prototype, t, i);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: i, set: r } = fE(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? f1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Qr("elementProperties")))
      return;
    const t = mE(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Qr("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Qr("properties"))) {
      const e = this.properties, s = [...pE(e), ...gE(e)];
      for (const i of s)
        this.createProperty(i, e[i]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, i] of e)
          this.elementProperties.set(s, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const i = this._$Eu(e, s);
      i !== void 0 && this._$Eh.set(i, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const i of s)
        e.unshift(d1(i));
    } else
      t !== void 0 && e.push(d1(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === !1 ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return hE(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var r;
    const s = this.constructor.elementProperties.get(t), i = this.constructor._$Eu(t, s);
    if (i !== void 0 && s.reflect === !0) {
      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : _c).toAttribute(e, s.type);
      this._$Em = t, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r;
    const s = this.constructor, i = s._$Eh.get(t);
    if (i !== void 0 && this._$Em !== i) {
      const o = s.getPropertyOptions(i), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : _c;
      this._$Em = i, this[i] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? Sf)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0)
        for (const [r, o] of i)
          o.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((i) => {
        var r;
        return (r = i.hostUpdate) == null ? void 0 : r.call(i);
      }), this.update(e)) : this._$EU();
    } catch (i) {
      throw t = !1, this._$EU(), i;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var i;
      return (i = s.hostUpdated) == null ? void 0 : i.call(s);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
Fi.elementStyles = [], Fi.shadowRootOptions = { mode: "open" }, Fi[Qr("elementProperties")] = /* @__PURE__ */ new Map(), Fi[Qr("finalized")] = /* @__PURE__ */ new Map(), Fh == null || Fh({ ReactiveElement: Fi }), (fn.reactiveElementVersions ?? (fn.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const to = globalThis, yc = to.trustedTypes, p1 = yc ? yc.createPolicy("lit-html", { createHTML: (n) => n }) : void 0, Cf = "$lit$", Ls = `lit$${Math.random().toFixed(9).slice(2)}$`, kf = "?" + Ls, yE = `<${kf}>`, li = document, No = () => li.createComment(""), Lo = (n) => n === null || typeof n != "object" && typeof n != "function", x_ = Array.isArray, E_ = (n) => x_(n) || typeof (n == null ? void 0 : n[Symbol.iterator]) == "function", Bh = `[ 	
\f\r]`, Vr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, g1 = /-->/g, m1 = />/g, Un = RegExp(`>|${Bh}(?:([^\\s"'>=/]+)(${Bh}*=${Bh}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), _1 = /'/g, y1 = /"/g, T_ = /^(?:script|style|textarea|title)$/i, vE = (n) => (t, ...e) => ({ _$litType$: n, strings: t, values: e }), hi = vE(1), En = Symbol.for("lit-noChange"), Ft = Symbol.for("lit-nothing"), v1 = /* @__PURE__ */ new WeakMap(), jn = li.createTreeWalker(li, 129);
function A_(n, t) {
  if (!Array.isArray(n) || !n.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return p1 !== void 0 ? p1.createHTML(t) : t;
}
const I_ = (n, t) => {
  const e = n.length - 1, s = [];
  let i, r = t === 2 ? "<svg>" : "", o = Vr;
  for (let a = 0; a < e; a++) {
    const c = n[a];
    let l, h, d = -1, u = 0;
    for (; u < c.length && (o.lastIndex = u, h = o.exec(c), h !== null); )
      u = o.lastIndex, o === Vr ? h[1] === "!--" ? o = g1 : h[1] !== void 0 ? o = m1 : h[2] !== void 0 ? (T_.test(h[2]) && (i = RegExp("</" + h[2], "g")), o = Un) : h[3] !== void 0 && (o = Un) : o === Un ? h[0] === ">" ? (o = i ?? Vr, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, l = h[1], o = h[3] === void 0 ? Un : h[3] === '"' ? y1 : _1) : o === y1 || o === _1 ? o = Un : o === g1 || o === m1 ? o = Vr : (o = Un, i = void 0);
    const f = o === Un && n[a + 1].startsWith("/>") ? " " : "";
    r += o === Vr ? c + yE : d >= 0 ? (s.push(l), c.slice(0, d) + Cf + c.slice(d) + Ls + f) : c + Ls + (d === -2 ? a : f);
  }
  return [A_(n, r + (n[e] || "<?>") + (t === 2 ? "</svg>" : "")), s];
};
class Uo {
  constructor({ strings: t, _$litType$: e }, s) {
    let i;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, c = this.parts, [l, h] = I_(t, e);
    if (this.el = Uo.createElement(l, s), jn.currentNode = this.el.content, e === 2) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (i = jn.nextNode()) !== null && c.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes())
          for (const d of i.getAttributeNames())
            if (d.endsWith(Cf)) {
              const u = h[o++], f = i.getAttribute(d).split(Ls), p = /([.?@])?(.*)/.exec(u);
              c.push({ type: 1, index: r, name: p[2], strings: f, ctor: p[1] === "." ? D_ : p[1] === "?" ? P_ : p[1] === "@" ? M_ : ra }), i.removeAttribute(d);
            } else
              d.startsWith(Ls) && (c.push({ type: 6, index: r }), i.removeAttribute(d));
        if (T_.test(i.tagName)) {
          const d = i.textContent.split(Ls), u = d.length - 1;
          if (u > 0) {
            i.textContent = yc ? yc.emptyScript : "";
            for (let f = 0; f < u; f++)
              i.append(d[f], No()), jn.nextNode(), c.push({ type: 2, index: ++r });
            i.append(d[u], No());
          }
        }
      } else if (i.nodeType === 8)
        if (i.data === kf)
          c.push({ type: 2, index: r });
        else {
          let d = -1;
          for (; (d = i.data.indexOf(Ls, d + 1)) !== -1; )
            c.push({ type: 7, index: r }), d += Ls.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = li.createElement("template");
    return s.innerHTML = t, s;
  }
}
function di(n, t, e = n, s) {
  var o, a;
  if (t === En)
    return t;
  let i = s !== void 0 ? (o = e._$Co) == null ? void 0 : o[s] : e._$Cl;
  const r = Lo(t) ? void 0 : t._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== r && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), r === void 0 ? i = void 0 : (i = new r(n), i._$AT(n, e, s)), s !== void 0 ? (e._$Co ?? (e._$Co = []))[s] = i : e._$Cl = i), i !== void 0 && (t = di(n, i._$AS(n, t.values), i, s)), t;
}
class O_ {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, i = ((t == null ? void 0 : t.creationScope) ?? li).importNode(e, !0);
    jn.currentNode = i;
    let r = jn.nextNode(), o = 0, a = 0, c = s[0];
    for (; c !== void 0; ) {
      if (o === c.index) {
        let l;
        c.type === 2 ? l = new Ir(r, r.nextSibling, this, t) : c.type === 1 ? l = new c.ctor(r, c.name, c.strings, this, t) : c.type === 6 && (l = new R_(r, this, t)), this._$AV.push(l), c = s[++a];
      }
      o !== (c == null ? void 0 : c.index) && (r = jn.nextNode(), o++);
    }
    return jn.currentNode = li, i;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
}
class Ir {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, s, i) {
    this.type = 2, this._$AH = Ft, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = di(this, t, e), Lo(t) ? t === Ft || t == null || t === "" ? (this._$AH !== Ft && this._$AR(), this._$AH = Ft) : t !== this._$AH && t !== En && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : E_(t) ? this.k(t) : this._(t);
  }
  S(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));
  }
  _(t) {
    this._$AH !== Ft && Lo(this._$AH) ? this._$AA.nextSibling.data = t : this.T(li.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: s } = t, i = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Uo.createElement(A_(s.h, s.h[0]), this.options)), s);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === i)
      this._$AH.p(e);
    else {
      const o = new O_(i, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = v1.get(t.strings);
    return e === void 0 && v1.set(t.strings, e = new Uo(t)), e;
  }
  k(t) {
    x_(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, i = 0;
    for (const r of t)
      i === e.length ? e.push(s = new Ir(this.S(No()), this.S(No()), this, this.options)) : s = e[i], s._$AI(r), i++;
    i < e.length && (this._$AR(s && s._$AB.nextSibling, i), e.length = i);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
}
class ra {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, i, r) {
    this.type = 1, this._$AH = Ft, this._$AN = void 0, this.element = t, this.name = e, this._$AM = i, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = Ft;
  }
  _$AI(t, e = this, s, i) {
    const r = this.strings;
    let o = !1;
    if (r === void 0)
      t = di(this, t, e, 0), o = !Lo(t) || t !== this._$AH && t !== En, o && (this._$AH = t);
    else {
      const a = t;
      let c, l;
      for (t = r[0], c = 0; c < r.length - 1; c++)
        l = di(this, a[s + c], e, c), l === En && (l = this._$AH[c]), o || (o = !Lo(l) || l !== this._$AH[c]), l === Ft ? t = Ft : t !== Ft && (t += (l ?? "") + r[c + 1]), this._$AH[c] = l;
    }
    o && !i && this.j(t);
  }
  j(t) {
    t === Ft ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class D_ extends ra {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === Ft ? void 0 : t;
  }
}
class P_ extends ra {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== Ft);
  }
}
class M_ extends ra {
  constructor(t, e, s, i, r) {
    super(t, e, s, i, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = di(this, t, e, 0) ?? Ft) === En)
      return;
    const s = this._$AH, i = t === Ft && s !== Ft || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== Ft && (s === Ft || i);
    i && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class R_ {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    di(this, t);
  }
}
const bE = { P: Cf, A: Ls, C: kf, M: 1, L: I_, R: O_, D: E_, V: di, I: Ir, H: ra, N: P_, U: M_, B: D_, F: R_ }, Vh = to.litHtmlPolyfillSupport;
Vh == null || Vh(Uo, Ir), (to.litHtmlVersions ?? (to.litHtmlVersions = [])).push("3.1.3");
const $_ = (n, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let i = s._$litPart$;
  if (i === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = i = new Ir(t.insertBefore(No(), r), r, void 0, e ?? {});
  }
  return i._$AI(n), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Ss = class extends Fi {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = $_(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return En;
  }
};
var x1;
Ss._$litElement$ = !0, Ss.finalized = !0, (x1 = globalThis.litElementHydrateSupport) == null || x1.call(globalThis, { LitElement: Ss });
const jh = globalThis.litElementPolyfillSupport;
jh == null || jh({ LitElement: Ss });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.5");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Zl = (n) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    customElements.define(n, t);
  }) : customElements.define(n, t);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const wE = { attribute: !0, type: String, converter: _c, reflect: !1, hasChanged: Sf }, SE = (n = wE, t, e) => {
  const { kind: s, metadata: i } = e;
  let r = globalThis.litPropertyMetadata.get(i);
  if (r === void 0 && globalThis.litPropertyMetadata.set(i, r = /* @__PURE__ */ new Map()), r.set(e.name, n), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const c = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, c, n);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, n), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const c = this[o];
      t.call(this, a), this.requestUpdate(o, c, n);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function oe(n) {
  return (t, e) => typeof e == "object" ? SE(n, t, e) : ((s, i, r) => {
    const o = i.hasOwnProperty(r);
    return i.constructor.createProperty(r, o ? { ...s, wrapped: !0 } : s), o ? Object.getOwnPropertyDescriptor(i, r) : void 0;
  })(n, t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function CE(n) {
  return oe({ ...n, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function kE(n, t, e) {
  return n ? t(n) : e == null ? void 0 : e(n);
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const N_ = Symbol.for(""), xE = (n) => {
  if ((n == null ? void 0 : n.r) === N_)
    return n == null ? void 0 : n._$litStatic$;
}, b1 = (n) => ({ _$litStatic$: n, r: N_ }), w1 = /* @__PURE__ */ new Map(), EE = (n) => (t, ...e) => {
  const s = e.length;
  let i, r;
  const o = [], a = [];
  let c, l = 0, h = !1;
  for (; l < s; ) {
    for (c = t[l]; l < s && (r = e[l], (i = xE(r)) !== void 0); )
      c += i + t[++l], h = !0;
    l !== s && a.push(r), o.push(c), l++;
  }
  if (l === s && o.push(t[s]), h) {
    const d = o.join("$$lit$$");
    (t = w1.get(d)) === void 0 && (o.raw = o, w1.set(d, t = o)), e = a;
  }
  return n(t, ...e);
}, Bn = EE(hi);
function xf(n) {
  class t extends n {
    constructor() {
      super(...arguments), this._disposables = new as();
    }
    get disposables() {
      return this._disposables;
    }
    connectedCallback() {
      super.connectedCallback(), this._disposables.disposed && (this._disposables = new as());
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this._disposables.dispose();
    }
  }
  return t;
}
const Uf = class Uf extends Ss {
  static finalizeStyles(t) {
    let e = super.finalizeStyles(t);
    return this.disableShadowRoot && (e.forEach((s) => {
      if (s instanceof k_ && typeof document < "u") {
        const i = document.head, r = document.createElement("style");
        r.textContent = s.cssText, i.append(r);
      } else
        console.error("unreachable");
    }), e = []), e;
  }
  createRenderRoot() {
    return this.constructor.disableShadowRoot ? this : super.createRenderRoot();
  }
};
Uf.disableShadowRoot = !0;
let vc = Uf;
var Ii = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
};
class $n extends xf(vc) {
  constructor() {
    super(...arguments), this.content = null, this.dirty = !1, this.selected = null, this.handleEvent = (t, e, s) => {
      B(this.path, "Cannot bind block level hotkey without path");
      const i = {
        flavour: s != null && s.global ? void 0 : s != null && s.flavour ? this.model.flavour : void 0,
        path: s != null && s.global || s != null && s.flavour ? void 0 : this.path
      };
      this._disposables.add(this.host.event.add(t, e, i));
    }, this.renderChildren = (t) => this.host.renderChildren(t);
  }
  get parentPath() {
    return this.path.slice(0, -1);
  }
  get parentBlockElement() {
    const t = this.parentElement;
    return t == null ? void 0 : t.closest("[data-block-id]");
  }
  get childBlockElements() {
    return this.model.children.map((e) => this.std.view.getBlock(e.id)).filter((e) => !!e);
  }
  get rootElement() {
    var s;
    const t = (s = this.doc.root) == null ? void 0 : s.id;
    return t ? this.host.view.getBlock(t) ?? null : null;
  }
  get topContenteditableElement() {
    return this.rootElement;
  }
  get flavour() {
    return this.model.flavour;
  }
  get widgetElements() {
    return Object.keys(this.widgets).reduce((t, e) => ({
      ...t,
      [e]: this.host.view.viewFromPath("widget", [...this.path, e])
    }), {});
  }
  get selection() {
    return this.host.selection;
  }
  get std() {
    return this.host.std;
  }
  get isVersionMismatch() {
    const t = this.doc.schema.flavourSchemaMap.get(this.model.flavour);
    B(t, `Cannot find schema for flavour ${this.model.flavour}`);
    const e = t.version, s = this.model.version;
    return e !== s ? (console.warn(`Version mismatch for block ${this.model.id}, expected ${e}, actual ${s}`), !0) : !1;
  }
  bindHotKey(t, e) {
    B(this.path, "Cannot bind block level hotkey without path");
    const s = {
      flavour: e != null && e.global ? void 0 : e != null && e.flavour ? this.model.flavour : void 0,
      path: e != null && e.global || e != null && e.flavour ? void 0 : this.path
    };
    this._disposables.add(this.host.event.bindHotkey(t, s));
  }
  async getUpdateComplete() {
    const t = await super.getUpdateComplete();
    return await Promise.all(this.childBlockElements.map((e) => e.updateComplete)), t;
  }
  update(t) {
    this.dirty ? (this.__reflectingProperties && (this.__reflectingProperties = this.__reflectingProperties.forEach((e) => (
      //@ts-ignore
      this.__propertyToAttribute(e, this[e])
    ))), this._$changedProperties = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.__childPart = $_(Ft, this.renderRoot), this.updateComplete.then(() => {
      this.dirty = !1;
    }).catch(console.error)) : super.update(t);
  }
  connectedCallback() {
    super.connectedCallback(), this.std.view.setBlock(this);
    const t = this.std.doc.slots.blockUpdated.on(({ type: e, id: s }) => {
      s === this.model.id && e === "delete" && (this.std.view.deleteBlock(this), t.dispose());
    });
    this.service = this.host.std.spec.getService(this.model.flavour), this.path = this.host.view.calculatePath(this), this._disposables.add(this.model.propsUpdated.on(() => {
      this.requestUpdate();
    })), this._disposables.add(this.model.childrenUpdated.on(() => {
      this.requestUpdate();
    })), this._disposables.add(this.host.selection.slots.changed.on((e) => {
      const s = e.find((i) => os.equals(i.path, this.path));
      if (!s) {
        this.selected = null;
        return;
      }
      this.selected = s;
    })), this.service.specSlots.viewConnected.emit({
      service: this.service,
      component: this
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.service.specSlots.viewDisconnected.emit({
      service: this.service,
      component: this
    });
  }
  renderBlock() {
    return Ft;
  }
  renderVersionMismatch(t, e) {
    return Bn`
      <dl class="version-mismatch-warning" contenteditable="false">
        <dt>
          <h4>Block Version Mismatched</h4>
        </dt>
        <dd>
          <p>
            We can not render this <var>${this.model.flavour}</var> block
            because the version is mismatched.
          </p>
          <p>Editor version: <var>${t}</var></p>
          <p>Data version: <var>${e}</var></p>
        </dd>
      </dl>
    `;
  }
  render() {
    return kE(this.isVersionMismatch, () => {
      const t = this.doc.schema.flavourSchemaMap.get(this.model.flavour);
      B(t, `Cannot find schema for flavour ${this.model.flavour}`);
      const e = t.version, s = this.model.version;
      return this.renderVersionMismatch(e, s);
    }, () => this.renderBlock());
  }
}
Ii([
  oe({ attribute: !1 })
], $n.prototype, "host", void 0);
Ii([
  oe({ attribute: !1 })
], $n.prototype, "model", void 0);
Ii([
  oe({ attribute: !1 })
], $n.prototype, "content", void 0);
Ii([
  oe({
    attribute: !1,
    hasChanged(n, t) {
      return !n || !t ? n !== t : !Object.keys(n).length && !Object.keys(t).length ? !1 : n !== t;
    }
  })
], $n.prototype, "widgets", void 0);
Ii([
  oe({ attribute: !1 })
], $n.prototype, "doc", void 0);
Ii([
  oe({ attribute: !1 })
], $n.prototype, "dirty", void 0);
Ii([
  CE({
    hasChanged(n, t) {
      return !n || !t ? n !== t : !(n != null && n.equals(t));
    }
  })
], $n.prototype, "selected", void 0);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const L_ = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, U_ = (n) => (...t) => ({ _$litDirective$: n, values: t });
let F_ = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, s) {
    this._$Ct = t, this._$AM = e, this._$Ci = s;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { I: TE } = bE, S1 = () => document.createComment(""), jr = (n, t, e) => {
  var r;
  const s = n._$AA.parentNode, i = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const o = s.insertBefore(S1(), i), a = s.insertBefore(S1(), i);
    e = new TE(o, a, n, n.options);
  } else {
    const o = e._$AB.nextSibling, a = e._$AM, c = a !== n;
    if (c) {
      let l;
      (r = e._$AQ) == null || r.call(e, n), e._$AM = n, e._$AP !== void 0 && (l = n._$AU) !== a._$AU && e._$AP(l);
    }
    if (o !== i || c) {
      let l = e._$AA;
      for (; l !== o; ) {
        const h = l.nextSibling;
        s.insertBefore(l, i), l = h;
      }
    }
  }
  return e;
}, Fn = (n, t, e = n) => (n._$AI(t, e), n), AE = {}, IE = (n, t = AE) => n._$AH = t, OE = (n) => n._$AH, Gh = (n) => {
  var s;
  (s = n._$AP) == null || s.call(n, !1, !0);
  let t = n._$AA;
  const e = n._$AB.nextSibling;
  for (; t !== e; ) {
    const i = t.nextSibling;
    t.remove(), t = i;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const C1 = (n, t, e) => {
  const s = /* @__PURE__ */ new Map();
  for (let i = t; i <= e; i++)
    s.set(n[i], i);
  return s;
}, DE = U_(class extends F_ {
  constructor(n) {
    if (super(n), n.type !== L_.CHILD)
      throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let s;
    e === void 0 ? e = t : t !== void 0 && (s = t);
    const i = [], r = [];
    let o = 0;
    for (const a of n)
      i[o] = s ? s(a, o) : o, r[o] = e(a, o), o++;
    return { values: r, keys: i };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, s]) {
    const i = OE(n), { values: r, keys: o } = this.dt(t, e, s);
    if (!Array.isArray(i))
      return this.ut = o, r;
    const a = this.ut ?? (this.ut = []), c = [];
    let l, h, d = 0, u = i.length - 1, f = 0, p = r.length - 1;
    for (; d <= u && f <= p; )
      if (i[d] === null)
        d++;
      else if (i[u] === null)
        u--;
      else if (a[d] === o[f])
        c[f] = Fn(i[d], r[f]), d++, f++;
      else if (a[u] === o[p])
        c[p] = Fn(i[u], r[p]), u--, p--;
      else if (a[d] === o[p])
        c[p] = Fn(i[d], r[p]), jr(n, c[p + 1], i[d]), d++, p--;
      else if (a[u] === o[f])
        c[f] = Fn(i[u], r[f]), jr(n, i[d], i[u]), u--, f++;
      else if (l === void 0 && (l = C1(o, f, p), h = C1(a, d, u)), l.has(a[d]))
        if (l.has(a[u])) {
          const m = h.get(o[f]), _ = m !== void 0 ? i[m] : null;
          if (_ === null) {
            const v = jr(n, i[d]);
            Fn(v, r[f]), c[f] = v;
          } else
            c[f] = Fn(_, r[f]), jr(n, i[d], _), i[m] = null;
          f++;
        } else
          Gh(i[u]), u--;
      else
        Gh(i[d]), d++;
    for (; f <= p; ) {
      const m = jr(n, c[p + 1]);
      Fn(m, r[f]), c[f++] = m;
    }
    for (; d <= u; ) {
      const m = i[d++];
      m !== null && Gh(m);
    }
    return this.ut = o, IE(n, c), En;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const B_ = "important", PE = " !" + B_, ql = U_(class extends F_ {
  constructor(n) {
    var t;
    if (super(n), n.type !== L_.ATTRIBUTE || n.name !== "style" || ((t = n.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return Object.keys(n).reduce((t, e) => {
      const s = n[e];
      return s == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
    }, "");
  }
  update(n, [t]) {
    const { style: e } = n.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const s of this.ft)
      t[s] == null && (this.ft.delete(s), s.includes("-") ? e.removeProperty(s) : e[s] = null);
    for (const s in t) {
      const i = t[s];
      if (i != null) {
        this.ft.add(s);
        const r = typeof i == "string" && i.endsWith(PE);
        s.includes("-") || r ? e.setProperty(s, r ? i.slice(0, -11) : i, r ? B_ : "") : e[s] = i;
      }
    }
    return En;
  }
}), Ef = "", bc = "data-v-root";
function ME(n) {
  const t = n.closest(`[${bc}]`);
  B(t, "element must be inside a v-root");
  const e = t.inlineEditor;
  return B(e, "element must be inside a v-root with inline-editor"), e;
}
var Tf = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
};
let wc = class extends Ss {
  constructor() {
    super(...arguments), this.delta = {
      insert: Ef
    };
  }
  render() {
    const t = ME(this), e = t.attributeService.attributeRenderer;
    if (t.isEmbed(this.delta)) {
      if (this.delta.insert.length !== 1)
        throw new Error(`The length of embed node should only be 1.
          This seems to be an internal issue with inline editor.
          Please go to https://github.com/toeverything/blocksuite/issues
          to report it.`);
      return hi`<span
        data-v-embed="true"
        data-v-element="true"
        contenteditable="false"
        style=${ql({ userSelect: "none" })}
        >${e(this.delta, this.selected)}</span
      >`;
    }
    return hi`<span data-v-element="true"
      >${e(this.delta, this.selected)}</span
    >`;
  }
  createRenderRoot() {
    return this;
  }
};
Tf([
  oe({ type: Object })
], wc.prototype, "delta", void 0);
Tf([
  oe({ attribute: !1 })
], wc.prototype, "selected", void 0);
wc = Tf([
  Zl("v-element")
], wc);
const Ta = hi`<span
  data-v-embed-gap="true"
  style=${ql({
  userSelect: "text",
  padding: "0 0.5px",
  outline: "none"
})}
  ><v-text></v-text
></span>`;
var V_ = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
};
let nu = class extends Ss {
  constructor() {
    super(...arguments), this.elements = [];
  }
  get inlineEditor() {
    const t = this.closest(`[${bc}]`);
    B(t, "v-line must be inside a v-root");
    const e = t.inlineEditor;
    return B(e, "v-line must be inside a v-root with inline-editor"), e;
  }
  get vElements() {
    return Array.from(this.querySelectorAll("v-element"));
  }
  // vTexts.length > 0 does not mean the line is not empty,
  // you should use vElements.length or vTextLength because v-element corresponds to the actual delta
  get vTexts() {
    return Array.from(this.querySelectorAll("v-text"));
  }
  get vTextLength() {
    return this.vElements.reduce((t, e) => t + e.delta.insert.length, 0);
  }
  get vTextContent() {
    return this.vElements.reduce((t, e) => t + e.delta.insert, "");
  }
  async getUpdateComplete() {
    const t = await super.getUpdateComplete();
    return await Promise.all(this.vElements.map((e) => e.updateComplete)), await Promise.all(this.vTexts.map((e) => e.updateComplete)), t;
  }
  firstUpdated() {
    this.style.display = "block", this.addEventListener("mousedown", (t) => {
      if (t.detail >= 3) {
        t.preventDefault();
        const e = document.createRange();
        e.selectNodeContents(this);
        const s = window.getSelection();
        B(s), s.removeAllRanges(), s.addRange(e);
      }
    });
  }
  render() {
    if (this.elements.length === 0)
      return hi`<div><v-text .str=${Ef}></v-text></div>`;
    if (!this.isConnected)
      return;
    const t = this.inlineEditor, e = this.elements.flatMap(([s, i], r) => {
      var o, a;
      if (t.isEmbed(i)) {
        if (i.insert.length !== 1)
          throw new Error(`The length of embed node should only be 1.
            This seems to be an internal issue with inline editor.
            Please go to https://github.com/toeverything/blocksuite/issues
            to report it.`);
        if (r === 0) {
          const c = (o = this.elements[r + 1]) == null ? void 0 : o[1];
          return !c || t.isEmbed(c) ? [Ta, s, Ta] : [Ta, s];
        } else {
          const c = (a = this.elements[r + 1]) == null ? void 0 : a[1];
          return !c || t.isEmbed(c) ? [s, Ta] : [s];
        }
      }
      return s;
    });
    return hi`<div style=${ql({
      // this padding is used to make cursor can be placed at the
      // start and end of the line when the first and last element is embed element
      padding: "0 0.5px",
      display: "inline-block"
    })}>${e}</div>`;
  }
  createRenderRoot() {
    return this;
  }
};
V_([
  oe({ attribute: !1 })
], nu.prototype, "elements", void 0);
nu = V_([
  Zl("v-line")
], nu);
var Af = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
};
let Sc = class extends Ss {
  constructor() {
    super(...arguments), this.str = Ef, this.styles = {
      "word-break": "break-word",
      "white-space": "pre-wrap",
      cursor: "text"
    };
  }
  render() {
    return hi`<span style=${ql(this.styles)} data-v-text="true"
      >${this.str}</span
    >`;
  }
  createRenderRoot() {
    return this;
  }
};
Af([
  oe({ attribute: !1 })
], Sc.prototype, "str", void 0);
Af([
  oe({ attribute: !1 })
], Sc.prototype, "styles", void 0);
Sc = Af([
  Zl("v-text")
], Sc);
U.object({
  bold: U.literal(!0).optional().nullable().catch(void 0),
  italic: U.literal(!0).optional().nullable().catch(void 0),
  underline: U.literal(!0).optional().nullable().catch(void 0),
  strike: U.literal(!0).optional().nullable().catch(void 0),
  code: U.literal(!0).optional().nullable().catch(void 0),
  link: U.string().optional().nullable().catch(void 0)
});
class RE {
  get selectionManager() {
    return this.host.selection;
  }
  get rangeManager() {
    return B(this.host.rangeManager), this.host.rangeManager;
  }
  get host() {
    return this.manager.host;
  }
  constructor(t) {
    this.manager = t, this.isComposing = !1, this._prevTextSelection = null, this._onStdSelectionChanged = (e) => {
      this.host.updateComplete.then(() => {
        const s = e.find((r) => r.is("text")) ?? null;
        (s && this._prevTextSelection ? s.equals(this._prevTextSelection) : s === this._prevTextSelection) || (this._prevTextSelection = s, s ? this.rangeManager.syncTextSelectionToRange(s) : this.rangeManager.clear());
      }).catch(console.error);
    }, this._onNativeSelectionChanged = async () => {
      if (this.isComposing)
        return;
      await this.host.updateComplete;
      const e = document.getSelection();
      if (!e) {
        this.selectionManager.clear(["text"]);
        return;
      }
      const s = e.rangeCount > 0 ? e.getRangeAt(0) : null, i = !!e.anchorNode && !!e.focusNode && (e.anchorNode === e.focusNode ? e.anchorOffset > e.focusOffset : e.anchorNode.compareDocumentPosition(e.focusNode) === Node.DOCUMENT_POSITION_PRECEDING);
      if (s) {
        const r = s.commonAncestorContainer instanceof Element ? s.commonAncestorContainer : s.commonAncestorContainer.parentElement;
        if (!r)
          return;
        const o = r.closest(`[${this.host.blockIdAttr}]`);
        if ((o == null ? void 0 : o.getAttribute(Cc.rangeSyncExcludeAttr)) === "true")
          return;
        const a = this.rangeManager.getClosestInlineEditor(s.commonAncestorContainer);
        if (a != null && a.isComposing)
          return;
        this._prevTextSelection = this.rangeManager.rangeToTextSelection(s, i), this.rangeManager.syncRangeToTextSelection(s, i);
      } else
        this._prevTextSelection = null, this.selectionManager.clear(["text"]);
    }, this._onBeforeInput = (e) => {
      var f;
      const s = this.selectionManager.find("text");
      if (!s || e.isComposing)
        return;
      const { from: i, to: r } = s;
      if (!r || os.equals(i.path, r.path))
        return;
      const o = this.rangeManager.value;
      if (!o)
        return;
      const a = this.rangeManager.getSelectedBlockElementsByRange(o, {
        mode: "flat"
      }), c = a.at(0), l = a.at(-1);
      if (!c || !l)
        return;
      const h = c.model.text, d = l.model.text;
      if (!h || !d)
        return;
      e.preventDefault(), this.host.doc.transact(() => {
        h.delete(i.index, i.length), h.insert(e.data ?? "", i.index), d.delete(0, r.length), h.join(d), a.slice(1).reverse().forEach((p) => {
          const m = this.host.doc.getParent(p.model);
          B(m), this.host.doc.deleteBlock(p.model, {
            bringChildrenTo: m
          });
        });
      });
      const u = this.selectionManager.create("text", {
        from: {
          path: i.path,
          index: i.index + (((f = e.data) == null ? void 0 : f.length) ?? 0),
          length: 0
        },
        to: null
      });
      this.selectionManager.set([u]);
    }, this._compositionStartCallback = null, this._onCompositionStart = () => {
      const e = this.selectionManager.find("text");
      if (!e)
        return;
      const { from: s, to: i } = e;
      if (!i)
        return;
      this.isComposing = !0;
      const r = this.rangeManager.value;
      if (!r)
        return;
      const o = this.rangeManager.getSelectedBlockElementsByRange(r, {
        mode: "flat"
      }), a = this.rangeManager.getSelectedBlockElementsByRange(r, {
        mode: "highest",
        match: (u) => u.model.role === "content"
      }), c = o.at(0), l = o.at(-1);
      if (!c || !l)
        return;
      const h = c.model.text, d = l.model.text;
      !h || !d || (this._compositionStartCallback = async (u) => {
        var m;
        this.isComposing = !1;
        const f = [];
        for (const _ of a) {
          const v = this.host.view.getParent(_.path);
          !(v instanceof $n) || f.includes(v) || (v.dirty = !0, await v.updateComplete, await v.updateComplete, f.push(v));
        }
        this.host.doc.transact(() => {
          d.delete(0, i.length), h.join(d), o.slice(1).reverse().forEach((_) => {
            const v = this.host.doc.getParent(_.model);
            B(v), this.host.doc.deleteBlock(_.model, {
              bringChildrenTo: v
            });
          });
        }), await this.host.updateComplete;
        const p = this.selectionManager.create("text", {
          from: {
            path: s.path,
            index: s.index + (((m = u.data) == null ? void 0 : m.length) ?? 0),
            length: 0
          },
          to: null
        });
        this.host.selection.set([p]), this.rangeManager.syncTextSelectionToRange(p);
      });
    }, this._onCompositionEnd = (e) => {
      this._compositionStartCallback && (e.preventDefault(), this._compositionStartCallback(e).catch(console.error), this._compositionStartCallback = null);
    }, this.host.disposables.add(this.selectionManager.slots.changed.on(this._onStdSelectionChanged)), this.host.disposables.addFromEvent(document, "selectionchange", qy(() => {
      this._onNativeSelectionChanged().catch(console.error);
    }, 10)), this.host.disposables.add(this.host.event.add("beforeInput", (e) => {
      const s = e.get("defaultState").event;
      this._onBeforeInput(s);
    })), this.host.disposables.add(this.host.event.add("compositionStart", this._onCompositionStart)), this.host.disposables.add(this.host.event.add("compositionEnd", (e) => {
      const s = e.get("defaultState").event;
      this._onCompositionEnd(s);
    }));
  }
}
const Ki = class Ki {
  constructor(t) {
    this.host = t, this.binding = new RE(this);
  }
  get value() {
    const t = document.getSelection();
    return B(t), t.rangeCount === 0 ? null : t.getRangeAt(0);
  }
  clear() {
    const t = document.getSelection();
    B(t), t.removeAllRanges();
    const e = this.host.querySelector('[contenteditable="true"]');
    e instanceof HTMLElement && e.blur(), document.activeElement instanceof HTMLElement && document.activeElement.blur();
  }
  set(t) {
    const e = document.getSelection();
    B(e), e.removeAllRanges(), e.addRange(t);
  }
  syncTextSelectionToRange(t) {
    const e = this.textSelectionToRange(t);
    e ? this.set(e) : this.clear();
  }
  syncRangeToTextSelection(t, e) {
    const s = this.host.selection;
    if (!t) {
      s.clear(["text"]);
      return;
    }
    const i = this.rangeToTextSelection(t, e);
    i ? s.setGroup("note", [i]) : s.clear(["text"]);
  }
  /**
   * @example
   * aaa
   *   b[bb
   *     ccc
   * ddd
   *   ee]e
   *
   * all mode: [aaa, bbb, ccc, ddd, eee]
   * flat mode: [bbb, ccc, ddd, eee]
   * highest mode: [bbb, ddd]
   *
   * match function will be evaluated before filtering using mode
   */
  getSelectedBlockElementsByRange(t, e = {}) {
    const { mode: s = "all", match: i = () => !0 } = e;
    let r = Array.from(this.host.querySelectorAll(`[${this.host.blockIdAttr}]:not([${Ki.rangeQueryExcludeAttr}="true"])`)).filter((a) => t.intersectsNode(a) && i(a));
    if (r.length === 0)
      return [];
    const o = this.getClosestBlock(t.startContainer);
    if (B(o), s === "flat")
      r = r.filter((a) => o.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_FOLLOWING || a === o);
    else if (s === "highest") {
      let a = r[0];
      r = r.filter((c, l) => l === 0 ? !0 : a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_CONTAINED_BY ? !1 : (a = c, !0));
    }
    return r;
  }
  textSelectionToRange(t) {
    const { from: e, to: s } = t, i = this.queryInlineEditorByPath(e.path);
    if (!i)
      return null;
    if (t.isInSameBlock())
      return i.toDomRange({
        index: e.index,
        length: e.length
      });
    {
      B(s);
      const r = this.queryInlineEditorByPath(s.path);
      if (!r)
        return null;
      const o = i.toDomRange({
        index: e.index,
        length: e.length
      }), a = r.toDomRange({
        index: s.index,
        length: s.length
      });
      if (!o || !a)
        return null;
      const c = document.createRange(), l = o.startContainer, h = o.startOffset, d = a.endContainer, u = a.endOffset;
      return c.setStart(l, h), c.setEnd(d, u), c;
    }
  }
  rangeToTextSelection(t, e = !1) {
    const { startContainer: s, endContainer: i } = t, r = this.getClosestBlock(s), o = this.getClosestBlock(i);
    if (!r || !o)
      return null;
    const a = this.getClosestInlineEditor(s), c = this.getClosestInlineEditor(i);
    if (!a || !c)
      return null;
    const l = a.toInlineRange(t), h = c.toInlineRange(t);
    return !l || !h ? null : this.host.selection.create("text", {
      from: {
        path: r.path,
        index: l.index,
        length: l.length
      },
      to: r === o ? null : {
        path: o.path,
        index: h.index,
        length: h.length
      },
      reverse: e
    });
  }
  getClosestBlock(t) {
    const e = t instanceof Element ? t : t.parentElement;
    if (!e)
      return null;
    const s = e.closest(`[${this.host.blockIdAttr}]`);
    return !s || this._isRangeSyncExcluded(s) ? null : s;
  }
  getClosestInlineEditor(t) {
    const e = t instanceof Element ? t : t.parentElement;
    if (!e)
      return null;
    const s = e.closest(`[${bc}]`);
    return !s || this._isRangeSyncExcluded(s) ? null : s.inlineEditor;
  }
  queryInlineEditorByPath(t) {
    const e = this.host.view.viewFromPath("block", t);
    if (!e)
      return null;
    const s = e.querySelector(`[${bc}]`);
    return !s || this._isRangeSyncExcluded(s) ? null : s.inlineEditor;
  }
  _isRangeSyncExcluded(t) {
    return !!t.closest(`[${Ki.rangeSyncExcludeAttr}="true"]`);
  }
};
Ki.rangeSyncExcludeAttr = "data-range-sync-exclude", Ki.rangeQueryExcludeAttr = "data-range-query-exclude";
let Cc = Ki;
var oa = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
};
let pr = class extends xf(vc) {
  constructor() {
    super(...arguments), this.blockIdAttr = "data-block-id", this.widgetIdAttr = "data-widget-id", this.rangeManager = null, this._renderModel = (t) => {
      const { flavour: e } = t;
      if (!this.doc.schema.flavourSchemaMap.get(e))
        return console.warn(`Cannot find schema for ${e}.`), Bn`${Ft}`;
      const i = this.std.spec.getView(e);
      if (!i)
        return console.warn(`Cannot find view for ${e}.`), Bn`${Ft}`;
      const r = i.component, o = i.widgets ? Object.entries(i.widgets).reduce((a, [c, l]) => {
        const h = Bn`<${l}
            ${b1(this.widgetIdAttr)}=${c}
            .host=${this}
            .model=${t}
            .doc=${this.doc}></${l}>`;
        return {
          ...a,
          [c]: h
        };
      }, {}) : {};
      return Bn`<${r}
      ${b1(this.blockIdAttr)}=${t.id}
      .host=${this}
      .doc=${this.doc}
      .model=${t}
      .widgets=${o}
    ></${r}>`;
    }, this.renderModel = (t) => this._renderModel(t), this.renderSpecPortal = (t, e) => Bn`
      <editor-host
        .doc=${t}
        .specs=${e}
        contenteditable="false"
      ></editor-host>
    `, this.renderChildren = (t) => Bn`${DE(t.children, (e) => e.id, (e) => this._renderModel(e))}`;
  }
  get command() {
    return this.std.command;
  }
  get event() {
    return this.std.event;
  }
  get selection() {
    return this.std.selection;
  }
  get view() {
    return this.std.view;
  }
  get spec() {
    return this.std.spec;
  }
  willUpdate(t) {
    t.has("specs") && this.std.spec.applySpecs(this.specs), super.willUpdate(t);
  }
  async getUpdateComplete() {
    try {
      const t = await super.getUpdateComplete(), e = this.doc.root;
      B(e);
      const s = this.std.spec.getView(e.flavour);
      B(s);
      const i = Object.values(s.widgets ?? {}), r = [s.component, ...i];
      return await Promise.all(r.map((o) => {
        const a = this.renderRoot.querySelector(o._$litStatic$);
        if (a instanceof Ss)
          return a.updateComplete;
      })), t;
    } catch (t) {
      return t instanceof Error ? Yy(t) : console.error(t), !0;
    }
  }
  connectedCallback() {
    if (super.connectedCallback(), !this.doc.root)
      throw new Error("This doc is missing root block. Please initialize the default block structure before connecting the editor to DOM.");
    this.std = new j_({
      host: this,
      collection: this.doc.collection,
      doc: this.doc
    }), this.std.mount(), this.std.spec.applySpecs(this.specs), this.rangeManager = new Cc(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.std.unmount(), this.rangeManager = null;
  }
  render() {
    const { root: t } = this.doc;
    return t ? this._renderModel(t) : Ft;
  }
};
oa([
  oe({ attribute: !1 })
], pr.prototype, "specs", void 0);
oa([
  oe({ attribute: !1 })
], pr.prototype, "doc", void 0);
oa([
  oe({ attribute: !1 })
], pr.prototype, "blockIdAttr", void 0);
oa([
  oe({ attribute: !1 })
], pr.prototype, "widgetIdAttr", void 0);
pr = oa([
  Zl("editor-host")
], pr);
var If = function(n, t, e, s) {
  var i = arguments.length, r = i < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, e) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(n, t, e, s);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(t, e, r) : o(t, e)) || r);
  return i > 3 && r && Object.defineProperty(t, e, r), r;
};
class Of extends xf(Ss) {
  constructor() {
    super(...arguments), this.handleEvent = (t, e, s) => {
      this._disposables.add(this.host.event.add(t, e, {
        flavour: s != null && s.global ? void 0 : this.flavour
      }));
    };
  }
  get flavour() {
    return B(this.blockElement), this.blockElement.model.flavour;
  }
  get std() {
    return this.host.std;
  }
  bindHotKey(t, e) {
    this._disposables.add(this.host.event.bindHotkey(t, {
      flavour: e != null && e.global ? void 0 : this.flavour
    }));
  }
  connectedCallback() {
    super.connectedCallback();
    const t = this.dataset.widgetId;
    this.std.view.setWidget(this);
    const e = this.parentElement;
    B(e), this.blockElement = e.closest("[data-block-id]"), this.service = this.blockElement.service, this.path = this.host.view.calculatePath(this).concat(t), this.service.specSlots.widgetConnected.emit({
      service: this.blockElement.service,
      component: this
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.std.view.deleteWidget(this), this.service.specSlots.widgetDisconnected.emit({
      service: this.blockElement.service,
      component: this
    });
  }
  render() {
    return null;
  }
}
If([
  oe({ attribute: !1 })
], Of.prototype, "host", void 0);
If([
  oe({ attribute: !1 })
], Of.prototype, "doc", void 0);
If([
  oe({ attribute: !1 })
], Of.prototype, "model", void 0);
class $E {
  constructor(t) {
    this.std = t, this._blockMap = /* @__PURE__ */ new Map(), this._widgetMap = /* @__PURE__ */ new Map(), this.setBlock = (e) => {
      this._blockMap.set(e.model.id, e);
    }, this.setWidget = (e) => {
      const s = e.dataset.widgetId, i = `${e.model.id}|${s}`;
      this._widgetMap.set(i, e);
    }, this.getBlock = (e) => this._blockMap.get(e) ?? null, this.getWidget = (e, s) => {
      const i = `${s}|${e}`;
      return this._widgetMap.get(i) ?? null;
    }, this.deleteBlock = (e) => {
      this._blockMap.delete(e.id);
    }, this.deleteWidget = (e) => {
      const s = e.dataset.widgetId, i = `${e.model.id}|${s}`;
      this._widgetMap.delete(i);
    }, this.calculatePath = (e) => {
      const s = [];
      let i = e.model;
      for (; i; )
        s.push(i.id), i = this.std.doc.getParent(i);
      return s.reverse();
    }, this.fromPath = (e) => {
      var i;
      const s = e[e.length - 1] ?? ((i = this.std.doc.root) == null ? void 0 : i.id);
      return s ? this._blockMap.get(s) ?? null : null;
    }, this.walkThrough = (e, s = []) => {
      const i = this.fromPath(s);
      B(i, `Invalid path to get node in view: ${s}`);
      const r = (o) => (a, c) => {
        if (e(a, c, o) === !0)
          return;
        const h = a.model.children;
        h.forEach((d) => {
          const u = this._blockMap.get(d.id);
          u && r(a)(u, h.indexOf(d));
        });
      };
      i.model.children.forEach((o) => {
        const a = this._blockMap.get(o.id);
        a && r(a)(a, i.model.children.indexOf(o));
      });
    }, this.getParent = (e) => e.length === 0 ? null : this.fromPath(os.parent(e));
  }
  viewFromPath(t, e) {
    if (t === "block")
      return this.fromPath(e);
    const i = e.slice(-2).join("|");
    return this._widgetMap.get(i) ?? null;
  }
  mount() {
  }
  unmount() {
    this._blockMap.clear(), this._widgetMap.clear();
  }
}
class j_ {
  constructor(t) {
    this.host = t.host, this.collection = t.collection, this.doc = t.doc, this.event = new tE(this), this.selection = new rE(this), this.command = new Bx(this), this.spec = new cE(this), this.view = new $E(this), this.clipboard = new Fx(this);
  }
  mount() {
    this.selection.mount(), this.event.mount(), this.view.mount(), this.spec.mount();
  }
  unmount() {
    this.event.unmount(), this.selection.unmount(), this.view.unmount(), this.spec.unmount();
  }
}
class NE extends j_ {
  constructor(t) {
    super(t), this.editor = t.editor;
  }
}
var G_ = { exports: {} };
(function(n) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function s() {
  }
  Object.create && (s.prototype = /* @__PURE__ */ Object.create(null), new s().__proto__ || (e = !1));
  function i(c, l, h) {
    this.fn = c, this.context = l, this.once = h || !1;
  }
  function r(c, l, h, d, u) {
    if (typeof h != "function")
      throw new TypeError("The listener must be a function");
    var f = new i(h, d || c, u), p = e ? e + l : l;
    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], f] : c._events[p].push(f) : (c._events[p] = f, c._eventsCount++), c;
  }
  function o(c, l) {
    --c._eventsCount === 0 ? c._events = new s() : delete c._events[l];
  }
  function a() {
    this._events = new s(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], h, d;
    if (this._eventsCount === 0)
      return l;
    for (d in h = this._events)
      t.call(h, d) && l.push(e ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
  }, a.prototype.listeners = function(l) {
    var h = e ? e + l : l, d = this._events[h];
    if (!d)
      return [];
    if (d.fn)
      return [d.fn];
    for (var u = 0, f = d.length, p = new Array(f); u < f; u++)
      p[u] = d[u].fn;
    return p;
  }, a.prototype.listenerCount = function(l) {
    var h = e ? e + l : l, d = this._events[h];
    return d ? d.fn ? 1 : d.length : 0;
  }, a.prototype.emit = function(l, h, d, u, f, p) {
    var m = e ? e + l : l;
    if (!this._events[m])
      return !1;
    var _ = this._events[m], v = arguments.length, b, g;
    if (_.fn) {
      switch (_.once && this.removeListener(l, _.fn, void 0, !0), v) {
        case 1:
          return _.fn.call(_.context), !0;
        case 2:
          return _.fn.call(_.context, h), !0;
        case 3:
          return _.fn.call(_.context, h, d), !0;
        case 4:
          return _.fn.call(_.context, h, d, u), !0;
        case 5:
          return _.fn.call(_.context, h, d, u, f), !0;
        case 6:
          return _.fn.call(_.context, h, d, u, f, p), !0;
      }
      for (g = 1, b = new Array(v - 1); g < v; g++)
        b[g - 1] = arguments[g];
      _.fn.apply(_.context, b);
    } else {
      var y = _.length, S;
      for (g = 0; g < y; g++)
        switch (_[g].once && this.removeListener(l, _[g].fn, void 0, !0), v) {
          case 1:
            _[g].fn.call(_[g].context);
            break;
          case 2:
            _[g].fn.call(_[g].context, h);
            break;
          case 3:
            _[g].fn.call(_[g].context, h, d);
            break;
          case 4:
            _[g].fn.call(_[g].context, h, d, u);
            break;
          default:
            if (!b)
              for (S = 1, b = new Array(v - 1); S < v; S++)
                b[S - 1] = arguments[S];
            _[g].fn.apply(_[g].context, b);
        }
    }
    return !0;
  }, a.prototype.on = function(l, h, d) {
    return r(this, l, h, d, !1);
  }, a.prototype.once = function(l, h, d) {
    return r(this, l, h, d, !0);
  }, a.prototype.removeListener = function(l, h, d, u) {
    var f = e ? e + l : l;
    if (!this._events[f])
      return this;
    if (!h)
      return o(this, f), this;
    var p = this._events[f];
    if (p.fn)
      p.fn === h && (!u || p.once) && (!d || p.context === d) && o(this, f);
    else {
      for (var m = 0, _ = [], v = p.length; m < v; m++)
        (p[m].fn !== h || u && !p[m].once || d && p[m].context !== d) && _.push(p[m]);
      _.length ? this._events[f] = _.length === 1 ? _[0] : _ : o(this, f);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var h;
    return l ? (h = e ? e + l : l, this._events[h] && o(this, h)) : (this._events = new s(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, n.exports = a;
})(G_);
var LE = G_.exports;
const H_ = /* @__PURE__ */ ou(LE);
class UE extends Me.Layer {
  constructor(t) {
    super(t), this.viewPadding = 13 * 4, this.zoomRatio = 1, this.std = t.std, this.stage = t.stage, this.centerAnchor(), this.updateMeta(), this.stage.add(this), this.setStd(t.std, !0);
  }
  get doc() {
    return this.std.doc;
  }
  setStd(t, e = !1) {
    !e && t === this.std || (this.reset(), this.std = t, this.updateMeta());
  }
  updateMeta() {
    var e;
    const t = (e = this.doc) == null ? void 0 : e.root;
    this.setAttrs({
      id: `${t == null ? void 0 : t.flavour}:${t == null ? void 0 : t.id}`,
      name: "viewport"
    });
  }
  centerAnchor(t = this.zoomRatio) {
    const e = this.stage;
    this.setAttrs({
      offsetX: -e.width() / t / 2,
      offsetY: -e.height() / t / 2
    });
  }
  zoomTo(t = 1) {
    this.scale({ x: t, y: t }), this.centerAnchor(t), this.zoomRatio = t, this.fire("zoom", { ratio: t });
  }
  getScrollLimit() {
    const t = this.size(), e = this.getClientRect(), s = this.viewPadding, i = {
      width: e.width + s * 2,
      height: e.height + s * 2
    }, r = e.width > t.width ? (e.width - t.width) / 2 + s : 0, o = i.height > t.height ? (e.height - t.height) / 2 + s : 0;
    return {
      minX: -r,
      maxX: r,
      minY: -o,
      maxY: o
    };
  }
  scrollTo(t, e) {
    const s = this.position(), i = this.getScrollLimit();
    return t = Math.max(i.minX, Math.min(t, i.maxX)), e = Math.max(i.minY, Math.min(e, i.maxY)), s.x === t && s.y === e ? !1 : (this.position({ x: t, y: e }), this.fire("scroll", { x: t, y: e }), !0);
  }
  onResize() {
    this.centerAnchor(), this.fire("resize");
  }
  handleEvents() {
  }
  reset() {
    this.destroyChildren();
  }
}
class FE extends Me.Transformer {
  get doc() {
    return this.std.doc;
  }
  constructor(t) {
    super(t), this.std = t.std, this.setStd(t.std, !0);
  }
  setStd(t, e = !1) {
    !e && t === this.std || (this.reset(), this.std = t, this.updateMeta());
  }
  select(t) {
    const e = this.std.selection, s = t.map((i) => e.create("block", {
      path: [i.getAttr("modelId")]
    }));
    e.set(s);
  }
  clear() {
    this.std.selection.set([]);
  }
  updateMeta() {
    var i;
    const t = (i = this.doc) == null ? void 0 : i.root, s = getComputedStyle(this.std.host).getPropertyValue("--p") || "0.540977 0.192841 258.88531";
    this.setAttrs({
      name: "selection",
      id: `selection:${t == null ? void 0 : t.flavour}:${t == null ? void 0 : t.id}`,
      rotateLineVisible: !1,
      rotationSnaps: [0, 45, 90, 135, 180, 225, 270, 315],
      rotateAnchorCursor: "corsshair",
      rotateAnchorOffset: 30,
      anchorStroke: `oklch(${s} / 0.8)`,
      anchorSize: 10,
      keepRatio: !0,
      flipEnabled: !1,
      shouldOverdrawWholeArea: !0
    }), this.anchorStyleFunc((r) => {
      r.stroke("rgba(0, 0, 0, 0.2)"), r.cornerRadius(10), r.hasName("top-center") || r.hasName("bottom-center") ? (r.height(6), r.offsetY(3), r.width(20), r.offsetX(10)) : (r.hasName("middle-left") || r.hasName("middle-right")) && (r.height(20), r.offsetY(10), r.width(6), r.offsetX(3));
    });
  }
  reset() {
  }
}
const BE = Me.Util.haveIntersection;
class VE extends Me.Rect {
  constructor(t) {
    super(t), this.className = "Selector", this.dragging = !1, this.selecting = !1, this.selectPoints = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    }, this.selection = t.selection, this.container = t.container, this.stage = t.stage, this.handleEvents(), this.updateMeta();
  }
  onPointerDown(t) {
    const e = this.stage;
    if (t.target !== e)
      return;
    t.evt.preventDefault();
    const s = this.selectPoints, i = e.getPointerPosition();
    i && (s.x1 = i.x, s.y1 = i.y, s.x2 = i.x, s.y2 = i.y, this.width(0), this.height(0), this.selecting = !0);
  }
  onPointerMove(t) {
    if (!this.selecting)
      return;
    t.evt.preventDefault();
    const e = this.stage, s = this.selectPoints, i = e.getPointerPosition();
    if (!i)
      return;
    s.x2 = i.x, s.y2 = i.y;
    const { x1: r, y1: o, x2: a, y2: c } = s;
    this.setAttrs({
      visible: !0,
      x: Math.min(r, a),
      y: Math.min(o, c),
      width: Math.abs(a - r),
      height: Math.abs(c - o)
    });
  }
  onPointerUp(t) {
    if (this.selecting = !1, !this.visible())
      return;
    t.evt.preventDefault(), this.visible(!1);
    const e = this.container.find(".xpix:node"), s = this.getClientRect(), i = e.filter((r) => r.hasName("xpix:frame") ? !1 : BE(s, r.getClientRect()));
    this.selection.select(i);
  }
  onPointerClick(t) {
    if (this.visible() || this.dragging)
      return;
    const { stage: e, selection: s } = this, i = e.getPointerPosition() || { x: 0, y: 0 }, r = this.container.getIntersection(i), c = (r ? r.getAncestors() : []).filter((u) => u.hasName("xpix:node"))[0] || null;
    if (!c) {
      s.clear();
      return;
    }
    const l = t.evt.shiftKey || t.evt.ctrlKey || t.evt.metaKey, h = s.nodes(), d = h.indexOf(c) >= 0;
    if (!l && !d)
      s.select([c]);
    else if (l && d) {
      const u = h.slice();
      u.splice(u.indexOf(c), 1), s.select(u);
    } else if (l && !d) {
      const u = h.concat([c]);
      s.select(u);
    }
  }
  onDragStart() {
    this.dragging = !0;
  }
  onDragEnd(t) {
    this.dragging = !1;
    const e = t.target;
    if (!e.hasName("xpix:node") || e.hasName("selection"))
      return;
    const s = this.selection;
    s.nodes().indexOf(e) < 0 && s.select([t.target]);
  }
  handleEvents() {
    const t = this.stage;
    t.on("pointerdown", this.onPointerDown.bind(this)), t.on("pointermove", this.onPointerMove.bind(this)), t.on("pointerup", this.onPointerUp.bind(this)), t.on("pointerclick", this.onPointerClick.bind(this)), t.on("dragstart", this.onDragStart.bind(this)), t.on("dragend", this.onDragEnd.bind(this));
  }
  updateMeta() {
    this.setAttrs({
      id: "selector:root",
      name: "selector",
      fill: "rgba(0, 161, 255, .5)",
      visible: !1
    });
  }
  reset() {
  }
}
function jE(n) {
  return (t, e) => ({
    configurable: !0,
    enumerable: !1,
    value: Pc(t[e], n)
  });
}
var GE = Object.defineProperty, HE = Object.getOwnPropertyDescriptor, zE = (n, t, e, s) => {
  for (var i = s > 1 ? void 0 : s ? HE(t, e) : t, r = n.length - 1, o; r >= 0; r--)
    (o = n[r]) && (i = (s ? o(t, e, i) : o(i)) || i);
  return s && i && GE(t, e, i), i;
};
class z_ extends Me.Group {
  constructor(t) {
    super(t), this.className = "Scroller", this.viewport = t.viewport, this.stage = t.stage, this.setAttrs({
      name: "scroller"
    });
    const e = {
      viewport: this.viewport,
      visible: !1,
      // opacity: 0.8,
      fill: "rgba(22, 22, 22, .4)",
      stroke: "rgba(255, 255, 255, .24)",
      strokeWidth: 1,
      cornerRadius: 5,
      margin: 6,
      size: 6
    };
    this.hBar = new k1({
      ...e,
      dir: "horizontal"
    }), this.vBar = new k1({
      ...e,
      dir: "vertical"
    }), this.handleEvents(), this.add(this.hBar, this.vBar), this.update();
  }
  getLimit() {
    return this.viewport.getScrollLimit();
  }
  scrollTo(t, e) {
    return this.viewport.scrollTo(t, e);
  }
  update() {
    this.scrollTo(this.viewport.x(), this.viewport.y()), this.hBar.update(), this.vBar.update();
  }
  handleEvents() {
    const { stage: t, viewport: e } = this;
    e.on("scroll resize zoom", () => {
      this.update();
    }), t.on("wheel", (s) => {
      const { deltaX: i, deltaY: r } = s.evt, o = e.position();
      this.scrollTo(o.x - i, o.y - r) && s.evt.preventDefault();
    });
  }
}
zE([
  jE(0)
], z_.prototype, "update", 1);
class k1 extends Me.Rect {
  constructor(t) {
    super(t), this.viewport = t.viewport;
    const e = (s) => {
      const i = this.getStage();
      if (!i)
        return s;
      const { size: r, margin: o } = t;
      return t.dir === "horizontal" ? (s.x = Math.max(
        Math.min(s.x, i.width() - this.width() - o),
        o
      ), s.y = i.height() - o - r) : (s.x = i.width() - o - r, s.y = Math.max(
        Math.min(s.y, i.height() - this.height() - o),
        o
      )), s;
    };
    this.setAttrs({
      name: "scrollbar:" + t.dir,
      width: t.size,
      height: t.size,
      draggable: !0,
      dragBoundFunc: e
    });
  }
  update() {
    const t = this.viewport, e = t.getClientRect(), s = t.getScrollLimit(), i = t.viewPadding, r = {
      width: t.width(),
      height: t.height()
    }, o = {
      width: e.width + i * 2,
      height: e.height + i * 2
    }, { dir: a, margin: c } = this.getAttrs(), l = this.position(), h = this.size();
    if (a === "horizontal") {
      const d = this.height(), u = Math.min(r.width / o.width, 1), f = r.width - (c + d) * 2, p = s.maxX - s.minX;
      if (!p || u >= 1) {
        this.hide();
        return;
      }
      h.width = u * f;
      const _ = (-t.x() - s.minX) / p;
      l.x = _ * (f - h.width) + c + d, l.y = r.height - h.height - c;
    } else {
      const d = this.width(), u = Math.min(r.height / o.height, 1), f = r.height - (c + d) * 2, p = s.maxY - s.minY;
      if (!p || u >= 1) {
        this.hide();
        return;
      }
      h.height = u * f;
      const _ = (-t.y() - s.minY) / p;
      l.y = _ * (f - h.height) + c + d, l.x = r.width - h.width - c;
    }
    this.position(l), this.size(h), this.show();
  }
}
class WE {
  get doc() {
    return this.std.doc;
  }
  get viewport() {
    return this.view.viewport;
  }
  get stage() {
    return this.view.stage;
  }
  constructor(t) {
    const e = this.container = new Me.Layer(), s = this.view = t.view, i = this.std = t.std;
    this.selection = new FE({ std: i }), this.selector = new VE({
      selection: this.selection,
      container: this.viewport,
      stage: s.stage
    }), this.scroller = new z_({
      viewport: s.viewport,
      stage: s.stage
    }), e.add(this.selector), e.add(this.selection), e.add(this.scroller), this.stage.add(e), this.setStd(t.std, !0);
  }
  updateMeta() {
    var s;
    const t = (s = this.doc) == null ? void 0 : s.root, e = `${t == null ? void 0 : t.flavour}:${t == null ? void 0 : t.id}`;
    this.container.setAttrs({
      id: `helper:${e}`,
      name: "helper"
    }), this.scroller.setAttrs({
      id: `scroller:${e}`
    });
  }
  handleEvents() {
    const { std: t, doc: e, selection: s, viewport: i } = this;
    e.slots.blockUpdated.on(() => {
      this.scroller.update();
    }), t.selection.slots.changed.on((r) => {
      const o = r.map((a) => {
        const c = e.getBlockById(a.blockId);
        return i.findOne(`#${c == null ? void 0 : c.flavour}:${c == null ? void 0 : c.id}`);
      }).filter((a) => !!a);
      s.nodes(o);
    }), i.on("dragend", (r) => {
      const o = r.target, a = e.getBlockById(o.getAttr("modelId"));
      !a || !o.hasName("xpix:node") || e.updateBlock(a, {
        x: o.x(),
        y: o.y()
      });
    }), s.on("transformend", (r) => {
      const o = r.target, a = e.getBlockById(o.getAttr("modelId"));
      !a || !o.hasName("xpix:node") || e.updateBlock(a, {
        x: o.x(),
        y: o.y(),
        width: o.width(),
        height: o.height(),
        rotation: o.rotation(),
        scaleX: o.scaleX(),
        scaleY: o.scaleY()
      });
    });
  }
  setStd(t, e = !1) {
    !e && t === this.std || (this.selection.setStd(t), this.reset(), this.std = t, this.handleEvents(), this.updateMeta());
  }
  reset() {
  }
}
class KE extends H_ {
  constructor(t) {
    super(), this.viewState = {
      currentFrameId: "",
      zoomRatio: 1
    };
    const { root: e, std: s, viewState: i } = t;
    this.viewState = i, this.root = e, this.std = s;
    const r = this.stage = new Me.Stage({
      // draggable: true
      container: e,
      height: Math.max(10, e.offsetHeight),
      width: Math.max(10, e.offsetWidth)
    });
    e.oncontextmenu = () => !1, this.viewport = new UE({
      stage: r,
      std: s
    }), this.helper = new WE({
      view: this,
      std: s
    }), this.handleRootResize(), this.setStd(s, !0);
  }
  get doc() {
    return this.std.doc;
  }
  setStd(t, e = !1) {
    !e && t === this.std || (this.std = t, this.handleEvents(), this.helper.setStd(t), this.viewport.setStd(t), this.renderRoot());
  }
  getMode() {
    var e;
    const t = (e = this.doc) == null ? void 0 : e.root;
    return (t == null ? void 0 : t.mode) || "board";
  }
  getRootFrames() {
    var s;
    const t = this.doc;
    return (((s = t == null ? void 0 : t.root) == null ? void 0 : s.children) || []).filter((i) => i.flavour === "xpix:frame");
  }
  getCurrentFrame() {
    const t = this.getRootFrames(), e = this.viewState.currentFrameId;
    return t.find((i) => i.id === e) || t[0];
  }
  switchFrame(t) {
    t.id !== this.viewState.currentFrameId && (this.viewState.currentFrameId = t.id, this.emit("frame:switch", t));
  }
  renderRoot() {
    var e;
    const t = (e = this.doc) == null ? void 0 : e.root;
    t && this.render({
      id: t.id || "",
      flavour: t.flavour || "",
      type: "add"
    });
  }
  render(t) {
    var d, u, f;
    const { std: e, doc: s, stage: i } = this, { id: r, flavour: o, type: a } = t, c = (d = e.spec.getView(o)) == null ? void 0 : d.component, l = (t == null ? void 0 : t.model) ?? ((u = s.getBlock(r)) == null ? void 0 : u.model);
    if (!l)
      throw new Error("model not found");
    const h = {
      action: a,
      stage: i,
      std: e
    };
    if (a === "update") {
      const p = (f = t.props) == null ? void 0 : f.key;
      h.props = p ? { [p]: l[p] } : {}, c.update(l, h);
    } else
      a === "add" ? l.role !== "root" ? c.add(l, h) : c.renderChildren(l, h) : a === "delete" && c.remove(l, h);
  }
  handleRootResize() {
    const { stage: t, root: e } = this, s = Ky(() => {
      const i = Math.max(10, e.offsetHeight), r = Math.max(10, e.offsetWidth);
      t.height(i), t.width(r), this.viewport.onResize(), this.emit("resize", { width: r, height: i });
    }, 64);
    window.addEventListener("resize", s);
  }
  handleEvents() {
    this.doc.slots.blockUpdated.on((e) => {
      this.render(e);
    });
  }
  getZoomRatios() {
    return [0.02, 0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8];
  }
  zoomIn() {
    const e = this.getZoomRatios().find((s) => s > this.viewState.zoomRatio);
    e && this.zoomTo(e);
  }
  zoomOut() {
    const e = this.getZoomRatios().reverse().find((s) => s < this.viewState.zoomRatio);
    e && this.zoomTo(e);
  }
  zoomTo(t) {
    const { viewport: e } = this, s = this.getZoomRatios();
    t = Math.max(s[0], Math.min(s[s.length - 1], t)), e.zoomTo(t), this.viewState.zoomRatio = t, this.emit("zoom:change", this.viewState);
  }
  zoomBy(t) {
    if (!t)
      return;
    const e = t.size(), s = this.stage.size(), i = Math.min(
      s.width / e.width,
      s.height / e.height
    );
    this.zoomTo(i);
  }
  destroy() {
    this.stage.destroy();
  }
}
const YE = {
  multiple: !1,
  excludeAcceptAllOption: !0,
  accept: {
    "image/*": [".png", ".gif", ".jpeg", ".jpg"]
  }
};
async function ZE(n = YE) {
  if (n && (n.excludeAcceptAllOption === void 0 && (n.excludeAcceptAllOption = !0), n.accept && !n.types && (n.types = [{
    accept: n.accept
  }])), window.showOpenFilePicker) {
    const t = await window.showOpenFilePicker(n);
    return Promise.all(t.map((e) => e.getFile()));
  }
  throw new Error("File picker not supported");
}
class qE extends H_ {
  constructor(t) {
    var i, r;
    super(), this.viewState = {
      currentFrameId: "",
      zoomRatio: 1
    }, this.root = t.root, this.config = {
      useLocalDraft: !0,
      ...t
    };
    const e = this._doc = Rx();
    if (!e)
      throw new Error("Editor init error: Doc not found");
    this.std = this.getStd(), this.viewState.currentFrameId = ((r = (i = e.root) == null ? void 0 : i.children[0]) == null ? void 0 : r.id) || "", this.view = new KE({
      viewState: this.viewState,
      root: this.root,
      std: this.std
    }), ["frame:switch", "zoom:change"].forEach((o) => {
      var a;
      (a = this.view) == null || a.on(o, (...c) => this.emit(o, ...c));
    });
  }
  get doc() {
    return this._doc;
  }
  get viewMode() {
    var t;
    return ((t = this.view) == null ? void 0 : t.getMode()) || "board";
  }
  // History
  get canUndo() {
    var t;
    return !!((t = this.doc) != null && t.canUndo);
  }
  get canRedo() {
    var t;
    return !!((t = this.doc) != null && t.canRedo);
  }
  undo() {
    var t;
    return (t = this.doc) == null ? void 0 : t.undo();
  }
  redo() {
    var t;
    return (t = this.doc) == null ? void 0 : t.redo();
  }
  // Std
  get command() {
    var t;
    return (t = this.std) == null ? void 0 : t.command;
  }
  get event() {
    var t;
    return (t = this.std) == null ? void 0 : t.event;
  }
  get selection() {
    var t;
    return (t = this.std) == null ? void 0 : t.selection;
  }
  async init() {
    const t = await this.loadDoc();
    t && this.setDoc(t);
  }
  getStd() {
    let t = this.std;
    if (!t || t.doc !== this.doc) {
      t && t.unmount();
      const e = this.doc;
      t = new NE({
        editor: this,
        host: this.root,
        collection: e.collection,
        doc: e
      }), t.spec.applySpecs(v_), t.mount();
    }
    return t;
  }
  createDoc() {
    return vf();
  }
  async loadDoc(t) {
    const { useLocalDraft: e } = this.config;
    return !t && e && typeof localStorage < "u" && (t = localStorage.getItem("xpix:last-doc-id") || ""), $x(t);
  }
  setDoc(t) {
    const e = this._doc;
    this._doc = t, this.std = this.getStd(), this.view.setStd(this.std);
    const s = this.getRootFrames();
    if (s.length > 0 && this.switchFrame(s[0]), e) {
      const { slots: o, collection: a } = e;
      a.removeDoc(e.id), o.blockUpdated.dispose(), o.ready.dispose();
    }
    const { useLocalDraft: i } = this.config;
    i && typeof localStorage < "u" && localStorage.setItem("xpix:last-doc-id", t.id), this.emit("doc:change", t);
  }
  getRootFrames() {
    return this.view.getRootFrames();
  }
  getCurrentFrame() {
    return this.view.getCurrentFrame();
  }
  addFrame(t) {
    t = {
      width: 600,
      height: 400,
      ...t
    };
    const e = this.getCurrentFrame();
    e && (t.width = t.width || e.width, t.height = t.height || e.height);
    const s = e.doc.root, i = this.addBlock("frame", t, s);
    return this.switchFrame(i);
  }
  switchFrame(t) {
    var e, s;
    return (e = this.view) == null || e.switchFrame(t), (s = this.selection) == null || s.clear(), t;
  }
  getSelections() {
    var e;
    const t = (e = this.std) == null ? void 0 : e.selection;
    return t ? t.value : [];
  }
  getActiveBlock(t = this.getSelections()) {
    const e = this.doc, s = t.length;
    return !e || s < 1 ? null : s === 1 ? this.getBlockById(t[0].blockId) : Ux(e, {
      name: "xpix:mixed",
      flavour: "xpix:mixed",
      count: s
    });
  }
  getBlockById(t) {
    var s;
    const e = (s = this.doc) == null ? void 0 : s.getBlockById(t);
    return e || null;
  }
  getBlockType(t = this.getActiveBlock(), e = !0) {
    if (!t)
      return "";
    let s = t.flavour.replace("xpix:", "");
    return e && (s = s.charAt(0).toUpperCase() + s.slice(1)), s;
  }
  getAddableRoot() {
    var e;
    let t = this.getCurrentFrame();
    return t || (t = (e = this.doc) == null ? void 0 : e.root), t;
  }
  // async addImage(imgSource: CanvasImageSource, props?: XPixModelProps): Promise<string> {
  // async addImage(file: Blob, props?: XPixModelProps): Promise<string>;
  async addImage(t, e, s = this.getAddableRoot()) {
    const { blob: i, width: r, height: o } = await this.loadImage(t);
    e || (e = {}), e.height = e.height || o, e.width = e.width || r;
    const a = {
      width: s.width || 400,
      height: s.height || 400
    }, c = e.width / e.height;
    e.width > e.height ? (e.width = Math.min(e.width, a.width), e.height = e.width / c) : (e.height = Math.min(e.height, a.height), e.width = e.height * c), e.x = e.x ?? (a.width - e.width) / 2, e.y = e.y ?? (a.height - e.height) / 2;
    const l = await this.addAsset(i);
    return this.addBlock(
      "image",
      {
        ...e,
        assetId: l
      },
      s
    );
  }
  getActiveNode(t = this.getSelections()) {
    const e = this.getActiveBlock(t);
    return e ? this.getNode(e) : null;
  }
  getNode(t) {
    var s;
    let e = t;
    return typeof t == "string" && (e = this.getBlockById(t)), e || (e = this.getActiveBlock()), e ? (s = this.view) == null ? void 0 : s.stage.findOne(`#${e.getFullId()}`) : null;
  }
  addBlock(t, e = {}, s = this.getAddableRoot()) {
    if (!s)
      throw new Error("addBlock: parent not found");
    const i = s.doc, r = t.indexOf("xpix:") !== 0 ? `xpix:${t}` : t;
    if (!i.getSchemaByFlavour(r))
      throw new Error("addBlock: schema not found for type: " + t);
    const a = i.addBlock(
      r,
      e,
      s.id
    ), c = i.getBlockById(a);
    if (!this.getNode(c))
      throw i.deleteBlock(c), new Error("Node not found for model: " + a);
    return c;
  }
  updateBlock(t, e) {
    t.doc.updateBlock(t, e);
  }
  removeBlock(t) {
    t.doc.deleteBlock(t);
  }
  addAsset(t, e) {
    var s;
    return (s = this.doc) == null ? void 0 : s.blob.set(t, e);
  }
  select(t) {
    if (!this.std)
      return;
    Array.isArray(t) || (t = [t]);
    const e = this.std.selection, s = t.map((i) => e.create("block", {
      path: [i.id]
    }));
    e.set(s);
  }
  fitZoom() {
    var s;
    const t = this.getCurrentFrame(), e = t ? this.getNode(t) : null;
    e && ((s = this.view) == null || s.zoomBy(e));
  }
  zoomIn() {
    var t;
    (t = this.view) == null || t.zoomIn();
  }
  zoomOut() {
    var t;
    (t = this.view) == null || t.zoomOut();
  }
  zoomTo(t) {
    var e;
    (e = this.view) == null || e.zoomTo(t);
  }
  // Tools
  showOpenFilePicker(t) {
    return ZE(t);
  }
  async loadImage(t) {
    const e = await Ax(t), s = await __(e);
    return {
      height: s.naturalHeight,
      width: s.naturalWidth,
      image: s,
      blob: e
    };
  }
  async exportImage(t, e) {
    if (e || (e = this.getCurrentFrame()), !e)
      throw new Error("No block found");
    if (e.count > 1)
      throw new Error("Mixed block not supported");
    const s = this.getNode(e);
    if (!s)
      throw new Error("No node found");
    const i = (t == null ? void 0 : t.mimeType) || "image/png", r = i.split("/")[1] || "png", o = `${e.name || "xpix-export-image"}.${r}`, a = await s.toBlob(t);
    return new File([a], o, {
      type: i
    });
  }
  async saveToFile(t) {
    const e = t;
    t instanceof Blob && (t = URL.createObjectURL(t));
    const s = document.createElement("a");
    s.download = e.name || "", s.href = t, s.click();
  }
  // Snapshot
  async fromJSON(t) {
    const e = await Nx(t);
    this.setDoc(e), e.resetHistory();
  }
  async toJSON() {
    return Lx(this.doc);
  }
  // destroy
  destroy() {
    var t;
    (t = this.view) == null || t.destroy();
  }
  async runDemo() {
    await this.addBlock("shape", {
      type: "rect",
      cornerRadius: 5,
      fill: "#EEE",
      stroke: "#DDD",
      strokeWidth: 2,
      width: 560,
      height: 360,
      x: 20,
      y: 20
    }), await this.addBlock("shape", {
      type: "circle",
      radius: 70,
      fill: "red",
      stroke: "black",
      strokeWidth: 4,
      x: 80,
      y: 80
    });
    const t = 200, e = t * (window.devicePixelRatio || 1);
    await this.addImage(
      `https://st0.dancf.com/02/cms/202212290331-12c2.png?x-oss-process=image/interlace,1/crop,g_nw,w_${e},h_${e}`,
      {
        height: t,
        width: t,
        x: 190,
        y: 80
      }
    );
  }
}
function aD(n) {
  return new qE(n);
}
const Df = "XPIX_EDITOR_INSTANCE", iu = /* @__PURE__ */ new WeakMap();
function XE() {
  return {
    editorState: Bi(null)
  };
}
async function JE(n) {
  const t = iu.get(n);
  if (t)
    return t;
  const e = jo(Df);
  if (!e)
    throw new Error("installEditor must be call in EditorProvider context");
  const { createEditor: s, DisposableGroup: i } = await import("./index-Dxc2uOCs.mjs"), r = s({ root: n }), o = e.editorState.value = {
    editor: r,
    docs: Bi([]),
    doc: Bi(void 0),
    selections: Bi([]),
    viewState: Bi({
      currentFrameId: "",
      zoomRatio: 1
    })
  };
  console.log("XPix-Editor:", r);
  const a = Pc(() => {
    var u;
    const d = r == null ? void 0 : r.doc;
    !r || !d || (o.doc.value = d, Ql(o.doc), o.selections.value = ((u = r.selection) == null ? void 0 : u.value) || [], Ql(o.selections), o.viewState.value = r.viewState, Ql(o.viewState));
  }, 0);
  Object.assign(window, {
    xxUpdateState: a,
    xxDocRef: o.doc,
    xxState: o,
    xxDoc: r.doc,
    xx: r
  }), iu.set(n, e), await r.init();
  let c = new i();
  const l = r.view, h = () => {
    c && c.dispose();
    const d = r.doc.slots, u = r.selection;
    c = new i(), c.add(d.rootAdded.on(a)), c.add(d.rootDeleted.on(a)), c.add(d.blockUpdated.on(a)), c.add(d.historyUpdated.on(a)), c.add(u.slots.changed.on(a)), a();
  };
  return r.on("doc:change", h), l.on("frame:switch", a), l.on("zoom:change", a), h(), e;
}
function QE() {
  const n = jo(Df);
  if (!n)
    throw new Error("installEditor must be call in EditorProvider context");
  const t = n.editorState.value, e = t == null ? void 0 : t.editor;
  if (e) {
    const s = e.root;
    n.editorState.value = null, iu.delete(s), e.destroy();
  } else
    console.log("unmount.error:", e, t);
}
function sn() {
  const t = jo(Df).editorState;
  if (!t.value)
    throw new Error("useEditor must be call in EditorProvider context");
  return t.value;
}
const cD = /* @__PURE__ */ $e({
  __name: "EditorProvider",
  setup(n) {
    return Ga("XPIX_EDITOR_INSTANCE", XE()), (t, e) => Yi(t.$slots, "default");
  }
}), Xt = (n, t) => {
  const e = n.__vccOpts || n;
  for (const [s, i] of t)
    e[s] = i;
  return e;
}, tT = {
  name: "IconAdd"
}, eT = {
  class: "figma-icon figma-icon-add",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, sT = /* @__PURE__ */ O(
  "path",
  {
    d: "M11.2559 20.2544C11.2559 20.6686 11.5916 21.0044 12.0059 21.0044C12.4201 21.0044 12.7559 20.6686 12.7559 20.2544V12.7505L20.2598 12.7505C20.674 12.7505 21.0098 12.4147 21.0098 12.0005C21.0098 11.5863 20.674 11.2505 20.2598 11.2505L12.7559 11.2505V3.74609C12.7559 3.33188 12.4201 2.99609 12.0059 2.99609C11.5916 2.99609 11.2559 3.33188 11.2559 3.74609V11.2505L3.75146 11.2505C3.33725 11.2505 3.00146 11.5863 3.00146 12.0005C3.00146 12.4147 3.33725 12.7505 3.75146 12.7505L11.2559 12.7505V20.2544Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), nT = [
  sT
];
function iT(n, t, e, s, i, r) {
  return J(), gt("svg", eT, nT);
}
const rT = /* @__PURE__ */ Xt(tT, [["render", iT]]), oT = {
  name: "IconAdjust"
}, aT = {
  class: "figma-icon figma-icon-adjust",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, cT = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M9.69543 9.2793C11.2373 9.2793 12.5284 8.20562 12.8618 6.76514L21.011 6.76514C21.4252 6.76514 21.761 6.42935 21.761 6.01514C21.761 5.60092 21.4252 5.26514 21.011 5.26514L12.8551 5.26514C12.5114 3.83893 11.2272 2.7793 9.69543 2.7793C8.1632 2.7793 6.87861 3.83964 6.53543 5.26657C6.52 5.26562 6.50444 5.26514 6.48877 5.26514H2.98877C2.57456 5.26514 2.23877 5.60092 2.23877 6.01514C2.23877 6.42935 2.57456 6.76514 2.98877 6.76514H6.48877C6.50221 6.76514 6.51558 6.76478 6.52885 6.76408C6.86188 8.20509 8.15321 9.2793 9.69543 9.2793ZM9.69543 7.7793C10.6619 7.7793 11.4454 6.9958 11.4454 6.0293C11.4454 5.0628 10.6619 4.2793 9.69543 4.2793C8.72894 4.2793 7.94543 5.0628 7.94543 6.0293C7.94543 6.9958 8.72894 7.7793 9.69543 7.7793Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), lT = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M15.014 14.7198C16.5508 14.7198 17.8385 15.7865 18.1771 17.2198H21.011C21.4252 17.2198 21.761 17.5556 21.761 17.9698C21.761 18.384 21.4252 18.7198 21.011 18.7198H18.1771C17.8385 20.1532 16.5508 21.2198 15.014 21.2198C13.4772 21.2198 12.1896 20.1532 11.851 18.7198H2.99988C2.58566 18.7198 2.24988 18.384 2.24988 17.9698C2.24988 17.5556 2.58566 17.2198 2.99988 17.2198H11.851C12.1896 15.7865 13.4772 14.7198 15.014 14.7198ZM16.761 17.9698C16.761 17.9506 16.7617 17.9316 16.7631 17.9128C16.733 16.9727 15.9614 16.2198 15.014 16.2198C14.0475 16.2198 13.264 17.0033 13.264 17.9698C13.264 18.9363 14.0475 19.7198 15.014 19.7198C15.9614 19.7198 16.733 18.967 16.7631 18.0269C16.7617 18.0081 16.761 17.989 16.761 17.9698Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), hT = [
  cT,
  lT
];
function dT(n, t, e, s, i, r) {
  return J(), gt("svg", aT, hT);
}
const W_ = /* @__PURE__ */ Xt(oT, [["render", dT]]), uT = {
  name: "IconArrowLeft"
}, fT = {
  class: "figma-icon figma-icon-arrow-left",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, pT = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M15.8448 19.1592C15.5519 19.4521 15.077 19.4521 14.7841 19.1592L8.15522 12.5303C7.86232 12.2374 7.86232 11.7626 8.15522 11.4697L14.7841 4.84076C15.077 4.54787 15.5519 4.54787 15.8448 4.84076C16.1377 5.13366 16.1377 5.60853 15.8448 5.90142L9.74621 12L15.8448 18.0986C16.1377 18.3915 16.1377 18.8663 15.8448 19.1592Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), gT = [
  pT
];
function mT(n, t, e, s, i, r) {
  return J(), gt("svg", fT, gT);
}
const _T = /* @__PURE__ */ Xt(uT, [["render", mT]]), yT = {
  name: "IconBackground"
}, vT = {
  class: "figma-icon figma-icon-background",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, bT = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M3 5C3 3.89543 3.89543 3 5 3H19C20.1046 3 21 3.89543 21 5V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V5ZM10.4398 4.5H5C4.72386 4.5 4.5 4.72386 4.5 5V10.4398L10.4398 4.5ZM12.501 4.5L12.5311 4.53009L4.53009 12.5311L4.5 12.501V18.4393L18.4393 4.5H12.501ZM5.56066 19.5H11.4983L11.4689 19.4706L19.4699 11.4697L19.5 11.4998V5.56066L5.56066 19.5ZM19 19.5H13.5609L19.5 13.5609V19C19.5 19.2761 19.2761 19.5 19 19.5Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), wT = [
  bT
];
function ST(n, t, e, s, i, r) {
  return J(), gt("svg", vT, wT);
}
const CT = /* @__PURE__ */ Xt(yT, [["render", ST]]), kT = {
  name: "IconCloudSaveSuccess"
}, xT = {
  class: "figma-icon figma-icon-cloud-save-success",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, ET = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M7.47694 8.00998C8.1804 6.19728 9.94122 4.91426 11.9998 4.91426C14.0585 4.91426 15.8193 6.19728 16.5227 8.00998L16.7041 8.47724L17.2052 8.48846C19.403 8.53767 21.1699 10.3351 21.1699 12.5451C21.1699 14.4132 19.9067 15.9883 18.1866 16.4592C17.7871 16.5685 17.5518 16.9811 17.6612 17.3806C17.7706 17.7801 18.1831 18.0153 18.5826 17.906C20.9379 17.2612 22.6699 15.1064 22.6699 12.5451C22.6699 9.68376 20.5077 7.32762 17.7279 7.02116C16.705 4.8885 14.5254 3.41426 11.9998 3.41426C9.47432 3.41426 7.29474 4.88847 6.2718 7.02111C3.49173 7.32736 1.32935 9.6836 1.32935 12.5451C1.32935 15.1069 3.06204 17.2621 5.41812 17.9064C5.81766 18.0156 6.23012 17.7803 6.33937 17.3807C6.44862 16.9812 6.21329 16.5687 5.81374 16.4595C4.09303 15.989 2.82935 14.4136 2.82935 12.5451C2.82935 10.335 4.59641 8.53746 6.79447 8.48845L7.2956 8.47728L7.47694 8.00998ZM16.503 15.3886C16.793 15.0929 16.7884 14.6181 16.4927 14.328C16.197 14.038 15.7221 14.0426 15.4321 14.3383L11.0686 18.7874L9.09036 16.5463C8.81625 16.2357 8.34229 16.2062 8.03175 16.4803C7.72121 16.7544 7.69168 17.2284 7.96579 17.5389L10.4774 20.3843C10.6152 20.5404 10.8118 20.6322 11.02 20.6377C11.2282 20.6432 11.4293 20.5618 11.5751 20.4131L16.503 15.3886Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), TT = /* @__PURE__ */ O(
  "path",
  {
    d: "M7.47694 8.00998C8.1804 6.19728 9.94122 4.91426 11.9998 4.91426C14.0585 4.91426 15.8193 6.19728 16.5227 8.00998L16.7041 8.47724L17.2052 8.48846C19.403 8.53767 21.1699 10.3351 21.1699 12.5451C21.1699 14.4132 19.9067 15.9883 18.1866 16.4592C17.7871 16.5685 17.5518 16.9811 17.6612 17.3806C17.7706 17.7801 18.1831 18.0153 18.5826 17.906C20.9379 17.2612 22.6699 15.1064 22.6699 12.5451C22.6699 9.68376 20.5077 7.32762 17.7279 7.02116C16.705 4.8885 14.5254 3.41426 11.9998 3.41426C9.47432 3.41426 7.29474 4.88847 6.2718 7.02111C3.49173 7.32736 1.32935 9.6836 1.32935 12.5451C1.32935 15.1069 3.06204 17.2621 5.41812 17.9064C5.81766 18.0156 6.23012 17.7803 6.33937 17.3807C6.44862 16.9812 6.21329 16.5687 5.81374 16.4595C4.09303 15.989 2.82935 14.4136 2.82935 12.5451C2.82935 10.335 4.59641 8.53746 6.79447 8.48845L7.2956 8.47728L7.47694 8.00998Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), AT = /* @__PURE__ */ O(
  "path",
  {
    d: "M16.503 15.3886C16.793 15.0929 16.7884 14.6181 16.4927 14.328C16.197 14.038 15.7221 14.0426 15.4321 14.3383L11.0686 18.7874L9.09036 16.5463C8.81625 16.2357 8.34229 16.2062 8.03175 16.4803C7.72121 16.7544 7.69168 17.2284 7.96579 17.5389L10.4774 20.3843C10.6152 20.5404 10.8118 20.6322 11.02 20.6377C11.2282 20.6432 11.4293 20.5618 11.5751 20.4131L16.503 15.3886Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), IT = [
  ET,
  TT,
  AT
];
function OT(n, t, e, s, i, r) {
  return J(), gt("svg", xT, IT);
}
const DT = /* @__PURE__ */ Xt(kT, [["render", OT]]), PT = {
  name: "IconCompare"
}, MT = {
  class: "figma-icon figma-icon-compare",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, RT = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M12.7502 2.71771C12.7502 2.3035 12.4145 1.96771 12.0002 1.96771C11.586 1.96771 11.2502 2.3035 11.2502 2.71771V4.29413H4.24902C3.28253 4.29413 2.49902 5.07763 2.49902 6.04413V17.9559C2.49902 18.9224 3.28252 19.7059 4.24902 19.7059H11.2502V21.2297C11.2502 21.6439 11.586 21.9797 12.0002 21.9797C12.4145 21.9797 12.7502 21.6439 12.7502 21.2297L12.7502 2.71771ZM11.2502 5.79413H4.24902C4.11095 5.79413 3.99902 5.90606 3.99902 6.04413V17.9559C3.99902 18.0939 4.11095 18.2059 4.24902 18.2059H11.2502L11.2502 5.79413Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), $T = /* @__PURE__ */ O(
  "path",
  {
    d: "M19.7515 18.2059H14.2502V19.7059H19.7515C20.718 19.7059 21.5015 18.9224 21.5015 17.9559V6.04413C21.5015 5.07763 20.718 4.29413 19.7515 4.29413H14.2502V5.79413H19.7515C19.8895 5.79413 20.0015 5.90606 20.0015 6.04413V17.9559C20.0015 18.0939 19.8895 18.2059 19.7515 18.2059Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), NT = [
  RT,
  $T
];
function LT(n, t, e, s, i, r) {
  return J(), gt("svg", MT, NT);
}
const UT = /* @__PURE__ */ Xt(PT, [["render", LT]]), FT = {
  name: "IconCorrection"
}, BT = {
  class: "figma-icon figma-icon-correction",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, VT = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M2.4751 4.07703C2.4751 4.59899 2.74685 5.05748 3.15659 5.31873V18.8539C2.74685 19.1151 2.4751 19.5736 2.4751 20.0956C2.4751 20.9083 3.13394 21.5672 3.94666 21.5672C4.55071 21.5672 5.06976 21.2032 5.29647 20.6826L18.9872 19.0231C19.2569 19.3305 19.6527 19.5246 20.0938 19.5246C20.9065 19.5246 21.5653 18.8658 21.5653 18.053C21.5653 17.5142 21.2758 17.0431 20.8438 16.7867V7.1062C21.2758 6.8498 21.5653 6.37863 21.5653 5.83984C21.5653 5.02712 20.9065 4.36828 20.0938 4.36828C19.606 4.36828 19.1737 4.60558 18.9059 4.97103L5.20278 3.31004C4.9442 2.88746 4.47836 2.60547 3.94666 2.60547C3.13394 2.60547 2.4751 3.26431 2.4751 4.07703ZM19.3438 16.7867V7.1062C19.0908 6.95606 18.8867 6.7323 18.7609 6.46443L5.21565 4.82258C5.08165 5.05017 4.88817 5.23854 4.65659 5.36633V18.8063C4.83296 18.9036 4.98723 19.0361 5.10996 19.1942L18.7121 17.5455C18.8295 17.2258 19.0548 16.9582 19.3438 16.7867Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), jT = [
  VT
];
function GT(n, t, e, s, i, r) {
  return J(), gt("svg", BT, jT);
}
const HT = /* @__PURE__ */ Xt(FT, [["render", GT]]), zT = {
  name: "IconCrop"
}, WT = {
  class: "figma-icon figma-icon-crop",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, KT = /* @__PURE__ */ O(
  "path",
  {
    d: "M5.29177 2.02344C5.70598 2.02344 6.04177 2.35922 6.04177 2.77344V17.7122C6.04177 17.8502 6.1537 17.9622 6.29177 17.9622H15.2493V17.9669H20.8391V17.9622H21.2237C21.638 17.9622 21.9737 18.2979 21.9737 18.7122C21.9737 19.1264 21.638 19.4622 21.2237 19.4622H19.4572V21.1723C19.4572 21.5865 19.1214 21.9223 18.7072 21.9223C18.2929 21.9223 17.9572 21.5865 17.9572 21.1723V19.4622H6.29177C5.32527 19.4622 4.54177 18.6786 4.54177 17.7122V6.04851H2.78076C2.36655 6.04851 2.03076 5.71272 2.03076 5.29851C2.03076 4.8843 2.36655 4.54851 2.78076 4.54851H4.54177V2.77344C4.54177 2.35922 4.87756 2.02344 5.29177 2.02344Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), YT = /* @__PURE__ */ O(
  "path",
  {
    d: "M19.4572 16.4148L19.4571 6.29851C19.4571 5.33201 18.6736 4.54851 17.7072 4.54851L7.59378 4.54851V6.04851L17.7072 6.04851C17.8452 6.04851 17.9572 6.16044 17.9572 6.29851L17.9572 16.4148L19.4572 16.4148Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), ZT = [
  KT,
  YT
];
function qT(n, t, e, s, i, r) {
  return J(), gt("svg", WT, ZT);
}
const K_ = /* @__PURE__ */ Xt(zT, [["render", qT]]), XT = {
  name: "IconCutout"
}, JT = {
  class: "figma-icon figma-icon-cutout",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, QT = /* @__PURE__ */ fy('<path fill-rule="evenodd" clip-rule="evenodd" d="M8.36821 4.40151C8.66442 4.36849 8.96523 4.35156 9.26972 4.35156C9.5742 4.35156 9.87501 4.36849 10.1712 4.40151C10.5829 4.4474 10.8794 4.81832 10.8335 5.22998C10.8281 5.27894 10.818 5.32627 10.8038 5.3716C11.9655 4.72189 13.3047 4.35156 14.7303 4.35156C19.1794 4.35156 22.7862 7.95829 22.7862 12.4074C22.7862 16.8565 19.1794 20.4633 14.7303 20.4633C13.3047 20.4633 11.9655 20.0929 10.8038 19.4432C10.818 19.4886 10.8281 19.5359 10.8335 19.5848C10.8794 19.9965 10.5829 20.3674 10.1712 20.4133C9.87502 20.4463 9.5742 20.4633 9.26972 20.4633C8.96523 20.4633 8.66442 20.4463 8.36821 20.4133C7.95654 20.3674 7.66003 19.9965 7.70591 19.5848C7.7518 19.1732 8.12272 18.8767 8.53438 18.9226C8.77553 18.9494 9.02086 18.9633 9.26972 18.9633C9.51445 18.9633 9.75579 18.9499 9.99308 18.9239C7.98175 17.4592 6.67448 15.086 6.67448 12.4074C6.67448 9.72886 7.98175 7.35564 9.99308 5.89095C9.75579 5.86494 9.51445 5.85156 9.26972 5.85156C9.02086 5.85156 8.77553 5.86539 8.53438 5.89227C8.12272 5.93816 7.7518 5.64164 7.70591 5.22998C7.66002 4.81832 7.95654 4.4474 8.36821 4.40151ZM8.17448 12.4074C8.17448 8.78672 11.1096 5.85156 14.7303 5.85156C18.351 5.85156 21.2862 8.78672 21.2862 12.4074C21.2862 16.0281 18.351 18.9633 14.7303 18.9633C11.1096 18.9633 8.17448 16.0281 8.17448 12.4074Z" fill="currentColor"></path><path d="M7.03465 5.40919C7.20049 5.78876 7.02723 6.2309 6.64766 6.39673C6.19543 6.59432 5.76956 6.8416 5.37699 7.13181C5.04391 7.37803 4.57428 7.30762 4.32805 6.97454C4.08182 6.64146 4.15223 6.17183 4.48532 5.9256C4.96732 5.56929 5.49071 5.2653 6.04711 5.0222C6.42667 4.85637 6.86881 5.02963 7.03465 5.40919Z" fill="currentColor"></path><path d="M3.83685 7.46575C4.16993 7.71198 4.24034 8.1816 3.99411 8.51468C3.70391 8.90725 3.45663 9.33312 3.25904 9.78536C3.0932 10.1649 2.65106 10.3382 2.2715 10.1723C1.89193 10.0065 1.71867 9.56437 1.88451 9.1848C2.12761 8.62841 2.43159 8.10502 2.78791 7.62301C3.03414 7.28993 3.50376 7.21952 3.83685 7.46575Z" fill="currentColor"></path><path d="M2.09228 10.8436C2.50395 10.8895 2.80047 11.2604 2.75458 11.6721C2.7277 11.9132 2.71387 12.1586 2.71387 12.4074C2.71387 12.6563 2.7277 12.9016 2.75458 13.1427C2.80047 13.5544 2.50395 13.9253 2.09228 13.9712C1.68062 14.0171 1.3097 13.7206 1.26381 13.3089C1.23079 13.0127 1.21387 12.7119 1.21387 12.4074C1.21387 12.1029 1.23079 11.8021 1.26381 11.5059C1.3097 11.0942 1.68062 10.7977 2.09228 10.8436Z" fill="currentColor"></path><path d="M2.2715 14.6425C2.65106 14.4766 3.0932 14.6499 3.25904 15.0295C3.45663 15.4817 3.70391 15.9076 3.99411 16.3001C4.24034 16.6332 4.16993 17.1028 3.83685 17.3491C3.50376 17.5953 3.03414 17.5249 2.78791 17.1918C2.43159 16.7098 2.12761 16.1864 1.88451 15.63C1.71867 15.2505 1.89193 14.8083 2.2715 14.6425Z" fill="currentColor"></path><path d="M4.32805 17.8403C4.57428 17.5072 5.04391 17.4368 5.37699 17.683C5.76956 17.9732 6.19543 18.2205 6.64766 18.4181C7.02723 18.5839 7.20049 19.0261 7.03465 19.4056C6.86881 19.7852 6.42667 19.9585 6.04711 19.7926C5.49071 19.5495 4.96732 19.2455 4.48532 18.8892C4.15223 18.643 4.08182 18.1734 4.32805 17.8403Z" fill="currentColor"></path>', 6), tA = [
  QT
];
function eA(n, t, e, s, i, r) {
  return J(), gt("svg", JT, tA);
}
const sA = /* @__PURE__ */ Xt(XT, [["render", eA]]), nA = {
  name: "IconImage2image"
}, iA = {
  class: "figma-icon figma-icon-image2image",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, rA = /* @__PURE__ */ O(
  "path",
  {
    d: "M7.65522 4.22656H17.7786C18.8831 4.22656 19.7786 5.12199 19.7786 6.22656V16.3499C19.7786 16.4068 19.7691 16.4615 19.7515 16.5125V18.1385C19.7515 18.1912 19.7495 18.2434 19.7455 18.2951C20.6248 18.0848 21.2786 17.2937 21.2786 16.3499V6.22656C21.2786 4.29357 19.7116 2.72656 17.7786 2.72656H7.65522C6.72113 2.72656 5.9366 3.36692 5.71668 4.23259C5.75805 4.23004 5.79977 4.22874 5.84178 4.22874H7.60825C7.62371 4.2273 7.63938 4.22656 7.65522 4.22656Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), oA = /* @__PURE__ */ O(
  "path",
  {
    d: "M4.35254 7.23941H16.2623C16.5384 7.23941 16.7623 7.46326 16.7623 7.73941V19.6492C16.7623 19.9253 16.5384 20.1492 16.2623 20.1492H8.70763L7.20763 21.6492H16.2623C17.3669 21.6492 18.2623 20.7537 18.2623 19.6492V7.73941C18.2623 6.63484 17.3669 5.73941 16.2623 5.73941H4.35254C3.24797 5.73941 2.35254 6.63484 2.35254 7.73941V16.7933L3.85254 15.2933V7.73941C3.85254 7.46326 4.0764 7.23941 4.35254 7.23941Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), aA = /* @__PURE__ */ O(
  "path",
  {
    d: "M12.754 10.3858C13.2683 10.2978 13.7152 10.7447 13.6272 11.2591L13.4138 12.5073C13.3858 12.671 13.4124 12.8394 13.4897 12.9865L14.0784 14.1077C14.321 14.5696 14.0341 15.1327 13.5177 15.208L12.2647 15.3907C12.1003 15.4147 11.9483 15.4921 11.8323 15.611L10.948 16.5174C10.5836 16.8909 9.95939 16.792 9.72823 16.3242L9.16727 15.1889C9.09368 15.04 8.9731 14.9194 8.82415 14.8458L7.68886 14.2848C7.22104 14.0537 7.12218 13.4295 7.49567 13.0651L8.40205 12.1807C8.52096 12.0647 8.59838 11.9128 8.62235 11.7484L8.80503 10.4953C8.8803 9.97894 9.4434 9.69203 9.90539 9.93463L11.0265 10.5234C11.1736 10.6006 11.342 10.6273 11.5058 10.5993L12.754 10.3858Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), cA = /* @__PURE__ */ O(
  "path",
  {
    d: "M6.67296 16.0402C7.03192 15.6812 7.61392 15.6812 7.97288 16.0402C8.33184 16.3991 8.33184 16.9811 7.97288 17.3401L4.56564 20.7473C4.20668 21.1063 3.62469 21.1063 3.26572 20.7473C2.90676 20.3884 2.90676 19.8064 3.26572 19.4474L6.67296 16.0402Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), lA = [
  rA,
  oA,
  aA,
  cA
];
function hA(n, t, e, s, i, r) {
  return J(), gt("svg", iA, lA);
}
const dA = /* @__PURE__ */ Xt(nA, [["render", hA]]), uA = {
  name: "IconImagefilter"
}, fA = {
  class: "figma-icon figma-icon-imagefilter",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, pA = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M6.13279 8.40103C6.13279 8.90334 6.19448 9.39124 6.31072 9.85756C3.85273 10.6087 2.06494 12.8951 2.06494 15.599C2.06494 18.9141 4.75239 21.6016 8.06753 21.6016C9.57206 21.6016 10.9473 21.048 12.0007 20.1335C13.0539 21.0471 14.4284 21.5999 15.932 21.5999C19.2472 21.5999 21.9346 18.9125 21.9346 15.5973C21.9346 12.9861 20.2673 10.7644 17.9392 9.93854C18.0689 9.44783 18.138 8.93249 18.138 8.40103C18.138 5.08589 15.4505 2.39844 12.1354 2.39844C8.82024 2.39844 6.13279 5.08589 6.13279 8.40103ZM13.3463 12.7389C15.2449 12.2101 16.638 10.4682 16.638 8.40103C16.638 5.91432 14.6221 3.89844 12.1354 3.89844C9.64866 3.89844 7.63279 5.91432 7.63279 8.40103C7.63279 8.8171 7.68922 9.21999 7.79485 9.60246C7.88524 9.59842 7.97615 9.59638 8.06753 9.59638C10.3472 9.59638 12.33 10.8671 13.3463 12.7389ZM17.3755 11.3311C16.6271 12.6666 15.3829 13.6869 13.8922 14.1424C14.0084 14.6088 14.0701 15.0967 14.0701 15.599C14.0701 16.869 13.6757 18.0469 13.0027 19.0168C13.7901 19.692 14.8134 20.0999 15.932 20.0999C18.4187 20.0999 20.4346 18.084 20.4346 15.5973C20.4346 13.6155 19.1542 11.9327 17.3755 11.3311ZM8.06753 20.1016C10.5542 20.1016 12.5701 18.0857 12.5701 15.599C12.5701 13.1123 10.5542 11.0964 8.06753 11.0964C5.58082 11.0964 3.56494 13.1123 3.56494 15.599C3.56494 18.0857 5.58082 20.1016 8.06753 20.1016Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), gA = [
  pA
];
function mA(n, t, e, s, i, r) {
  return J(), gt("svg", fA, gA);
}
const _A = /* @__PURE__ */ Xt(uA, [["render", mA]]), yA = {
  name: "IconLayers"
}, vA = {
  class: "figma-icon figma-icon-layers",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, bA = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M3.43971 10.5136C2.17244 9.73232 2.17244 7.88986 3.43971 7.10861L10.4259 2.80175C11.3911 2.20671 12.6093 2.20671 13.5745 2.80175L20.5607 7.10861C21.828 7.88986 21.828 9.73232 20.5607 10.5136L13.5745 14.8204C12.6093 15.4155 11.3911 15.4155 10.4259 14.8204L3.43971 10.5136ZM4.22687 8.38547L11.2131 4.07861C11.6957 3.78109 12.3048 3.78109 12.7874 4.07861L19.7736 8.38547C20.0904 8.58078 20.0904 9.0414 19.7736 9.23671L12.7874 13.5436C12.3048 13.8411 11.6957 13.8411 11.2131 13.5436L4.22687 9.23671C3.91005 9.0414 3.91005 8.58078 4.22687 8.38547Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), wA = /* @__PURE__ */ O(
  "path",
  {
    d: "M3.4399 13.4858L4.48545 12.8412L5.91463 13.7223L4.22706 14.7626C3.91024 14.9579 3.91024 15.4185 4.22706 15.6139L11.2132 19.9207C11.6959 20.2182 12.305 20.2182 12.7876 19.9207L19.7738 15.6139C20.0906 15.4185 20.0906 14.9579 19.7738 14.7626L18.0862 13.7223L19.5154 12.8412L20.5609 13.4857C21.8282 14.267 21.8282 16.1095 20.5609 16.8907L13.5747 21.1976C12.6095 21.7926 11.3913 21.7926 10.4261 21.1976L3.4399 16.8907C2.17263 16.1095 2.17263 14.267 3.4399 13.4858Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), SA = [
  bA,
  wA
];
function CA(n, t, e, s, i, r) {
  return J(), gt("svg", vA, SA);
}
const kA = /* @__PURE__ */ Xt(yA, [["render", CA]]), xA = {
  name: "IconLink"
}, EA = {
  class: "figma-icon figma-icon-link",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, TA = /* @__PURE__ */ O(
  "path",
  {
    d: "M12 2.00098C9.515 2.00098 7.50049 4.01549 7.50049 6.50052V9.37516C7.50049 9.78937 7.83627 10.1252 8.25049 10.1252C8.6647 10.1252 9.00049 9.78937 9.00049 9.37516V6.50052C9.00049 4.84392 10.3434 3.50098 12 3.50098C13.6566 3.50098 14.9996 4.84391 14.9996 6.50051V9.37516C14.9996 9.78937 15.3354 10.1252 15.7496 10.1252C16.1638 10.1252 16.4996 9.78937 16.4996 9.37516V6.50051C16.4996 4.01549 14.4851 2.00098 12 2.00098Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), AA = /* @__PURE__ */ O(
  "path",
  {
    d: "M9.00049 14.6245C9.00049 14.2103 8.6647 13.8745 8.25049 13.8745C7.83627 13.8745 7.50049 14.2103 7.50049 14.6245V17.4992C7.50049 19.9842 9.515 21.9987 12 21.9987C14.4851 21.9987 16.4996 19.9842 16.4996 17.4992V14.6245C16.4996 14.2103 16.1638 13.8745 15.7496 13.8745C15.3354 13.8745 14.9996 14.2103 14.9996 14.6245V17.4992C14.9996 19.1558 13.6566 20.4987 12 20.4987C10.3434 20.4987 9.00049 19.1558 9.00049 17.4992V14.6245Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), IA = /* @__PURE__ */ O(
  "path",
  {
    d: "M12.7498 8.37545C12.7498 7.96124 12.4141 7.62545 11.9998 7.62545C11.5856 7.62545 11.2498 7.96124 11.2498 8.37545V15.6246C11.2498 16.0388 11.5856 16.3746 11.9998 16.3746C12.4141 16.3746 12.7498 16.0388 12.7498 15.6246V8.37545Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), OA = [
  TA,
  AA,
  IA
];
function DA(n, t, e, s, i, r) {
  return J(), gt("svg", EA, OA);
}
const PA = /* @__PURE__ */ Xt(xA, [["render", DA]]), MA = {
  name: "IconMagicwand"
}, RA = {
  class: "figma-icon figma-icon-magicwand",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, $A = /* @__PURE__ */ O(
  "path",
  {
    d: "M19.3739 2.14733C19.469 1.91443 19.7988 1.91443 19.8939 2.14733L20.3189 3.18828C20.4136 3.42033 20.5978 3.60449 20.8299 3.69923L21.8708 4.12422C22.1037 4.2193 22.1037 4.54912 21.8708 4.6442L20.8299 5.06919C20.5978 5.16393 20.4136 5.34808 20.3189 5.58014L19.8939 6.62109C19.7988 6.85399 19.469 6.85399 19.3739 6.62109L18.9489 5.58014C18.8541 5.34808 18.67 5.16393 18.4379 5.06919L17.3969 4.6442C17.164 4.54912 17.164 4.2193 17.3969 4.12422L18.4379 3.69923C18.67 3.60449 18.8541 3.42033 18.9489 3.18828L19.3739 2.14733Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), NA = /* @__PURE__ */ O(
  "path",
  {
    d: "M9.96886 3.47748C10.0391 3.30554 10.2825 3.30554 10.3527 3.47748L10.6665 4.24598C10.7365 4.41729 10.8724 4.55325 11.0437 4.62319L11.8123 4.93694C11.9842 5.00714 11.9842 5.25063 11.8123 5.32083L11.0437 5.63458C10.8724 5.70452 10.7365 5.84047 10.6665 6.01179L10.3527 6.78029C10.2825 6.95222 10.0391 6.95222 9.96886 6.78028L9.65508 6.01179C9.58513 5.84047 9.44917 5.70452 9.27785 5.63458L8.50934 5.32083C8.33739 5.25063 8.33739 5.00714 8.50934 4.93694L9.27785 4.62319C9.44917 4.55325 9.58513 4.41729 9.65508 4.24597L9.96886 3.47748Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), LA = /* @__PURE__ */ O(
  "path",
  {
    d: "M19.6499 11.6876C19.5992 11.5636 19.4236 11.5636 19.373 11.6876L19.1466 12.242C19.0961 12.3656 18.998 12.4637 18.8744 12.5142L18.32 12.7405C18.196 12.7912 18.196 12.9668 18.32 13.0175L18.8744 13.2438C18.998 13.2943 19.0961 13.3924 19.1466 13.516L19.373 14.0704C19.4236 14.1944 19.5992 14.1944 19.6499 14.0704L19.8763 13.516C19.9267 13.3924 20.0248 13.2943 20.1484 13.2438L20.7028 13.0175C20.8269 12.9668 20.8269 12.7912 20.7028 12.7405L20.1484 12.5142C20.0248 12.4637 19.9267 12.3656 19.8763 12.242L19.6499 11.6876Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), UA = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M2.19711 17.292C1.41607 18.073 1.41607 19.3394 2.19712 20.1204L3.74996 21.6733C4.53101 22.4543 5.79734 22.4543 6.57839 21.6733L17.8755 10.3761C18.6566 9.59506 18.6566 8.32873 17.8755 7.54768L16.3227 5.99484C15.5416 5.21379 14.2753 5.21379 13.4943 5.99484L2.19711 17.292ZM11.4745 10.1359L3.25777 18.3526C3.06251 18.5479 3.06251 18.8645 3.25778 19.0598L4.81062 20.6126C5.00588 20.8079 5.32246 20.8079 5.51773 20.6126L13.7341 12.3963L11.4745 10.1359ZM12.5352 9.07524L14.7947 11.3356L16.8149 9.31545C17.0101 9.12019 17.0101 8.8036 16.8149 8.60834L15.262 7.0555C15.0668 6.86024 14.7502 6.86023 14.5549 7.0555L12.5352 9.07524Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), FA = [
  $A,
  NA,
  LA,
  UA
];
function BA(n, t, e, s, i, r) {
  return J(), gt("svg", RA, FA);
}
const VA = /* @__PURE__ */ Xt(MA, [["render", BA]]), jA = {
  name: "IconMinus"
}, GA = {
  class: "figma-icon figma-icon-minus",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, HA = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M3.00146 12C3.00146 11.5858 3.33725 11.25 3.75146 11.25L20.2598 11.25C20.674 11.25 21.0098 11.5858 21.0098 12C21.0098 12.4142 20.674 12.75 20.2598 12.75L3.75146 12.75C3.33725 12.75 3.00146 12.4142 3.00146 12Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), zA = [
  HA
];
function WA(n, t, e, s, i, r) {
  return J(), gt("svg", GA, zA);
}
const KA = /* @__PURE__ */ Xt(jA, [["render", WA]]), YA = {
  name: "IconRedo"
}, ZA = {
  class: "figma-icon figma-icon-redo",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, qA = /* @__PURE__ */ O(
  "path",
  {
    d: "M17.4138 12.5807C17.1209 12.8736 16.6461 12.8736 16.3532 12.5807C16.0603 12.2878 16.0603 11.8129 16.3532 11.52L18.4515 9.42174L8.75436 9.42169C6.39807 9.42168 4.48792 11.3318 4.48792 13.6881C4.48792 16.0444 6.39806 17.9545 8.75434 17.9545H13.2068C13.6211 17.9545 13.9568 18.2903 13.9568 18.7045C13.9568 19.1188 13.6211 19.4545 13.2068 19.4545H8.75434C5.56963 19.4545 2.98792 16.8728 2.98792 13.6881C2.98792 10.5034 5.56965 7.92167 8.75437 7.92169L18.4516 7.92174L16.3532 5.8233C16.0603 5.53041 16.0603 5.05553 16.3532 4.76264C16.6461 4.46975 17.1209 4.46975 17.4138 4.76264L20.7925 8.14133C21.0854 8.43422 21.0854 8.9091 20.7925 9.20199L17.4138 12.5807Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), XA = [
  qA
];
function JA(n, t, e, s, i, r) {
  return J(), gt("svg", ZA, XA);
}
const QA = /* @__PURE__ */ Xt(YA, [["render", JA]]), tI = {
  name: "IconRemove"
}, eI = {
  class: "figma-icon figma-icon-remove",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, sI = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M13.26 19.3367L21.4241 11.1726C22.2051 10.3915 22.2051 9.1252 21.4241 8.34415L16.2378 3.15793C15.4568 2.37688 14.1905 2.37688 13.4094 3.15793L2.58334 13.984C1.8023 14.765 1.8023 16.0314 2.58335 16.8124L6.09432 20.3241C6.42251 20.6523 6.86763 20.8367 7.33176 20.8367H20.1942C20.6085 20.8367 20.9442 20.5009 20.9442 20.0867C20.9442 19.6724 20.6085 19.3367 20.1942 19.3367H13.26ZM20.3634 9.40481L15.1772 4.21859C14.9819 4.02333 14.6653 4.02333 14.4701 4.21859L7.92893 10.7597L13.8222 16.6531L20.3634 10.1119C20.5587 9.91666 20.5587 9.60007 20.3634 9.40481ZM12.7616 17.7137L6.86827 11.8204L3.644 15.0447C3.44874 15.2399 3.44874 15.5565 3.64401 15.7518L7.1664 19.2742C7.21193 19.3143 7.27069 19.3367 7.33176 19.3367H11.1387L12.7616 17.7137Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), nI = [
  sI
];
function iI(n, t, e, s, i, r) {
  return J(), gt("svg", eI, nI);
}
const rI = /* @__PURE__ */ Xt(tI, [["render", iI]]), oI = {
  name: "IconResize"
}, aI = {
  class: "figma-icon figma-icon-resize",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, cI = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M4.75 3C3.7835 3 3 3.7835 3 4.75V19.25C3 20.2165 3.7835 21 4.75 21H19.25C20.2165 21 21 20.2165 21 19.25V4.75C21 3.7835 20.2165 3 19.25 3H4.75ZM12.4147 19.5H19.25C19.3881 19.5 19.5 19.3881 19.5 19.25V4.75C19.5 4.61193 19.3881 4.5 19.25 4.5H4.75C4.61193 4.5 4.5 4.61193 4.5 4.75V9.88281H10.6647C11.6312 9.88281 12.4147 10.6663 12.4147 11.6328V19.5ZM4.5 11.3828V19.25C4.5 19.3881 4.61193 19.5 4.75 19.5H10.9147V11.6328C10.9147 11.4947 10.8028 11.3828 10.6647 11.3828H4.5Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), lI = [
  cI
];
function hI(n, t, e, s, i, r) {
  return J(), gt("svg", aI, lI);
}
const dI = /* @__PURE__ */ Xt(oI, [["render", hI]]), uI = {
  name: "IconRevoke"
}, fI = {
  class: "figma-icon figma-icon-revoke",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, pI = /* @__PURE__ */ O(
  "path",
  {
    d: "M6.58615 12.5807C6.87905 12.8736 7.35392 12.8736 7.64681 12.5807C7.93971 12.2878 7.93971 11.8129 7.64681 11.52L5.54853 9.42174L15.2456 9.42169C17.6019 9.42168 19.5121 11.3318 19.5121 13.6881C19.5121 16.0444 17.6019 17.9545 15.2457 17.9545H10.7931C10.3789 17.9545 10.0431 18.2903 10.0431 18.7045C10.0431 19.1188 10.3789 19.4545 10.7931 19.4545H15.2457C18.4304 19.4545 21.0121 16.8728 21.0121 13.6881C21.0121 10.5034 18.4303 7.92167 15.2456 7.92169L5.54837 7.92174L7.64681 5.8233C7.93971 5.53041 7.93971 5.05553 7.64681 4.76264C7.35392 4.46975 6.87905 4.46975 6.58615 4.76264L3.20746 8.14133C2.91457 8.43422 2.91457 8.9091 3.20746 9.20199L6.58615 12.5807Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), gI = [
  pI
];
function mI(n, t, e, s, i, r) {
  return J(), gt("svg", fI, gI);
}
const _I = /* @__PURE__ */ Xt(uI, [["render", mI]]), yI = {
  name: "IconShadow"
}, vI = {
  class: "figma-icon figma-icon-shadow",
  "aria-hidden": "true",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, bI = /* @__PURE__ */ O(
  "path",
  {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M4.5 2.5C3.39543 2.5 2.5 3.39543 2.5 4.5V16.5C2.5 17.6046 3.39543 18.5 4.5 18.5V19.5C4.5 20.6046 5.39543 21.5 6.5 21.5H19.5C20.6046 21.5 21.5 20.6046 21.5 19.5L21.5 6.49755C21.5 5.92238 21.2572 5.40392 20.8685 5.03906L20.8673 5.04034C20.5096 4.70521 20.0288 4.5 19.5 4.5H18.5C18.5 3.39543 17.6046 2.5 16.5 2.5H4.5ZM16.5 4H4.5C4.22386 4 4 4.22386 4 4.5V16.5C4 16.7761 4.22386 17 4.5 17H16.5C16.7761 17 17 16.7761 17 16.5V4.5C17 4.22386 16.7761 4 16.5 4ZM18.5 6V16.5C18.5 17.6046 17.6046 18.5 16.5 18.5H15.1858L13.6858 20H16.2213L20 16.2213V13.6858L18.5 15.1858V13.0644L20 11.5645V8.02892L18.5 9.52891V7.40759L19.8043 6.10326C19.72 6.0385 19.6145 6 19.5 6H18.5ZM20 18.3426L18.3426 20H19.5C19.7761 20 20 19.7761 20 19.5V18.3426ZM11.5645 20L13.0645 18.5H9.52892L8.02892 20H11.5645ZM6.10326 19.8043L7.4076 18.5H6V19.5C6 19.6145 6.0385 19.72 6.10326 19.8043Z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), wI = [
  bI
];
function SI(n, t, e, s, i, r) {
  return J(), gt("svg", vI, wI);
}
const CI = /* @__PURE__ */ Xt(yI, [["render", SI]]), kI = {
  key: 0,
  class: "flex-1"
}, xI = {
  class: "tooltip tooltip-bottom",
  "data-tip": "Saving..."
}, EI = {
  type: "button",
  class: "btn btn-square btn-ghost ml-1"
}, TI = /* @__PURE__ */ O(
  "div",
  { class: "divider divider-horizontal mx-0 my-3 w-2" },
  null,
  -1
  /* HOISTED */
), AI = {
  class: "tooltip tooltip-bottom",
  "data-tip": "Undo"
}, II = ["disabled"], OI = {
  class: "tooltip tooltip-bottom",
  "data-tip": "Redo"
}, DI = ["disabled"], PI = {
  key: 1,
  class: "flex-none"
}, MI = /* @__PURE__ */ $e({
  __name: "Header",
  props: {
    title: {}
  },
  setup(n) {
    const { editor: t, doc: e } = sn();
    async function s(r = {}, o = null) {
      const a = await t.exportImage(
        {
          pixelRatio: 2,
          ...r
        },
        o
      );
      t.saveToFile(a);
    }
    async function i() {
      const r = t.getActiveBlock();
      if (!r || t.getSelections().length > 1) {
        alert("Please select a block to export");
        return;
      }
      const o = await t.exportImage({}, r);
      t.saveToFile(o);
    }
    return (r, o) => (J(), gt(
      Go,
      null,
      [
        xe(` <div class="flex-none mr-2">
    <a href="javascript:;" class="btn btn-ghost mr-1"
      ><h1 class="font-medium">{{ title }}</h1></a
    >
    <button class="btn btn-square btn-ghost">
      <i-material-symbols:menu-rounded></i-material-symbols:menu-rounded>
    </button>
  </div> `),
        bt(e) ? (J(), gt("div", kI, [
          O("div", xI, [
            O("button", EI, [
              fe(bt(DT))
            ])
          ]),
          TI,
          O("div", AI, [
            O("button", {
              type: "button",
              class: "btn btn-square btn-ghost ml-1",
              disabled: !bt(e).canUndo,
              onClick: o[0] || (o[0] = (a) => {
                var c;
                return (c = bt(e)) == null ? void 0 : c.undo();
              })
            }, [
              fe(bt(_I))
            ], 8, II)
          ]),
          O("div", OI, [
            O("button", {
              type: "button",
              class: "btn btn-square btn-ghost ml-1",
              disabled: !bt(e).canRedo,
              onClick: o[1] || (o[1] = (a) => {
                var c;
                return (c = bt(e)) == null ? void 0 : c.redo();
              })
            }, [
              fe(bt(QA))
            ], 8, DI)
          ]),
          xe(' <input type="text" :value="doc.id" placeholder="Filename" class="input input-bordered ml-2 max-w-xs" /> ')
        ])) : xe("v-if", !0),
        bt(e) ? (J(), gt("div", PI, [
          O("button", {
            type: "button",
            class: "btn mr-2",
            onClick: o[2] || (o[2] = (a) => i())
          }, " Save as template "),
          O("button", {
            type: "button",
            class: "btn btn-primary",
            onClick: o[3] || (o[3] = (a) => s())
          }, " Export "),
          xe(` <button class="btn ml-1 btn-square btn-ghost">
      <i-material-symbols:more-horiz></i-material-symbols:more-horiz>
    </button> `)
        ])) : xe("v-if", !0)
      ],
      64
      /* STABLE_FRAGMENT */
    ));
  }
}), RI = (n, t) => {
  const e = n[t];
  return e ? typeof e == "function" ? e() : Promise.resolve(e) : new Promise((s, i) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(i.bind(null, new Error("Unknown variable dynamic import: " + t)));
  });
}, $I = /* @__PURE__ */ $e({
  __name: "Props",
  setup(n) {
    const { editor: t, selections: e } = sn(), s = Jn(() => t.getCurrentFrame()), i = Jn(() => t.getActiveBlock(e.value));
    function r(o = "") {
      return o || (o = t.getBlockType(i.value)), !o && s.value && (o = "Frame"), $i(() => RI(/* @__PURE__ */ Object.assign({ "../props/Frame.vue": () => import("./Frame-BLelyKGK.mjs"), "../props/Image.vue": () => import("./Image-CL33UlJQ.mjs"), "../props/Mixed.vue": () => import("./Mixed-BB4BZ-RR.mjs"), "../props/PropBase.vue": () => import("./PropBase-Wu3roZyp.mjs"), "../props/Shape.vue": () => import("./Shape-DoU6JFvX.mjs") }), `../props/${o}.vue`));
    }
    return (o, a) => i.value || s.value ? (J(), Fe(Hh(r()), {
      key: 0,
      activeBlock: i.value || s.value
    }, null, 8, ["activeBlock"])) : xe("v-if", !0);
  }
}), NI = { class: "xpix-editor-nav p-4" }, LI = ["onClick"], UI = { key: 1 }, FI = ["src", "width", "height", "alt"], BI = /* @__PURE__ */ $e({
  __name: "Nav",
  setup(n) {
    const { editor: t, doc: e } = sn(), s = Jn(() => e.value ? t.getRootFrames() : []), i = Jn(() => e.value ? t.getCurrentFrame() : void 0);
    function r(f) {
      t.switchFrame(f);
    }
    const o = so(/* @__PURE__ */ new Map());
    function a(f) {
      const p = f.id, m = o.value.get(p) || "";
      return m || l(f), m;
    }
    async function c(f) {
      try {
        const p = 300 / f.width, m = await t.exportImage(
          {
            pixelRatio: p
          },
          f
        ), _ = o.value.get(f.id);
        _ && URL.revokeObjectURL(_);
        const v = URL.createObjectURL(m);
        o.value.set(f.id, v);
      } catch (p) {
        console.log("makeThumbnail.error:", p);
      }
    }
    const l = Pc(c, 1024, {
      leading: !0
    });
    let h = null;
    E1(() => {
      var p;
      const f = (p = e.value) == null ? void 0 : p.slots;
      h = f == null ? void 0 : f.historyUpdated.on(() => {
        i.value && l(i.value);
      }), t.on("frame:switch", (m) => {
        a(m) || l(m);
      });
    }), py(() => {
      h && h.dispose();
    });
    const d = so(null);
    function u(f) {
      var m;
      return (((m = d.value) == null ? void 0 : m.clientWidth) || 120) * f.height / f.width;
    }
    return (f, p) => (J(), gt("div", NI, [
      xe(` <div
      class="btn mb-4 shadow-xl rounded-lg text-2xl w-full h-28"
      @click="addFrame()"
      ref="addBtn"
    >
      <IconAdd />
    </div> `),
      (J(!0), gt(
        Go,
        null,
        ru(s.value, (m) => (J(), gt("div", {
          class: gy([
            "mb-4 shadow-xl rounded-lg cursor-pointer overflow-hidden max",
            i.value === m ? "outline outline-offset-1 outline-2 outline-primary" : ""
          ]),
          key: m.id,
          onClick: (_) => r(m)
        }, [
          a(m) ? (J(), gt("figure", UI, [
            O("img", {
              src: a(m),
              width: m.width,
              height: m.height,
              alt: m.name
            }, null, 8, FI)
          ])) : (J(), gt(
            "div",
            {
              key: 0,
              class: "skeleton",
              style: T1({ height: u(m) + "px" })
            },
            null,
            4
            /* STYLE */
          ))
        ], 10, LI))),
        128
        /* KEYED_FRAGMENT */
      ))
    ]));
  }
}), VI = { class: "xpix-editor-Helper absolute right-4 bottom-4" }, jI = {
  class: "tooltip tooltip-top join-item",
  "data-tip": "Original picture"
}, GI = {
  type: "button",
  class: "btn btn-sm btn-outline btn-ghost ml-1"
}, HI = { class: "join ml-2" }, zI = /* @__PURE__ */ $e({
  __name: "Helper",
  setup(n) {
    const { editor: t, viewState: e } = sn(), s = Jn(() => (e.value.zoomRatio * 100).toFixed(2).replace(/\.\d+$/, "") + "%");
    function i() {
      e.value.zoomRatio === 1 ? t.fitZoom() : t.zoomTo(1);
    }
    return (r, o) => (J(), gt("div", VI, [
      O("div", jI, [
        O("button", GI, [
          fe(bt(UT))
        ])
      ]),
      O("div", HI, [
        O("button", {
          type: "button",
          class: "btn btn-sm btn-outline btn-ghost join-item",
          onClick: o[0] || (o[0] = (a) => bt(t).zoomOut())
        }, [
          fe(bt(KA))
        ]),
        O(
          "button",
          {
            type: "button",
            class: "btn btn-sm btn-outline btn-ghost join-item min-w-16 text-center",
            onClick: o[1] || (o[1] = (a) => i())
          },
          gr(s.value),
          1
          /* TEXT */
        ),
        O("button", {
          type: "button",
          class: "btn btn-sm btn-outline btn-ghost join-item",
          onClick: o[2] || (o[2] = (a) => bt(t).zoomIn())
        }, [
          fe(bt(rT))
        ])
      ])
    ]));
  }
}), WI = { class: "xpix-editor-header flex-none navbar border-b border-slate-700" }, KI = { class: "xpix-editor-main flex flex-1" }, YI = { class: "xpix-editor-res flex-none border-r border-slate-700 w-[152px]" }, ZI = { class: "xpix-editor-container relative flex-1" }, qI = /* @__PURE__ */ O(
  "div",
  { class: "loader text-center p-20" },
  [
    /* @__PURE__ */ O("div", { class: "join mx-auto" }, [
      /* @__PURE__ */ O("i", { class: "loading loading-spinner loading-md" }),
      /* @__PURE__ */ O("span", { class: "ml-1" }, "Loading...")
    ])
  ],
  -1
  /* HOISTED */
), XI = [
  qI
], JI = { class: "xpix-editor-props relative flex-none bg-base-100 border-l border-slate-700 w-[320px]" }, lD = /* @__PURE__ */ $e({
  __name: "ImageEditor",
  props: {
    config: {
      type: Object,
      required: !0,
      default: () => ({
        title: "XPix-Editor"
      })
    }
  },
  setup(n) {
    const t = so(null), e = Bi(void 0);
    return my(QE), E1(async () => {
      const i = (await JE(t.value)).editorState.value;
      if (!i)
        throw new Error("Failed to install editor");
      _y(i.doc, (a) => {
        e.value = a;
      });
      const r = i.editor, o = r.getCurrentFrame();
      o && o.children.length <= 0 && r.runDemo();
    }), (s, i) => (J(), gt(
      Go,
      null,
      [
        O("div", WI, [
          e.value ? (J(), Fe(bt(MI), {
            key: 0,
            title: n.config.title || "XPix-Editor"
          }, null, 8, ["title"])) : xe("v-if", !0)
        ]),
        O("div", KI, [
          O("div", YI, [
            e.value ? (J(), Fe(bt(BI), { key: 0 })) : xe("v-if", !0)
          ]),
          O("div", ZI, [
            O(
              "div",
              {
                class: "xpix-editor-shell absolute w-full h-full",
                ref_key: "shell",
                ref: t
              },
              XI,
              512
              /* NEED_PATCH */
            ),
            e.value ? (J(), Fe(bt(zI), { key: 0 })) : xe("v-if", !0)
          ]),
          O("div", JI, [
            e.value ? (J(), Fe(bt($I), { key: 0 })) : xe("v-if", !0)
          ])
        ])
      ],
      64
      /* STABLE_FRAGMENT */
    ));
  }
});
function QI() {
  return jo("activeBlock");
}
function tO() {
  return jo("activeBlockType");
}
const eO = { class: "xpix-editor-prop xpix-editor-prop-tool absolute left-0 top-0 w-full h-full bg-base-100" }, sO = { class: "xpix-prop-header px-4 border-b border-slate-700" }, nO = { class: "xpix-prop-main mx-4 py-5" }, iO = /* @__PURE__ */ O(
  "span",
  { class: "p-2" },
  "Current Block props not implemented yet",
  -1
  /* HOISTED */
), Pf = /* @__PURE__ */ $e({
  __name: "PropToolBase",
  props: {
    toolName: String
  },
  emits: ["close"],
  setup(n, { emit: t }) {
    const e = t, s = tO();
    return (i, r) => (J(), gt("div", eO, [
      O("div", sO, [
        Yi(i.$slots, "header", {}, () => [
          O("a", {
            href: "javascript:;",
            class: "flex py-4",
            onClick: r[0] || (r[0] = (o) => e("close"))
          }, [
            fe(bt(_T)),
            O(
              "span",
              null,
              gr(n.toolName || bt(s)),
              1
              /* TEXT */
            )
          ])
        ])
      ]),
      O("div", nO, [
        Yi(i.$slots, "default", {}, () => [
          iO
        ])
      ])
    ]));
  }
}), rO = { class: "color-group" }, oO = /* @__PURE__ */ O(
  "i",
  { class: "w-8 h-8 cursor-pointer" },
  "Transparent",
  -1
  /* HOISTED */
), aO = [
  oO
], cO = { class: "avatar color-picker" }, lO = /* @__PURE__ */ O(
  "i",
  { class: "w-8 h-8 cursor-pointer" },
  "Color picker",
  -1
  /* HOISTED */
), hO = ["value"], dO = ["onClick"], uO = { class: "w-8 h-8 cursor-pointer" }, hD = /* @__PURE__ */ $e({
  __name: "Background",
  props: {
    toolName: {}
  },
  setup(n) {
    const t = n, e = so([
      "#2C2C2C",
      "#7D7D7D",
      "#BABABA",
      "#D9D9D9",
      "#FEFEFE",
      "#B0301D",
      "#EE9130",
      "#F2DC6C",
      "#64833F",
      "#6E79E5",
      "#212080",
      "#411E80",
      "#D28C86",
      "#F6D3A3",
      "#EBE1A6",
      "#BAD993",
      "#8C94D1",
      "#686AB2",
      "#9F8DC1"
    ]), { editor: s } = sn(), i = QI();
    function r(a) {
      s.updateBlock(i, {
        background: a || "transparent"
      });
    }
    function o(a) {
      r(a.target.value);
    }
    return (a, c) => (J(), Fe(
      Pf,
      Ho(zo(t)),
      {
        default: pn(() => [
          O("div", rO, [
            O("div", {
              class: "avatar color-transparent",
              onClick: c[0] || (c[0] = (l) => r(""))
            }, aO),
            O("div", cO, [
              lO,
              O("input", {
                type: "color",
                value: bt(i).background,
                onInput: o
              }, null, 40, hO)
            ]),
            (J(!0), gt(
              Go,
              null,
              ru(e.value, (l) => (J(), gt("div", {
                key: l,
                class: "avatar",
                style: T1({ backgroundColor: l }),
                onClick: (h) => r(l)
              }, [
                O(
                  "i",
                  uO,
                  gr(l),
                  1
                  /* TEXT */
                )
              ], 12, dO))),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ));
  }
}), fO = /* @__PURE__ */ O(
  "h5",
  { class: "mb-3" },
  "Custom size",
  -1
  /* HOISTED */
), pO = { class: "form-inner flex" }, gO = /* @__PURE__ */ O(
  "input",
  {
    name: "width",
    type: "text",
    placeholder: "0",
    class: "input input-bordered w-16",
    min: "0",
    max: "1000",
    step: "1",
    value: "100"
  },
  null,
  -1
  /* HOISTED */
), mO = { class: "btn btn-outline mx-2" }, _O = /* @__PURE__ */ O(
  "input",
  {
    type: "text",
    placeholder: "0",
    class: "input input-bordered w-16",
    min: "0",
    max: "1000",
    step: "1",
    value: "100"
  },
  null,
  -1
  /* HOISTED */
), yO = /* @__PURE__ */ O(
  "select",
  { class: "select select-bordered w-20 ml-3" },
  [
    /* @__PURE__ */ O("option", { selected: "" }, "px"),
    /* @__PURE__ */ O("option", null, "cm")
  ],
  -1
  /* HOISTED */
), dD = /* @__PURE__ */ $e({
  __name: "Resize",
  props: {
    toolName: {}
  },
  setup(n) {
    const t = n;
    return (e, s) => (J(), Fe(
      Pf,
      yy(t, { "tool-name": "Resize" }),
      {
        default: pn(() => [
          O(
            "form",
            {
              action: ".",
              onSubmit: s[0] || (s[0] = vy(() => {
              }, ["prevent"]))
            },
            [
              fO,
              O("div", pO, [
                gO,
                O("button", mO, [
                  fe(bt(PA))
                ]),
                _O,
                yO
              ])
            ],
            32
            /* NEED_HYDRATION */
          )
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ));
  }
}), vO = { class: "p-5" }, uD = /* @__PURE__ */ $e({
  __name: "Crop",
  props: {
    toolName: {}
  },
  setup(n) {
    const t = n;
    return (e, s) => (J(), Fe(
      Pf,
      Ho(zo(t)),
      {
        default: pn(() => [
          O(
            "p",
            vO,
            "TODO: " + gr(e.toolName),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ));
  }
}), bO = { class: "x-pix-editor-prop" }, wO = { class: "x-pix-prop-header px-4 border-b border-slate-700" }, SO = { class: "py-4" }, CO = { class: "x-pix-prop-main mx-4 pb-5" }, kO = /* @__PURE__ */ O(
  "span",
  { class: "p-2" },
  "Current Block props not implemented yet",
  -1
  /* HOISTED */
), xO = { class: "x-pix-editor-prop" }, EO = /* @__PURE__ */ O(
  "div",
  { class: "x-pix-prop-header px-4 border-t border-b border-slate-700" },
  [
    /* @__PURE__ */ xe(' <h4 class="py-4">Tools</h4> ')
  ],
  -1
  /* HOISTED */
), TO = { class: "x-pix-prop-main mx-4 py-5" }, Mf = /* @__PURE__ */ $e({
  __name: "PropBase",
  props: {
    activeBlock: {}
  },
  setup(n) {
    const t = n, { editor: e } = sn(), s = Jn(() => {
      const r = e.getBlockType(t.activeBlock);
      return r !== "Frame" ? r : "Board";
    });
    Ga("activeBlock", t.activeBlock), Ga("activeBlockType", s);
    function i() {
      e.removeBlock(t.activeBlock);
    }
    return (r, o) => (J(), gt("div", bO, [
      O("div", wO, [
        Yi(r.$slots, "header", {}, () => [
          O(
            "h4",
            SO,
            gr(s.value),
            1
            /* TEXT */
          )
        ])
      ]),
      O("div", CO, [
        Yi(r.$slots, "default", {}, () => [
          kO
        ])
      ]),
      Yi(r.$slots, "ext", {}, () => [
        O("div", xO, [
          EO,
          O("div", TO, [
            O("button", {
              type: "button",
              class: "btn mr-2 mb-2",
              onClick: o[0] || (o[0] = (a) => i())
            }, "Delete")
          ])
        ])
      ])
    ]));
  }
}), AO = { class: "menu xpix-prop-menu" }, IO = ["onClick"], OO = { class: "xpix-editor-prop" }, DO = /* @__PURE__ */ O(
  "div",
  { class: "xpix-prop-header px-4 border-t border-b border-slate-700" },
  [
    /* @__PURE__ */ xe(' <h4 class="py-4">Tools</h4> ')
  ],
  -1
  /* HOISTED */
), PO = { class: "xpix-prop-main mx-4 py-5" }, fD = /* @__PURE__ */ $e({
  __name: "Frame",
  props: {
    activeBlock: {}
  },
  setup(n) {
    const { editor: t } = sn(), e = n;
    Ga("activeBlock", e.activeBlock);
    const s = so([
      {
        name: "Resize",
        component() {
          return $i(() => import("./Resize-CKvOrNyM.mjs"));
        },
        icon() {
          return dI;
        },
        active: !1
      },
      {
        name: "Crop",
        component() {
          return $i(() => import("./Crop-BSJOwtEa.mjs"));
        },
        icon() {
          return K_;
        },
        active: !1
      },
      {
        name: "Background",
        component() {
          return $i(() => import("./Background-Bv68ckyV.mjs"));
        },
        icon() {
          return CT;
        },
        active: !1
      },
      {
        name: "Magic Eraser",
        component() {
          return $i(
            () => import("./MagicEraser-DqypwuNR.mjs")
          );
        },
        icon() {
          return rI;
        },
        active: !1
      },
      {
        name: "AI Image to Image",
        component() {
          return $i(
            () => import("./AIImageToImage-RHWAZsaB.mjs")
          );
        },
        icon() {
          return dA;
        },
        active: !1
      }
    ]), i = Jn(() => s.value.find((c) => c.active));
    function r(c) {
      i.value && (i.value.active = !1), c.active = !0;
    }
    const o = {
      runDemo() {
        return t.runDemo();
      },
      clearStage() {
        alert("Clear stage not implemented yet");
      },
      addRect() {
        return t.addBlock("shape", {
          type: "rect",
          x: 100,
          y: 100,
          width: 100,
          height: 100,
          fill: "#EE0"
        });
      },
      addCircle() {
        return t.addBlock("shape", {
          type: "circle",
          x: 100,
          y: 100,
          radius: 50,
          fill: "#0A0"
        });
      },
      async addImage() {
        (await t.showOpenFilePicker({
          excludeAcceptAllOption: !0,
          multiple: !0,
          accept: {
            "image/*": [".png", ".gif", ".jpeg", ".jpg"]
          }
        })).forEach(async (l) => {
          if (l.type.startsWith("image/")) {
            const h = await t.addImage(l);
            t.select(h);
          }
        });
      },
      addText() {
        return t.addBlock("text", {
          x: 100,
          y: 100,
          text: "Hello World",
          fontSize: 24,
          fill: "#000"
        });
      }
    };
    function a(c, ...l) {
      const h = o[c];
      return typeof h == "function" ? h(...l) : alert("Action not implemented");
    }
    return (c, l) => (J(), Fe(
      Mf,
      Ho(zo(e)),
      {
        ext: pn(() => [
          O("div", OO, [
            DO,
            O("div", PO, [
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: l[1] || (l[1] = (h) => a("runDemo"))
              }, " Run demo "),
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: l[2] || (l[2] = (h) => a("clearStage"))
              }, " Clear stage "),
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: l[3] || (l[3] = (h) => a("addRect"))
              }, " Add Rect "),
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: l[4] || (l[4] = (h) => a("addCircle"))
              }, " Add Circle "),
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: l[5] || (l[5] = (h) => a("addImage"))
              }, " Add Image "),
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: l[6] || (l[6] = (h) => a("addText"))
              }, " Add Text ")
            ])
          ])
        ]),
        default: pn(() => [
          O("ul", AO, [
            (J(!0), gt(
              Go,
              null,
              ru(s.value, (h) => (J(), gt("li", {
                key: h.name
              }, [
                O("a", {
                  onClick: (d) => r(h)
                }, [
                  (J(), Fe(Hh(h.icon()))),
                  O(
                    "span",
                    null,
                    gr(h.name),
                    1
                    /* TEXT */
                  )
                ], 8, IO)
              ]))),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          i.value ? (J(), Fe(Hh(i.value.component()), {
            key: 0,
            "tool-name": i.value.name,
            onClose: l[0] || (l[0] = (h) => i.value.active = !1)
          }, null, 40, ["tool-name"])) : xe("v-if", !0)
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ));
  }
}), MO = { class: "menu xpix-prop-menu" }, RO = /* @__PURE__ */ O(
  "span",
  null,
  "Color",
  -1
  /* HOISTED */
), pD = /* @__PURE__ */ $e({
  __name: "Shape",
  props: {
    activeBlock: {}
  },
  setup(n) {
    const t = n, { editor: e } = sn();
    async function s() {
      const i = t.activeBlock;
      i && e.updateBlock(i, {
        fill: i.fill === "#0A0" ? "#F00" : "#0A0"
      });
    }
    return (i, r) => (J(), Fe(
      Mf,
      Ho(zo(t)),
      {
        default: pn(() => [
          O("ul", MO, [
            O("li", null, [
              O("a", {
                onClick: r[0] || (r[0] = (o) => s())
              }, [
                fe(bt(W_)),
                RO
              ])
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ));
  }
}), $O = { class: "menu xpix-prop-menu" }, NO = /* @__PURE__ */ O(
  "span",
  null,
  "Crop",
  -1
  /* HOISTED */
), LO = /* @__PURE__ */ O(
  "span",
  null,
  "Correct Deformation",
  -1
  /* HOISTED */
), UO = /* @__PURE__ */ O(
  "span",
  null,
  "Shadows",
  -1
  /* HOISTED */
), FO = /* @__PURE__ */ O(
  "span",
  null,
  "Cutout",
  -1
  /* HOISTED */
), BO = /* @__PURE__ */ O(
  "span",
  null,
  "1-Tap Unblur",
  -1
  /* HOISTED */
), VO = /* @__PURE__ */ O(
  "span",
  null,
  "Color",
  -1
  /* HOISTED */
), jO = /* @__PURE__ */ O(
  "span",
  null,
  "Paint Matting",
  -1
  /* HOISTED */
), GO = /* @__PURE__ */ O(
  "span",
  null,
  "Transparency",
  -1
  /* HOISTED */
), HO = { class: "xpix-editor-prop" }, zO = /* @__PURE__ */ O(
  "div",
  { class: "xpix-prop-header px-4 border-t border-b border-slate-700" },
  [
    /* @__PURE__ */ xe(' <h4 class="py-4">Tools</h4> ')
  ],
  -1
  /* HOISTED */
), WO = { class: "xpix-prop-main mx-4 py-5" }, gD = /* @__PURE__ */ $e({
  __name: "Image",
  props: {
    activeBlock: {}
  },
  setup(n) {
    const t = n, { editor: e, doc: s } = sn();
    async function i() {
      const o = t.activeBlock, a = await e.showOpenFilePicker();
      if (o) {
        const { blob: c } = await e.loadImage(a[0]), l = await e.addAsset(c);
        e.updateBlock(o, { assetId: l });
      }
    }
    function r() {
      e.removeBlock(t.activeBlock);
    }
    return (o, a) => (J(), Fe(
      Mf,
      Ho(zo(t)),
      {
        ext: pn(() => [
          O("div", HO, [
            zO,
            O("div", WO, [
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: a[0] || (a[0] = (c) => i())
              }, " Replace Image "),
              O("button", {
                type: "button",
                class: "btn mr-2 mb-2",
                onClick: a[1] || (a[1] = (c) => r())
              }, " Delete ")
            ])
          ])
        ]),
        default: pn(() => [
          O("ul", $O, [
            O("li", null, [
              O("a", null, [
                fe(bt(K_)),
                NO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(HT)),
                LO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(CI)),
                UO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(sA)),
                FO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(VA)),
                BO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(W_)),
                VO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(_A)),
                jO
              ])
            ]),
            O("li", null, [
              O("a", null, [
                fe(bt(kA)),
                GO
              ])
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ));
  }
});
export {
  QE as A,
  j_ as B,
  MI as C,
  as as D,
  qE as E,
  $I as F,
  BI as G,
  zI as H,
  QI as I,
  Gu as J,
  tO as K,
  c9 as S,
  NE as X,
  fD as _,
  Yl as a,
  vf as b,
  aD as c,
  Rx as d,
  Ux as e,
  Nx as f,
  ai as g,
  Z9 as h,
  b_ as i,
  yd as j,
  Nu as k,
  $x as l,
  h6 as m,
  gD as n,
  Mf as o,
  pD as p,
  dD as q,
  uD as r,
  hD as s,
  Lx as t,
  sn as u,
  Pf as v,
  cD as w,
  lD as x,
  XE as y,
  JE as z
};
